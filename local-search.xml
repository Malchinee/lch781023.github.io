<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基础补漏</title>
    <link href="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/"/>
    <url>/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h3 id="static-关键字："><a href="#static-关键字：" class="headerlink" title="+static 关键字："></a>+static 关键字：</h3><p>（不属于任何独立的对象）<br>1、静态变量：所有类共享一个地址<br>2、静态常量：如Math类中定义了PI，System.out静态常量<br>3、静态方法：不能向对象实时操作，如Math中的pow方法，不使用任何Ｍath对象。可以认 为静态方法是<strong>没有this参数的方法</strong>。它不能操作对象，但是可以访问自身类中的静态域，建议<strong>使用类名访问静态方法</strong>。</p><h3 id="java中方法参数的使用情况："><a href="#java中方法参数的使用情况：" class="headerlink" title="java中方法参数的使用情况："></a>java中方法参数的使用情况：</h3><p>1、一个方法不能修改一个基本数据类型的参数<br>2、一个方法可以改变一个对象参数的状态<br>3、一个方法不能让对象参数引用一个新的对象</p><h3 id="java调用构造器的具体处理步骤："><a href="#java调用构造器的具体处理步骤：" class="headerlink" title="java调用构造器的具体处理步骤："></a>java调用构造器的具体处理步骤：</h3><p>1、所有数据域被初始化为默认值（0、false或null）<br>2、按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块<br>3、如果构造器第一行调用了第二个构造器，则执行第二个构造器主体<br>4、执行这个构造器主体</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="Object类：所有类的超类"><a href="#Object类：所有类的超类" class="headerlink" title="Object类：所有类的超类"></a>Object类：所有类的超类</h3><h4 id="equals-方法："><a href="#equals-方法：" class="headerlink" title="equals()方法："></a>equals()方法：</h4><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/equals1.png" class><p>比较两个对象是否相等，如果两个对象指向同一块内存区域，方法返回true；否则方法返回false。自定义类中，应该覆盖这个方法。</p><p>在子类定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域</p><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/equals2.png" class><p>编写一个完美的equals方法的建议：</p><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/equals3.png" class><h4 id="hashCode-方法："><a href="#hashCode-方法：" class="headerlink" title="hashCode()方法："></a>hashCode()方法：</h4><p>由对象导出的一个整型值，无规律，两对象之间的hashCode基本不会相同</p><p>字符串的散列码由内容导出，StringBuffer类中没有定义hashCode方法，它的散列码由Object类默认的hasCode方法导出的对象存储地址。</p><p>需要组合多个散列值时，可以调用Objects.hash并提供多个参数，这个方法会对各个参数调用object.hashCode，并组合这些散列值如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> Object.<span class="hljs-title">hash</span><span class="hljs-params">(name,salary,hireDay)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>数组</strong>：使用静态的Arrays.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成。</p><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/hashCode.png" class><h4 id="toSting方法："><a href="#toSting方法：" class="headerlink" title="toSting方法："></a>toSting方法：</h4><p><strong>数组</strong>使用Arrays.toString()方法，生成字符串。</p><p>建议为自定义的每一个类增加toString方法</p><h4 id="泛型数组列表ArrayList"><a href="#泛型数组列表ArrayList" class="headerlink" title="泛型数组列表ArrayList"></a>泛型数组列表ArrayList</h4><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/ArrayList.png" class><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/ArrayList1.png" class><h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer a<span class="hljs-operator">=</span><span class="hljs-number">1000</span><span class="hljs-comment">;</span><br>Integer b<span class="hljs-operator">=</span><span class="hljs-number">1000</span><span class="hljs-comment">;</span><br>if(a<span class="hljs-operator">=</span><span class="hljs-operator">=</span>b)<br>.....<br></code></pre></td></tr></table></figure><p>上述代码java可能成立，解决的办法是在两个包装器对象比较时调用equals方法。</p><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/Integer1.png" class><img src="/2022/03/29/%E5%9F%BA%E7%A1%80%E8%A1%A5%E6%BC%8F/Integer2.png" class>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>java核心技术卷1</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IOC本质分析探究</title>
    <link href="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/"/>
    <url>/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC本质分析探究"><a href="#IOC本质分析探究" class="headerlink" title="IOC本质分析探究"></a>IOC本质分析探究</h1><h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p><strong>控制反转IOC</strong>是一种设计思想。没有IOC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系<strong>完全硬编码在程序中</strong>，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方。</p><h3 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h3><p>我们有4个类：<br>1、userDao接口</p><figure class="highlight aspectj"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> dao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">userDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2、userDaoImpl实现类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">package dao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">userDaoImpl</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">userDao</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> getUser()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;默认获取用户数据&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>3、userService业务接口</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">userService</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>4、userServiceImpl业务实现类</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> service;<br><br><span class="hljs-keyword">import</span> dao.userDao;<br><span class="hljs-keyword">import</span> dao.userDaoImpl;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userServiceImpl</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">userService</span></span></span>&#123;<br>    <span class="hljs-keyword">private</span> userDao userDao=<span class="hljs-keyword">new</span> <span class="hljs-type">userDaoImpl</span>() ;<br><br>    <span class="hljs-keyword">public</span> void getUser()&#123;<br>        userDao.getUser();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/contest.png" class><p>main方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> service.<span class="hljs-property">userServiceImpl</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        userServiceImpl userService=<span class="hljs-keyword">new</span> <span class="hljs-title function_">userServiceImpl</span>();<br>        userService.<span class="hljs-title function_">getUser</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行项目，得到结果：</p><img src="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/result1.png" class><p><strong>若新的需求：增加mysql的实现</strong>，此时代码又需要修改：<br>添加userDaoMysql类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">package dao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">userDaoImpl</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">userDao</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> getUser()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;默认获取用户数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且改变userServiceImpl类：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userServiceImpl</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">userService</span></span></span>&#123;<br>    <span class="hljs-keyword">private</span> userDao userDao=<span class="hljs-keyword">new</span> <span class="hljs-type">userDaoMysql</span>() ;<br><br>    <span class="hljs-keyword">public</span> void getUser()&#123;<br>        userDao.getUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的运行结果为：</p><img src="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/result2.png" class><p><strong>如果又有新的需求，userServiceImp类又需要修改。但是实际改变可能需要几十个类，如此下去工程量很大</strong></p><p>上述是通过程序创建对象，<strong>利用set进行动态值的注入</strong>，用户实际上调用的是业务层，dao层不需要接触</p><img src="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/set%E6%B3%A8%E5%85%A5.png" class><img src="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/123456789.png" class><p><strong>在之前的代码中，用户需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码</strong>，如果代码量大，修改代码的成本会十分昂贵。<strong>我们使用set接口实现</strong>，现在控制权在用户手上，程序<strong>由主动变成被动接受对象</strong></p><p>这种思想从本质上解决问题，程序员不需要管理对象的创建了，系统耦合性大大降低，可以专注于业务的实现，这就是IOC的原型</p><img src="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/789456.png" class><p>IOC是spring框架的核心内容，使用多种方式完美实现IOC，可以使用xml配置，也可以使用注解</p><p>spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IOC容器中取出需要的对象</p><img src="/2022/03/25/IOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/qwe.png" class><p>采用xml方式配置bean的时候，bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的</p><p><strong>控制反转是一种通过描述（xml或注解）并通过第三方去生产或获取特定对象的方式。在spring中实现控制反转的是IOC容器，其实现方法是依赖注入</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚幻4入门</title>
    <link href="/2022/03/22/%E8%99%9A%E5%B9%BB4%E5%85%A5%E9%97%A8/"/>
    <url>/2022/03/22/%E8%99%9A%E5%B9%BB4%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="虚幻4工程文件夹的结构"><a href="#虚幻4工程文件夹的结构" class="headerlink" title="虚幻4工程文件夹的结构"></a>虚幻4工程文件夹的结构</h3><div class="code-wrapper"><pre><code class="hljs">Config ：包含项目设置，键盘输入之类的配置文件Content ：存放引擎或游戏内容，包括地图、贴图、模型、材质、蓝图等Intermediate 包含了在编译引擎或游戏时生成的临时文件Saved 包含了自动保存内容，配置（*.ini）文件以及日志文件.uproject 项目启动程序，开启项目</code></pre></div><img src="/2022/03/22/%E8%99%9A%E5%B9%BB4%E5%85%A5%E9%97%A8/%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90.png" class>]]></content>
    
    
    <categories>
      
      <category>虚幻4</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring入门</title>
    <link href="/2022/03/07/Spring/"/>
    <url>/2022/03/07/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-入门"><a href="#Spring-入门" class="headerlink" title="Spring 入门"></a>Spring 入门</h1><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><div class="code-wrapper"><pre><code class="hljs">1、开源免费框架2、轻量级、非入侵式3、控制反转（IOC），面向切面编程（AOP）4、支持事务的处理，对框架整合的支持！</code></pre></div><h3 id="Spring-组成"><a href="#Spring-组成" class="headerlink" title="Spring 组成"></a>Spring 组成</h3><img src="/2022/03/07/Spring/Spring%E7%BB%84%E6%88%90.png" class><img src="/2022/03/07/Spring/java%E8%B7%AF%E7%BA%BF.png" class><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><div class="code-wrapper"><pre><code class="hljs">一个快速开发的脚手架基于SpringBoot可以快速开发单个微服务约定大于配置</code></pre></div><h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><div class="code-wrapper"><pre><code class="hljs">SpringClud基于SpringBoot实现</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
