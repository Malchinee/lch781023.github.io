<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230103165644870.png" class title="image-20230103165644870"><p>f[i][j]表示只看前i个物品，总体积是j的情况下，总价值最大是多少（选法的集合）</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">result = max&#123;f[n][<span class="hljs-number">0</span>~V]&#125;<br><br>f[i][j]:<br><span class="hljs-number">1.</span> 不选第i个物品，f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br><span class="hljs-number">2.</span> 选第i个物品,f[i][j] = f[i - <span class="hljs-number">1</span>][j - v[i]];<br>f[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>原始版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i])&#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) res = <span class="hljs-built_in">max</span>(res, f[n][i]);<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>f[i]的状态只与f[i - 1]有关，所以用一维数组表示，内层遍历时从大到小遍历，优化后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-type">int</span> v[N], w[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dp[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230103200640387.png" class title="image-20230103200640387"><p>状态表示：f[i][j]——所有只考虑前i个物品，且总体积不大于j的所有选法</p><p>状态转移：集合划分</p><ul><li>不选第i个物品：f[i - 1][j]</li><li>选了1个</li><li>选了2个</li><li>·········</li><li>选了k个：max(f[i - 1, j - k <em> v[ i]] + k </em> w[i])</li></ul><p>朴素解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k++) &#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过数学推导，可以简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i])f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续优化，删除一维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= m; j++) &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与01背包的区别：</p><ul><li>01背包都从i - 1层转移过来</li><li>完全背包都从i 层转移过来</li><li><strong>01背包第二层从大到小(m ~ v[i])循环，完全背包第二层从小到大循环(v[i] ~ m)</strong></li></ul><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230103231626379.png" class title="image-20230103231626379"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> v[N], w[N], s[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dp[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-comment">// 穷举第i个物品的情况，与上面相比多了一重循环</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dp[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包II"><a href="#多重背包II" class="headerlink" title="多重背包II"></a>多重背包II</h2><p>背景与上题类似，考察多重背包的二进制优化做法</p><p>假如要从一堆苹果中选出1027个，那就先准备10个框，里面分别装1， 2， 4， 8， 16……..1024个</p><p>然后选前9个框，共1023个再另选4个苹果，这样选择的次数就是13次，大大减少选的次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12010</span>, M = <span class="hljs-number">2010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N]; <span class="hljs-comment">//逐一枚举最大是N*logS</span><br><span class="hljs-type">int</span> f[M]; <span class="hljs-comment">// 体积&lt;M</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//分组的组别</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; <span class="hljs-comment">// 组别里面的个数</span><br>        <span class="hljs-keyword">while</span>(k&lt;=s)<br>        &#123;<br>            cnt ++ ; <span class="hljs-comment">//组别先增加</span><br>            v[cnt] = a * k ; <span class="hljs-comment">//整体体积</span><br>            w[cnt] = b * k; <span class="hljs-comment">// 整体价值</span><br>            s -= k; <span class="hljs-comment">// s要减小</span><br>            k *= <span class="hljs-number">2</span>; <span class="hljs-comment">// 组别里的个数增加</span><br>        &#125;<br>        <span class="hljs-comment">//剩余的一组</span><br>        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a*s; <br>            w[cnt] = b*s;<br>        &#125;<br>    &#125;<br><br>    n = cnt ; <span class="hljs-comment">//枚举次数正式由个数变成组别数</span><br><br>    <span class="hljs-comment">//01背包一维优化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n ;i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ;j &gt;= v[i];j --)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]] + w[i]);<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230104202530187.png" class title="image-20230104202530187"><p>与前面的不同：有了组的概念，并且每组只能选一个物品</p><p>01背包的变种：第一重循环循环物品，第二重循环循环体积，只不过每次选每组中的一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> dp[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> s;<br>        cin &gt;&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s; j++) cin &gt;&gt; v[j] &gt;&gt; w[j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; s; k++) &#123;<br>                <span class="hljs-keyword">if</span>(j &gt;= v[k]) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[k]] + w[k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dp[m] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230104210118241.png" class title="image-20230104210118241"><p>方法：从下到上考虑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][j] : 从底向上走到(i, j)的所有路线的集合,表示路径和的最大值<br></code></pre></td></tr></table></figure><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230104211012403.png" class title="image-20230104211012403"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> dp[N][N], w[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++) cin &gt;&gt; w[i][j];<br>    &#125;    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) dp[n][i] = w[n][i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) + w[i][j];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230105194736696.png" class title="image-20230105194736696"><p>集合：dp[i]：所有以第i个数结尾的数值上升的子序列的集合<br>属性：上升的子序列的长度的最大值</p><p>状态计算：<script type="math/tex">a_i、a_j</script>是倒数的两个数，j∈(1, 2, …, i)，在w[i] &gt; w[j]时，dp[i] = max(dp[i], dp[j] + 1);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N], dp[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j] &lt; a[i]) &#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长上升子序列II"><a href="#最长上升子序列II" class="headerlink" title="最长上升子序列II"></a>最长上升子序列II</h2><p>与上题不同的是N的数量变大，时间复杂度要求严格</p><p>遍历每一个数a[i]，对于当前的数a[i]，先找到一个最大的小于a[i]的数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n ;i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前的最大长度</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span>&gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(dp[mid] &lt; a[i]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        len = <span class="hljs-built_in">max</span>(len, r + <span class="hljs-number">1</span>);<br>        dp[r + <span class="hljs-number">1</span>] = a[i];<br>    &#125;<br>    <br>    cout &lt;&lt; len &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106152127695.png" class title="image-20230106152127695"><p>状态表示：</p><p>dp[i][j]:所有A[1~ i]和B[1 ~ j]的所有子序列的集合，表示集合里所有公共子序列的长度的最大值</p><p>用0、1表示A[i]、B[j]是否包含在子序列中</p><p>11：只有当a[i] = [j]时才存在</p><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106153735715.png" class title="image-20230106153735715"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a + <span class="hljs-number">1</span> &gt;&gt; b + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dp[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106155829733.png" class title="image-20230106155829733"><p>状态表示：dp[i][j]：所有将a[1 ~ i]变成b[1 ~ j]的操作方式的最小值</p><ul><li>操作1：删除a[i]，要想删除之后完全匹配，先做到a[1 ~ i - 1]和b[1 ~ j]匹配，即dp[i - 1][j] + 1</li><li>操作2：添加a[i]，要想做到添加完之后完全匹配，那么添加之前应该a[1 ~ i]和b[1 ~ j - 1]匹配，那么再加上b[j]就可以匹配，即dp[i, j - 1] + 1</li><li>操作3：修改a[i]<ul><li>如果a[i] 、b[j]相等那么就不需要变了</li><li>如果不相等就得让a[1 ~ i - 1]和b[1 ~ j - 1]匹配，即dp[i - 1][j - 1] + 1;</li></ul></li></ul><p>总共的最小值就是以上三类取最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; a + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; b + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) dp[<span class="hljs-number">0</span>][i] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) dp[i][<span class="hljs-number">0</span>] = i;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dp[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106163236997.png" class title="image-20230106163236997"><p>主要代码和上一题的一样，主要别把n、m和la、lb弄混</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15</span>, M = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">char</span> str[M][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">edit_distance</span><span class="hljs-params">(<span class="hljs-type">char</span> a[], <span class="hljs-type">char</span> b[])</span> </span>&#123;<br>    <br>    <span class="hljs-type">int</span> la = <span class="hljs-built_in">strlen</span>(a + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> lb = <span class="hljs-built_in">strlen</span>(b + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= la; i ++) dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= lb; i ++) dp[<span class="hljs-number">0</span>][i] = i;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= la; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lb; j++) &#123;<br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[la][lb];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str[i] + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">char</span> s[N];<br>        <span class="hljs-type">int</span> limit;<br>        cin &gt;&gt; s + <span class="hljs-number">1</span> &gt;&gt; limit;<br>        <br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++ )&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">edit_distance</span>(str[i], s) &lt;= limit) res ++;<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106173302024.png" class title="image-20230106173302024"><p>合并只能合并相邻两堆，那么左右两边的两堆一定是连续的，所以才可以用dp去做</p><p>dp[ i ][ j ]所有将[i , j]合并成一堆的方案的集合，表示所有方案的最小代价</p><p>从分界点开始考虑：</p><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106174135096.png" class title="image-20230106174135096"><p>分成两大堆：[i ~ k]、[k + 1 ~ j]</p><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106174201769.png" class title="image-20230106174201769"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s[N];   <span class="hljs-comment">//前缀和</span><br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; s[i], s[i] += s[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 区间dp：先枚举区间长度，再枚举区间左端点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            dp[i][j] = <span class="hljs-number">1e8</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i; k &lt; j ;k ++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + s[j] - s[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h1><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230106193417483.png" class title="image-20230106193417483"><p>容量为n的一个背包；一共有n个物品，每个物品的体积为<script type="math/tex">1, 2, 3,...,n</script>，求的是恰好装满背包的方案数，每种物品可以用无限次，属于<strong>完全背包问题</strong></p><p>dp[ i ] [ j ]表示从集合1 ~ i中选，体积为j的选法的数量</p><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230107103450852.png" class title="image-20230107103450852"><p>又因为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - i] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span> * i]+ ... +dp[i - <span class="hljs-number">1</span>][j - s * i];<br>dp[i][j - i] = dp[i - <span class="hljs-number">1</span>][j - i] + dp[i - <span class="hljs-number">1</span>][j - i * <span class="hljs-number">2</span>] + ... + dp[i - <span class="hljs-number">1</span>][j * s * i];<br></code></pre></td></tr></table></figure><p>得出完全背包的状态转移：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - i];<br></code></pre></td></tr></table></figure><p>去掉一维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] = (dp[j] + dp[j - i]) % mod;<br></code></pre></td></tr></table></figure><p>最终代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// 完全背包问题，遍历物品从小到大遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= n; j++) &#123;<br>            dp[j] = (dp[j] + dp[j - i]) % mod;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[n] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种：</p><p>dp[ i ][ j ]表示所有总和是 i ，并且恰好表示成j个数的和的方案数量</p><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230107105529593.png" class title="image-20230107105529593"><p>左边：拿出一个1，总和为i - 1， 个数为 j - 1；</p><p>右边：每个数都减去1，总和为i - j， 个数为还是 j 个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - j][j];<br>    <br>ans = dp[n][<span class="hljs-number">1</span>] + dp[n][<span class="hljs-number">2</span>] + ... + dp[n][n];<br></code></pre></td></tr></table></figure><p>最终代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>            dp[i][j] = (dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - j][j]) % mod; <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res = (res + dp[n][i]) % mod;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><h2 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h2><img src="/2023/01/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230107110856503.png" class title="image-20230107110856503">]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>算法基础课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索与图论</title>
    <link href="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    <url>/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="排列数字"><a href="#排列数字" class="headerlink" title="排列数字"></a>排列数字</h2><p>DFS搜索顺序可以看成一条树：</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230102105756709.png" class title="image-20230102105756709"><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(u == n) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, path[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) &#123;<br>            path[u] = i;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 恢复现场(回溯)</span><br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n-皇后问题"></a>n-皇后问题</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230102111954361.png" class title="image-20230102111954361"><p>已知一行只能有一个皇后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// 棋盘</span><br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-comment">// 表示列、主对角线、副对角线</span><br><span class="hljs-type">bool</span> col[N], dg[N], udg[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(u == n) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)  <span class="hljs-built_in">puts</span>(g[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123;<br>            g[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n - u + i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            col[i] = dg[u + i] = udg[n - u + i] = <span class="hljs-literal">false</span>;<br>            g[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) g[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>更原始的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> row[N], col[N], dg[N], udg[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(y == n) y = <span class="hljs-number">0</span>, x++;<br>    <br>    <span class="hljs-keyword">if</span>(x == n) &#123;<br>        <span class="hljs-keyword">if</span>(s == n) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">puts</span>(g[i]);<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不放皇后</span><br>    <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s);<br>    <br>    <span class="hljs-comment">//放皇后</span><br>    <span class="hljs-keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n]) &#123;<br>        g[x][y] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s + <span class="hljs-number">1</span>);<br>        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="hljs-literal">false</span>;<br>        g[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>宽搜可以搜到最短路</p><p>基本框架：一般是用队列记录所有可以走的地方，然后每次取出队列头，再看这个点的周围有哪些地方可以走，继续入队</p><ol><li>队列</li><li>每个状态的距离如何表示</li></ol><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> g[N][N], d[N][N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br>queue&lt;PII&gt; q;<span class="hljs-comment">// 用队列记录上下左右能走的地方</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> x = t.first + dx[i], y = t.second + dy[i];<br>            <br>            <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="hljs-number">0</span> &amp;&amp; d[x][y] == <span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">// 发现可以走的地方</span><br>                d[x][y] = d[t.first][t.second] + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) cin &gt;&gt; g[i][j];<br>    <br>    <br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230102154810426.png" class title="image-20230102154810426"><ol><li>队列：queue\<string></string></li><li>距离dist:unordered_map<stirng, int> </stirng,></li></ol><p>步骤：</p><ol><li>将字符串转化成3*3的矩阵</li><li>枚举’X’的上下左右移动的情况</li><li>移动之后的矩阵恢复成字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string start)</span> </span>&#123;<br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; d;<br>    d[start] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <br>    string end = <span class="hljs-string">&quot;12345678x&quot;</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> distance = d[t];<br>        <span class="hljs-keyword">if</span>(t == end) <span class="hljs-keyword">return</span> distance;<br>        <span class="hljs-type">int</span> k = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);<br>    <br>        <span class="hljs-type">int</span> x = k / <span class="hljs-number">3</span>, y = k % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span>(a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span> &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; <span class="hljs-number">3</span>) &#123;<br>                <br>                <span class="hljs-built_in">swap</span>(t[k], t[a * <span class="hljs-number">3</span> + b]);<br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(t)) &#123;<br>                    d[t] = distance + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(t);<br>                &#125;<br>                <span class="hljs-built_in">swap</span>(t[k], t[a * <span class="hljs-number">3</span> + b]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    string start;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>        <span class="hljs-type">char</span> c;<br>        cin &gt;&gt; c;<br>        start += c ;<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>(start) &lt;&lt; endl;<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树与图的DFS"><a href="#树与图的DFS" class="headerlink" title="树与图的DFS"></a>树与图的DFS</h1><p>dfs模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230103144215317.png" class title="image-20230103144215317"><p>依次枚举，求删除每一个节点后的连通块的节点数最大值，再取一个最小的</p><p>删除某个点可以将整个树分成三部分：</p><ul><li>左子树</li><li>右子树</li><li>它的父亲连带着其他的除上面的两个的所有</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">2</span> * N;<br><br><span class="hljs-type">int</span> e[M], ne[M], h[N], idx;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> ans = N;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, sum = <span class="hljs-number">1</span>;<span class="hljs-comment">// sum算上自己初始化为1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j]) &#123;<br>            <br>            <span class="hljs-comment">// 求子树</span><br>            <span class="hljs-type">int</span> s = <span class="hljs-built_in">dfs</span>(j);<br>            res = <span class="hljs-built_in">max</span>(res, s);<br>            sum += s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 删除这个节点后，各连通块的最大的节点数</span><br>    res = <span class="hljs-built_in">max</span>(res, n - sum);<br>    <br>    <span class="hljs-comment">// 挑最小的</span><br>    ans = <span class="hljs-built_in">min</span>(ans, res);<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b); <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230103153610162.png" class title="image-20230103153610162"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>           <span class="hljs-type">int</span> j =e[i];<br>           <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>) &#123;<br>               d[j] = d[t] + <span class="hljs-number">1</span>;<br>               q.<span class="hljs-built_in">push</span>(j);<br>           &#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230103162641496.png" class title="image-20230103162641496"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> e[N], ne[N], h[N], idx;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> d[N], q[N];   <span class="hljs-comment">// 入度</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;<br> <br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">-1</span>, hh = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 将所有入度为0的点入队</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!d[i]) &#123;<br>            q[++ tt] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt) &#123;<br>        <span class="hljs-keyword">auto</span> t = q[hh ++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            d[j] --;<br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">0</span>) q[++ tt] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 队列是否为空</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>        d[b] ++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">topsort</span>()) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++ )&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, q[i]);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230106200803584.png" class title="image-20230106200803584"><h2 id="朴素版本"><a href="#朴素版本" class="headerlink" title="朴素版本"></a>朴素版本</h2><p>朴素Dijkstra：</p><ol><li>距离初始化：dist[1] = 0，其余的dist设置为<script type="math/tex">+\infty</script></li><li>s集合为当前已经确定最短距离的点，t为不在s中的，距离最近的点，再将t加入到s中，用t更新其他点的距离dist</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> g[N][N], dist[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// t为没有被访问过的，离起点最近的点</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 用t更新所有点和1之间的距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆优化版本"><a href="#堆优化版本" class="headerlink" title="堆优化版本"></a>堆优化版本</h2><p>用堆找不在s中的，距离起点最近的点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span> * <span class="hljs-number">1.5</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N], ne[N], w[N], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br>    <br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br>        <br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])  &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>    <br>&#125;<br>    <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h1><p>边的存边方式比较随意，可以定义一个结构体</p><p>第一层for循环n次，表示最多不超过n条边</p><p>进行下一层循环之前先备份，backup存储上一次更新迭代的dist，防止出现串联（每一次更新的dist应该是一个整体，如果前面的数用dist更新，那么后面的数在更新的时候会使用前面的dist，这样就不对了）</p><p>第二层循环所有边(a, b, w)，可以遍历所有结构体dist[b] = min(dist[b], dist[a] +w)（松弛操作），即求下图：</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230107114724507.png" class title="image-20230107114724507"><p>最后所有dist[b] &lt;= dist[a] + w，（三角不等式）</p><p>如果有负权回路（转一圈小于0），最短路就不存在了</p><h2 id="有边限制的最短路"><a href="#有边限制的最短路" class="headerlink" title="有边限制的最短路"></a>有边限制的最短路</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230107113417127.png" class title="image-20230107113417127"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;<br><br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> dist[N], backup[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>  <span class="hljs-type">int</span> a, b, w;  <br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-comment">// 备份</span><br>        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-type">int</span> a= edges[j].a, b = edges[j].b, w = edges[j].w;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + w);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 可能会碰到负数，这样即使它不大于0x3f，也不是最短路</span><br>    <span class="hljs-keyword">if</span>(dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        edges[i] = &#123;a, b, c&#125;;<br>    &#125;<br>    <br>   <span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h1><p>对bellma_ford算法用宽度优先搜索进行优化，dist[b] = min(dist[b], dist[a] + w)，不一定每次都会变小，队列里面存储所有变小的点：</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230107170509372.png" class title="image-20230107170509372"><h2 id="spfa求最短路"><a href="#spfa求最短路" class="headerlink" title="spfa求最短路"></a>spfa求最短路</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230107150737412.png" class title="image-20230107150737412"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx, w[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dist[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    w[idx] = c;<br>    h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">// 用队列存储所有待更新的点</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span>(!st[j]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa判断负环"><a href="#spfa判断负环" class="headerlink" title="spfa判断负环"></a>spfa判断负环</h2><p>更新时候dist[x] = dist[t] + w[i]</p><p>另设一个新数组cnt[x] = cnt[t] + 1</p><p>如果过程中的cnt[n] &gt;= n意味这从1~x经过了至少n条边，即至少n + 1个点，利用抽屉原理抽屉原理，那么就一定会有两个点是同一个点，即存在一个环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N], e[N], ne[N], w[N], idx;<br><span class="hljs-type">int</span> dist[N], cnt[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx ++;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// 1号点不一定能到负环，所以把所有点放进去</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; w[i] + dist[t]) &#123;<br>                dist[j] = w[i] + dist[t];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <br>                <span class="hljs-keyword">if</span>(cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <br>                <span class="hljs-keyword">if</span>(!st[j]) &#123;<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h1><p>前面三重循环，d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</p><p>基于动态规划</p><h2 id="Floyd求最短路"><a href="#Floyd求最短路" class="headerlink" title="Floyd求最短路"></a>Floyd求最短路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> n, m, Q;<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], w);<br>    &#125;<br>    <br>    <span class="hljs-built_in">floyd</span>();<br>    <br>    <span class="hljs-keyword">while</span>(Q --) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(d[a][b] &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; d[a][b] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h1><ol><li><p>初始化距离：将所有距离初始化成+<script type="math/tex">\infty</script></p></li><li><p>n次迭代</p></li><li><p>找到不在集合st中的距离的最小的点t，用t来更新其他点到集合的距离，最后将t加入到集合中</p></li></ol><h2 id="Prim算法求最小生成树"><a href="#Prim算法求最小生成树" class="headerlink" title="Prim算法求最小生成树"></a>Prim算法求最小生成树</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230108202705068.png" class title="image-20230108202705068"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> g[N][N], dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, INF, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++ ) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp;(t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-keyword">if</span>(i) res += dist[t];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b]  = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span>(t == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1><ol><li>将所有边按权重从小到大排序</li><li>从小到达枚举每条边a、b，权重c。如果a、b不连通，就将这条边加入到集合中（并查集）</li></ol><h2 id="Kruskal算法求最小生成树"><a href="#Kruskal算法求最小生成树" class="headerlink" title="Kruskal算法求最小生成树"></a>Kruskal算法求最小生成树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x != p[x]) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        edges[i] = &#123;a, b, w&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b= edges[i].b, w = edges[i].w;<br>        <br>        a= <span class="hljs-built_in">find</span>(a); b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span>(a != b) &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>一个图是二分图，当且仅当图中不含奇数环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span>( i 没被染色) &#123;<br><span class="hljs-built_in">dfs</span>(i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230108210759566.png" class title="image-20230108210759566"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2</span> * N;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[M], e[M], ne[M], idx;<br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">// 0 ：没被涂色； 1 、2 ：被涂了颜色</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    <span class="hljs-comment">// 涂色</span><br>    color[u] = c;<br>    <br>    <span class="hljs-comment">// 进行深搜</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-comment">// 如果下一个点没被涂色</span><br>        <span class="hljs-keyword">if</span>(!color[j]) &#123;<br>            <span class="hljs-comment">// 下一个点应该被涂成对立色</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(j, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果下一个点被涂了相同的颜色</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>        <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!color[i]) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>)) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/image-20230108215629428.png" class title="image-20230108215629428"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n1, n2, m;<br><span class="hljs-type">int</span> h[M], ne[M], e[M], idx;<br><span class="hljs-type">int</span> match[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-comment">// j没有被匹配过</span><br>        <span class="hljs-keyword">if</span>(!st[j]) &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)) res ++;<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>算法基础课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>做笔试时，不会采用动态链表的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span> () <span class="hljs-comment">//耗时太长</span><br></code></pre></td></tr></table></figure><p>笔试时采用数组模拟链表</p><ul><li>单链表：邻接表——存储图和树</li><li>双链表：优化某些问题</li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//head表示头节点的下标</span><br><span class="hljs-comment">// e[i]表示节点i的值</span><br><span class="hljs-comment">// ne[i]表示节点i的next值</span><br><span class="hljs-comment">// idx 存储当前用到哪个地址</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span> <span class="hljs-params">()</span> </span>&#123;<br>    <br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>    ne[idx] = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 将x插入到头节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <br>    e[idx] = x;<br>    ne[idx] = head;<br>    head = idx;<br>    idx ++;<br>    <br>&#125;<br><br><span class="hljs-comment">// 将x插入到下标是k的点的后面</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    e[idx] = x;<br>    ne[idx] = ne[k];<br>    ne[k] = idx;<br>    idx ++;<br>&#125;<br><br><span class="hljs-comment">// 删除下标是k的点的后面的点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 向第k个节点的右边插入x</span><br><span class="hljs-comment">// 向左边插入应该传入l[k]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <br>    e[idx] = x;<br>    r[idx] = r[k];<br>    l[idx] = k;<br>    l[r[k]] = idx;<br>    r[k] = idx ++;<br>&#125;<br><br><span class="hljs-comment">// 移除节点k</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>操作很简单</p><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; num;<br>stack&lt;<span class="hljs-type">char</span>&gt; op;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> b = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">auto</span> a = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">auto</span> c = op.<span class="hljs-built_in">top</span>(); op.<span class="hljs-built_in">pop</span>();<br>    <br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span>) x = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) x = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) x = a * b;<br>    <span class="hljs-keyword">else</span> x = a / b;<br>    <br>    num.<span class="hljs-built_in">push</span>(x);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; pr &#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<br>    string str;<br>    cin &gt;&gt; str;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">auto</span> c = str[i];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, j = i;<br>            <span class="hljs-keyword">while</span>(j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[j])) <br>                x = x * <span class="hljs-number">10</span> + str[j ++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i = j - <span class="hljs-number">1</span>;<br>            num.<span class="hljs-built_in">push</span>(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(c);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( c == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>() &amp;&amp; pr[op.<span class="hljs-built_in">top</span>()] &gt;= pr[c]) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<br>    <br>    cout &lt;&lt; num.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>同样数组模拟队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">-1</span>, tt = <span class="hljs-number">-1</span>; <span class="hljs-comment">//初始化</span><br>q[tt ++] = x;<span class="hljs-comment">//添加</span><br>hh++<span class="hljs-comment">//弹出</span><br>hh &lt; tt Not empty  <span class="hljs-comment">//判断是否为空</span><br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>作用：找到序列中每个数左边离它最近的且比它小的数</p><p>每次遇到数x时，先将栈中的所有大于等于它的数全部弹出，如果栈空，说明左边没有小于它的数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x) tt --;<br>        <span class="hljs-keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        stk[++ tt] = x;<br>    &#125;    <br></code></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><ol><li><p>先考虑用普通队列怎么做</p></li><li><p>将队列的冗余元素删掉 -&gt; 队列具有了单调性</p></li><li><p>可以用O(1)时间复杂度从队头/队尾取出最值</p></li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> a[N], q[N]; <br><span class="hljs-type">int</span> n, k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-comment">// 找窗口内的最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;<br>        q[++ tt] = i;<br>        <br>        <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);<br>        <br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <br>    <span class="hljs-comment">// 找窗口内的最大值</span><br>    hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh ++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;<br>        q[++ tt] = i;<br>        <br>        <span class="hljs-keyword">if</span>( i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>朴素算法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[N], p[N];<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        <span class="hljs-keyword">if</span>(s[i + j - <span class="hljs-number">1</span>] != p[j]) &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">next[i] = j   说明：<br>p[i, j] = p[i - j + <span class="hljs-number">1</span>, i]<br></code></pre></td></tr></table></figure><p>KMP算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">char</span> p[N], s[M];<br><span class="hljs-type">int</span> ne[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 求next数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>        ne[i] = j;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 匹配</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>]) j ++;<br>        <span class="hljs-keyword">if</span>(j == n) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i - n);<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p>用于快速存储字符串集合的数据结构</p><h2 id="Trie字符串统计"><a href="#Trie字符串统计" class="headerlink" title="Trie字符串统计"></a>Trie字符串统计</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>]; <span class="hljs-comment">//每个点的所有儿子</span><br><span class="hljs-type">int</span> cnt[N];  <span class="hljs-comment">// 数量    </span><br><span class="hljs-type">int</span> idx;    <span class="hljs-comment">//当前用到的下标，下标是0的点既是根节点、又是空节点</span><br><span class="hljs-type">char</span> str[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221227181532735.png" class title="image-20221227181532735"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">3000000</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-type">int</span> son[M][<span class="hljs-number">2</span>], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; ~i; i--) &#123;<br>        <span class="hljs-type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(!s) s = ++ idx; <span class="hljs-comment">//创建新节点</span><br>        p = s;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; ~i; i--) &#123;<br>        <span class="hljs-type">int</span> s = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[p][!s]) &#123;<br>            res += <span class="hljs-number">1</span> &lt;&lt; i;<br>            p = son[p][!s];<br>        &#125;<span class="hljs-keyword">else</span> p = son[p][s];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        cin &gt;&gt; q[i];<br>        <span class="hljs-built_in">insert</span>(q[i]);<br>    &#125;   <br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(q[i]));<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul><li>将两个集合合并</li><li>询问两个和元素是否在一个集合中</li></ul><p>基本原理：每个集合用一棵树来表示。根的比那好就是整个集合的编号。每个节点存储它的父节点</p><ul><li><p>如何判断树根：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p[x] = x<br></code></pre></td></tr></table></figure></li><li><p>如何求x的集合编号:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(p[x] != x) x = p[x];<br></code></pre></td></tr></table></figure></li><li><p>如何合并两个集合：</p><p>px是x的集合编号,py是y的编号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p[x] = y;<br></code></pre></td></tr></table></figure></li></ul><h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回x所在集合的编号 + 压缩路径</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 合并a所在集合和b所在集合</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><span class="hljs-comment">// 判断a和b是否在一个集合</span><br><span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h2 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221231204742418.png" class title="image-20221231204742418"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        p[i] = i;<br>        num[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// find函数:</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 连接操作：</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b)) <span class="hljs-keyword">continue</span>;<br>num[<span class="hljs-built_in">find</span>(b)] += num[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><span class="hljs-comment">// 查询a和b是否在同一连通块上</span><br>p[<span class="hljs-built_in">find</span>(a)] == p[<span class="hljs-built_in">find</span>(b)];<br><br><span class="hljs-comment">// 输出点a所在的连通块中点的数量：</span><br>num[<span class="hljs-built_in">find</span>(a)];<br></code></pre></td></tr></table></figure><h2 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221231210659175.png" class title="image-20221231210659175"><p>用并查集表示，它们都是树的形式，维护每个点到根节点的距离</p><p>通过每个点与根节点的关系，就能判断两节点之间的关系</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221231212724021.png" class title="image-20221231212724021"><p>与根节点的距离记为x，对x进行模三，然后：</p><ul><li>余1的点，可以吃根节点</li><li>余2的点，可以被根节点吃</li><li>余3的点，与根节点是同类</li></ul><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221231213821468.png" class title="image-20221231213821468"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(k --) &#123;<br>        <span class="hljs-type">int</span> t, x, y;<br>        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(x &gt; n || y &gt; n) res ++;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x), py = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 表示x和y是同类</span><br>                <span class="hljs-keyword">if</span>(px == py &amp;&amp; (d[x] - d[y]) % <span class="hljs-number">3</span>) res++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px != py) &#123;     <span class="hljs-comment">// x和y不在一个集合里面</span><br>                    p[px] = py;<br>                    d[px] = d[y] - d[x];<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;     <span class="hljs-comment">// 表示x吃y</span><br>                <span class="hljs-keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>) res++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px != py) &#123;     <span class="hljs-comment">// x和y不在一个集合里面</span><br>                    p[px] = py;<br>                    d[px] = d[y] + <span class="hljs-number">1</span> - d[x];<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当两元素不在一个集合时，d[px] 的求法：</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221231221218274.png" class title="image-20221231221218274"><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul><li><p>插入一个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">heap[++ size] = x;<br><span class="hljs-built_in">up</span>(size);<br></code></pre></td></tr></table></figure></li><li><p>求集合中的最小（大）值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">heap[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li><li><p>删除最小（大）值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">heap[<span class="hljs-number">1</span>] = head[size];<br>size--;<span class="hljs-comment">// 干掉最后一个点</span><br><span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 让1号点沉下去</span><br></code></pre></td></tr></table></figure></li><li><p>删除任意一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">heap[k] = heap[size];<br>size --;<br><span class="hljs-built_in">down</span>(k); <span class="hljs-built_in">up</span>(k); <span class="hljs-comment">// 只会执行一个</span><br></code></pre></td></tr></table></figure></li><li><p>修改任意一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">head[k] = x;<br><span class="hljs-built_in">down</span>(k); <span class="hljs-built_in">up</span>(k);<br></code></pre></td></tr></table></figure></li></ul><p>用一位数组存储，下标从1开始，对于一个下标为k的点，左儿子为2k，右儿子为2k+1</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230101111309719.png" class title="image-20230101111309719"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> h[N], num;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= num &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= num &amp;&amp; h[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(u != t) &#123;<br>        <span class="hljs-built_in">swap</span>(h[t], h[u]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++ ) cin &gt;&gt; h[i];<br>    num = n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">down</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, h[<span class="hljs-number">1</span>]);<br>        h[<span class="hljs-number">1</span>] = h[num];<br>        num --;<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230101121001142.png" class title="image-20230101121001142"><p>ph[k] 存的是第k个插入的值在堆中的下标，hp[k]存的是堆里面下标是k的点对应的下表是xx</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230101114235476.png" class title="image-20230101114235476"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">// 交换</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]], ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= num &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= num &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(t != u) &#123;<br>        <span class="hljs-built_in">heap_swap</span>(t, u);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(u / <span class="hljs-number">2</span> &amp;&amp; h[u / <span class="hljs-number">2</span>] &gt; h[u]) &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u / <span class="hljs-number">2</span>, u);<br>        u /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 主要流程：</span><br> <span class="hljs-keyword">while</span>(n --) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span> k, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(op,<span class="hljs-string">&quot;I&quot;</span>)) &#123;<span class="hljs-comment">// 插入新节点</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            m ++;<br>            num ++;<br>            ph[m] = num, hp[num] = m;<br>            h[num] = x;<br>            <span class="hljs-built_in">up</span>(num);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;PM&quot;</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, h[<span class="hljs-number">1</span>]);<span class="hljs-comment">//输出最小值</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;DM&quot;</span>)) &#123;<span class="hljs-comment">// 删除最小值</span><br>            <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>, num);<br>            num--;<br>            <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(op,<span class="hljs-string">&quot;D&quot;</span>)) &#123;<span class="hljs-comment">// 删除第k个插入的值</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>            k = ph[k];<br>            <span class="hljs-built_in">heap_swap</span>(k, num);<br>            num --;<br>            <span class="hljs-built_in">down</span>(k); <span class="hljs-built_in">up</span>(k);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 修改第k个插入的值</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);<br>            k = ph[k];<br>            h[k] = x;<br>            <span class="hljs-built_in">down</span>(k); <span class="hljs-built_in">up</span>(k);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h2><p>拉链法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>; <br><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-keyword">if</span> (e[i] == x) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);  <br><br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        string op;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; op &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;I&quot;</span>) &#123;<br>            <span class="hljs-built_in">insert</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(x)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>开放寻址法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>, null = <span class="hljs-number">0x3f3f3f3f</span>; <br><br><span class="hljs-type">int</span> h[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <br>    <span class="hljs-keyword">while</span>(h[k] != null &amp;&amp; h[k] != x) &#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k == N) k = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> h);  <br><br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        string op;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; op &gt;&gt; x;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;I&quot;</span>) &#123;<br>            h[k] = x;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(h[k] != null) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希-使用次数多"><a href="#字符串哈希-使用次数多" class="headerlink" title="字符串哈希(使用次数多)"></a>字符串哈希(使用次数多)</h2><p>将字符串转化成数字</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230101221522229.png" class title="image-20230101221522229"><p>将字符串看成一个P进制的数，然后再转化成10进制的数，这样就可以将任何一个字符串映射为一个0~Q-1的数字</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230101221350201.png" class title="image-20230101221350201"><p>其中，当p = 131或13331，Q = <script type="math/tex">2^{64}</script>时，一般不会产生哈希冲突</p><p>已知h[R]和h[L - 1]的值，求[l, r]的哈希值：<script type="math/tex">h[R]- h[L] * p^{R - L + 1}</script></p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230101222307316.png" class title="image-20230101222307316"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, P = <span class="hljs-number">131</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> str[N];<br>ULL h[N], p[N];<br><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; str + <span class="hljs-number">1</span>;<br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m --) &#123;<br>        <span class="hljs-type">int</span> l1, r1, l2, r2;<br>        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l1, r1) == <span class="hljs-built_in">get</span>(l2, r2)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>算法基础课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225184417149.png" class title="image-20221225184417149"><p>快排模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> q[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x = q[(l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>        <span class="hljs-keyword">do</span> i ++;  <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j --;  <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(l, i - <span class="hljs-number">1</span>, q);<br>    <span class="hljs-built_in">quick_sort</span>(i, r, q);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第k个数"><a href="#第k个数" class="headerlink" title="第k个数"></a>第k个数</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225184512979.png" class title="image-20221225184512979"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> q[l];<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(sl &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(l, j, k);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(j + <span class="hljs-number">1</span>, r, k - sl);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225194942046.png" class title="image-20221225194942046"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> q[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid, q);<br>    <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r, q);<br>    <br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt; q[j]) tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++) q[i] = tmp[j++];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="逆序对的数量"><a href="#逆序对的数量" class="headerlink" title="逆序对的数量"></a>逆序对的数量</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225195637618.png" class title="image-20221225195637618"><p>要注意此题的数值范围，要用long long类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> q[N], tmp[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <br>    <br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <br>    LL res = <span class="hljs-built_in">merge_sort</span>(l, mid) + <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &gt; q[j]) &#123;<br>            tmp[k++] = q[j++];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> tmp[k++] = q[i++];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>        q[i] = tmp[j];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>模板：</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225201446079.png" class title="image-20221225201446079"><p>注意当 l = mid的时候，可能会陷入死循环，必须得 + 1</p><h2 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225201547657.png" class title="image-20221225201547657"><p>要找出左边界和右边界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, q, k;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; q;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">while</span>(q--) &#123;<br>        cin &gt;&gt; k;<br>        <br>        <span class="hljs-comment">//找左边界</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[mid] &gt;= k) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(a[l] != k) cout &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">//找有边界</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(a[mid] &lt;= k) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            cout &lt;&lt; r &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a>数的三次方根</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225204003821.png" class title="image-20221225204003821"><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225204051146.png" class title="image-20221225204051146"><p>模板代码：</p><p>注意终止条件和最后的格式化输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">double</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n;  <br>    <br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-10000</span>, r = <span class="hljs-number">10000</span>;<br>    <br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-8</span>) &#123;<br>        <span class="hljs-type">double</span> mid = (l + r ) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &gt;= n) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><p>存储：采用大端法，数字的高位保存在数组的高位，即个位保存在vector\<int>的第一位</int></p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225211802809.png" class title="image-20221225211802809"><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>add函数是重点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>; <span class="hljs-comment">//是否需要进位</span><br>    &#125;<br>    <span class="hljs-comment">//如果最后有进位，在最高位补1</span><br>    <span class="hljs-keyword">if</span>(t) res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">add</span>(A, B);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, C[i]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225211820710.png" class title="image-20221225211820710"><p>比较函数：（返回A是否大于等于B）</p><ol><li>当A和B的长度不相等时，判断A和B哪个长度大</li><li>当A和B的长度不相等时，从高位开始判断哪个数字大</li></ol><p>减法函数：</p><p>t表示是否从高位借位，1为需要，0为不需要，默认为0</p><p>同样从个位数开始相减</p><p>针对每次向结果中添加的t，当<script type="math/tex">t < 0</script>时，添加10 - t；当<script type="math/tex">t >= 0</script>时，添加t。可以用<script type="math/tex">(t + 10) \% 10</script> 代替，避免分类讨论</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A &gt;= B ?</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span>(A[i] != B[i]) <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 默认A &gt;= B</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        res.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">pop_back</span>(); <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225215223597.png" class title="image-20221225215223597"><p>这里只是一个很多位数的×一个位数比较小的</p><p>与加法类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>存储方式与加减乘一样</p><p>除法从高位开始算，结果需要反转一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; A;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span> </span>&#123;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        res.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><p>以下的数组下标全从1开始</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221225235036134.png" class title="image-20221225235036134"><p>前缀和就是数列的前n项和</p><p>生成时:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>[l, r]的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[r] - s[l - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h2 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226000156078.png" class title="image-20221226000156078"><p>生成s[i]时:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br></code></pre></td></tr></table></figure><p>算子矩阵时：(第二幅图中的阴影)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[x2][y2] - s[x1 - <span class="hljs-number">1</span>][y2] - s[x2][y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226001408407.png" class title="image-20221226001408407"><p>目的是让O(n)复杂度变成O(1)</p><p>应用在让[l, r]上的每个数都加c</p><p>首先写出insert函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造b数组时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">insert</span>(i, i, a[i]);<br></code></pre></td></tr></table></figure><p>计算时:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">insert</span>(l, r, c);<br></code></pre></td></tr></table></figure><p>计算完成之后同时别忘记还原a数组:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">b[i] += b[i - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h2 id="差分矩阵"><a href="#差分矩阵" class="headerlink" title="差分矩阵"></a>差分矩阵</h2><p>比如要给数组阴影部分全部加上常数c</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226104720069.png" class title="image-20221226104720069"><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226002854832.png" class title="image-20221226002854832"><p>insert函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">b[x1][y1] += c;<br>b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N], b[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>            <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q--) &#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2, c;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(x1, y1, x2, y2, c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            b[i][j] += b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            cout &lt;&lt; b[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>模板：</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226104911468.png" class title="image-20221226104911468"><h2 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h2><p>用一个数组s存放a[i]的个数，如果数据过于分散可以用哈希表</p><p>i和j都是从左往右移动，当发现s[a[i]] &gt; 1时，说明有元素重复，j到i的这一段一定不是不重复子串</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226110714696.png" class title="image-20221226110714696"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        s[a[i]] ++;<br>        <span class="hljs-keyword">while</span>(s[a[i]] &gt; <span class="hljs-number">1</span>) &#123;<br>            s[a[j]] --;<br>            j ++;<br>        &#125;<br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; res ;<br></code></pre></td></tr></table></figure><h2 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226112750337.png" class title="image-20221226112750337"><p>i指A数组从左往右，j指B数组从右往左，利用单调性</p><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226114158638.png" class title="image-20221226114158638"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>       <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[i] + b[j] &gt; x) &#123;<br>           j --;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(a[i] + b[j] == x) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226115836277.png" class title="image-20221226115836277"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; m) &#123;<br>        <span class="hljs-keyword">if</span>(a[i] == b[j]) i++;<br>        j++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(i == n) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226120015732.png" class title="image-20221226120015732"><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226121019709.png" class title="image-20221226121019709"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> x;<br>       cin &gt;&gt; x;<br>       <span class="hljs-keyword">while</span>(x)&#123;<br>           x -= <span class="hljs-built_in">lowbit</span>(x);<br>           res++;<br>       &#125;<br>       cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><img src="/2023/01/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/image-20221226163636258.png" class title="image-20221226163636258"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300010</span>;<br><span class="hljs-type">int</span> a[N], s[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; alls;<br>vector&lt;PII&gt; add, query;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//前缀和从1开始</span><br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>&#125; <br><br>vector&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-function">iterator <span class="hljs-title">unique</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(!i || a[i] != a[i - <span class="hljs-number">1</span>]) <br>            a[j ++] = a[i];<br>        <span class="hljs-comment">//a[0] ~ a[j - 1] 所有a中不重复的数</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">begin</span>() + j;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x, c;<br>        cin &gt;&gt; x &gt;&gt; c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x, c&#125;);<br>        <br>        alls.<span class="hljs-built_in">push_back</span>(x);<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l ,r&#125;);<br>        <br>        alls.<span class="hljs-built_in">push_back</span>(l);<br>        alls.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br>    <br>    <span class="hljs-comment">//去重</span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls), alls.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">//处理插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : add) &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(item.first);<br>        a[x] += item.second;<br>    &#125;<br>    <br>    <span class="hljs-comment">//预处理前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= alls.<span class="hljs-built_in">size</span>(); i++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>    <br>    <span class="hljs-comment">//处理询问</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : query)&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(item.first), r = <span class="hljs-built_in">find</span>(item.second);<br>        cout &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h1><h2 id="区间和并-1"><a href="#区间和并-1" class="headerlink" title="区间和并"></a>区间和并</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; &amp;segs)</span> </span>&#123;<br>    <br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; res;<br>    <br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; seg : segs) &#123;<br>        <span class="hljs-keyword">if</span>(ed &lt; seg.first) &#123;<br>            <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first;<br>            ed = seg.second;<br>        &#125;<span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>    <br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>算法基础课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用</title>
    <link href="/2022/12/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/12/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>主旨：</p><ol><li><p>先构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中</p></li><li><p>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行IO操作时，该函数才返回。</p><p>这个函数是阻塞的；函数对文件描述符的检测的操作是由内核完成的</p></li><li><p>在返回时，它告诉进程有多少（哪些）描述符进行IO操作</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="hljs-params">                  fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br>- 参数：<br>        -nfds:委托内核检测的最大文件描述符的值+<span class="hljs-number">1</span><br>        -readfds：要检测的文件描述符的读的集合，委托内核检测哪些文件符的属性<br>            - 一般检测读操作<br>            - 对应的是发送方发送过来的数据，因为读是接收数据，检测的是读缓冲区<br>            - 是一个传入传出参数<br>        -writefds:要检测的文件描述符的写的集合，委托内核检测哪些文件符的属性<br>            委托内核检测写缓冲区是不是还可以写数据<br>        -exceptfds：检测发生异常的文件描述符的集合<br>        -timeout：设置的超时时间<br>    - 返回值：<br>       <span class="hljs-number">-1</span>：失败<br>        &gt;<span class="hljs-number">0</span>：检测的集合中有n个文件描述符发生了变化<br><span class="hljs-comment">//将参数文件描述符fd对象的标志位设置为0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">//判断对应的标志位是0还是1</span><br><span class="hljs-type">int</span>  <span class="hljs-title function_">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">//讲参数文件描述符fd对应的标志位设置为1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">//fdset一共有1024bit，全部初始化为0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FD_ZERO</span><span class="hljs-params">(fd_set *<span class="hljs-built_in">set</span>)</span>;<br></code></pre></td></tr></table></figure><p>实现服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建一个fd_set的集合，存放的是需要检测的文件描述符</span><br>   fd_set rdset, tmp;<br>   FD_ZERO(&amp;rdset);<br>   FD_SET(lfd, &amp;rdset);<br>   <span class="hljs-type">int</span> maxfd = lfd;<br><br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>       tmp = rdset;<br>       <span class="hljs-comment">//调用select系统函数让内核检测哪些文件描述符有数据</span><br>       <span class="hljs-type">int</span> ret = select(maxfd + <span class="hljs-number">1</span>, &amp;tmp, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>       <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>           perror(<span class="hljs-string">&quot;select&quot;</span>);<br>           <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">continue</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">//检测到了有文件描述符的对应的缓冲区的数据发生了改变</span><br>           <span class="hljs-keyword">if</span>(FD_ISSET(lfd, &amp;tmp)) &#123;<br>               <span class="hljs-comment">//有新的客户端连接进来</span><br>               <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>               <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>               <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>               <span class="hljs-comment">//将新的文件描述符加入到rdset中</span><br>               FD_SET(cfd, &amp;rdset);<br>               <span class="hljs-comment">//更新最大的文件描述符</span><br>               maxfd = maxfd &gt; cfd ? maxfd : cfd;<br>           &#125;<br><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = lfd + <span class="hljs-number">1</span>; i &lt;= maxfd; i++)&#123;<br>               <span class="hljs-keyword">if</span>(FD_ISSET(i, &amp;tmp)) &#123;<br>                   <span class="hljs-comment">//说明文件描述符对应的客户端发来了数据</span><br>                   <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>                   <span class="hljs-type">int</span> len = read(i, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>                   <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)&#123;<br>                       perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                       <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed ...\n&quot;</span>);<br>                       close(i);<br>                       FD_CLR(i, &amp;rdset);<br>                   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read buf : %s\n&quot;</span>, buf);<br>                       write(i, buf, <span class="hljs-built_in">strlen</span>(buf));<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>select的缺点：</p><ul><li>每次需要将fds从用户态拷贝到内核态</li><li>每次调用select都需要在内核遍历传递进来的所有fd</li><li>select支持的文件描述符数量太小，默认1024</li><li>fds集合不能重用，每次都需要重置</li></ul><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll基本上是对select的改进</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>               <span class="hljs-type">int</span>   fd;       <span class="hljs-comment">/* 委托内核检测的文件描述符 */</span><br>               <span class="hljs-type">short</span> events;   <span class="hljs-comment">/* 委托内核检测文件描述符的什么事件 */</span><br>               <span class="hljs-type">short</span> revents;  <span class="hljs-comment">/* 文件描述符实际发生的事件 */</span><br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span>;<br>- 参数：<br>        -fds：需要检测的文件描述符的集合<br>        -nfds：第一个参数数组中最后一个有效元素的下标+<span class="hljs-number">1</span><br>        -timeout：阻塞时长<br>    - 返回值：<br>        <span class="hljs-number">-1</span>：失败<br>        &gt;<span class="hljs-number">0</span>:成功，检测的集合中有n个文件描述符发生变化<br></code></pre></td></tr></table></figure><p>poll多路复用编写服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化检测的文件描述符的数组</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>[1024];</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++)&#123;<br>       fds[i].fd = <span class="hljs-number">-1</span>;<br>       fds[i].events = POLLIN;<br>   &#125;<br>   fds[<span class="hljs-number">0</span>].fd = lfd; <br><br>   <span class="hljs-type">int</span> nfds = <span class="hljs-number">0</span>; <span class="hljs-comment">//最大的文件描述符的索引</span><br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-comment">//调用poll系统函数</span><br>       <span class="hljs-type">int</span> ret = poll(fds, nfds + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>       <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>           perror(<span class="hljs-string">&quot;poll&quot;</span>);<br>           <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">continue</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">//检测到了有文件描述符的对应的缓冲区的数据发生了改变</span><br>           <span class="hljs-keyword">if</span>(fds[<span class="hljs-number">0</span>].revents &amp; POLLIN) &#123;<br>               <span class="hljs-comment">//有新的客户端连接进来</span><br>               <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>               <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>               <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>               <span class="hljs-comment">//将新的文件描述符加入到rdset中</span><br>               <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1024</span>; i++)&#123;<br>                   <span class="hljs-keyword">if</span>(fds[i].fd == <span class="hljs-number">-1</span>)&#123;<br>                       fds[i].fd = cfd;<br>                       fds[i].events = POLLIN;<br>                       <span class="hljs-keyword">break</span>;<br>                   &#125;<br>               &#125;<br>               <span class="hljs-comment">//更新最大的文件描述符</span><br>               nfds = nfds &gt; cfd ? nfds : cfd;<br>           &#125;<br><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nfds; i++)&#123;<br>               <span class="hljs-keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;<br>                   <span class="hljs-comment">//说明文件描述符对应的客户端发来了数据</span><br>                   <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>                   <span class="hljs-type">int</span> len = read(fds[i].fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>                   <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)&#123;<br>                       perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                       <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed ...\n&quot;</span>);<br>                       close(fds[i].fd);<br>                       fds[i].fd = <span class="hljs-number">-1</span>;<br>                   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read buf : %s\n&quot;</span>, buf);<br>                       write(fds[i].fd, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>);<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br>   close(lfd);<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>每次都需要将fd集合拷贝到内核态</li><li>每次需要在内核遍历传进来的所有fd</li></ul><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-comment">//创建一个新的epoll实例，在内核中创建了一个数据</span><br><span class="hljs-comment">//红黑树、就绪列表（存放检测到数据发送改变的文件描述符信息）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br>-参数： size无意义<br>    -返回值：文件描述符<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span>&#123;</span><br>    <span class="hljs-type">void</span>     *ptr;<br>    <span class="hljs-type">int</span>       fd;<br>    <span class="hljs-type">uint32_t</span>  u32;<br>    <span class="hljs-type">uint64_t</span>  u64;<br>&#125;<span class="hljs-type">epoll_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>     events;  <span class="hljs-comment">//事件</span><br>    <span class="hljs-type">epoll_data_t</span> data;   <span class="hljs-comment">//用户数据信息</span><br>&#125;;<br>常见的epoll检测事件：<br>    - EPOLLIN<br>    - EPOLLOUT<br>    - EPOLLERR<br><span class="hljs-comment">//对epoll实例进行管理，添加文件描述符信息，删除信息，修改信息</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br>- 参数：<br>        - epfd:epoll实例对应的文件描述符<br>        - op：要进行什么操作<br>        EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD<br>        - fd：要检测的文件描述符<br>        - event：检测文件描述符具体的事情<br><span class="hljs-comment">//检测函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br>- 参数：<br>        - epfd：epoll实例对应的文件描述符<br>        - events：传出参数，保存了发生了变化的文件描述符的信息<br>        - maxevents：第二个参数结构体数组的大小<br>        - timeout：阻塞时间<br>        <span class="hljs-number">0</span>：不阻塞；<span class="hljs-number">-1</span>：阻塞，直到检测到数据发生变化；&gt;<span class="hljs-number">0</span>:阻塞时长<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//调用epoll_create创建一个epoll实例</span><br>  <span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">100</span>);<br><br>  <span class="hljs-comment">//将监听的文件描述符的相关的检测信息添加到epoll实例中</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epev</span>;</span><br>  epev.events = EPOLLIN;<br>  epev.data.fd = lfd;<br>  epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epevs</span>[1024];</span><br>  <br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><br>      <span class="hljs-type">int</span> ret = epoll_wait(epfd, epevs, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<br>      <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>          perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>      &#125;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>, ret);<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)&#123;<br><br>          <span class="hljs-type">int</span> curfd = epevs[i].data.fd;<br><br>          <span class="hljs-keyword">if</span>(curfd == lfd)&#123;<br>              <span class="hljs-comment">//监听的文件描述符有数据到达，有客户端连接</span><br>              <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>              <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>              <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>              epev.events = EPOLLIN;<br>              epev.data.fd = cfd;<br>              epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//有数据到达</span><br>              <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>              <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>);<br>              <span class="hljs-type">int</span> len = read(curfd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>              <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) &#123;<br>                  perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                  <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>              &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed ...\n&quot;</span>);<br>                  epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="hljs-literal">NULL</span>);<br>                  close(curfd);<br>              &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read buf : %s\n&quot;</span>, buf);<br>                  write(curfd, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>);<br>              &#125;<br>          &#125;<br>      &#125;<br>  &#125;<br>  close(lfd);<br>  close(epfd);<br></code></pre></td></tr></table></figure><p>epoll的工作模式：</p><ul><li><p>LT模式：水平触发</p><p>假设委托内核检测读事件-&gt;检测fd的读缓冲区</p><div class="code-wrapper"><pre><code class="hljs"> 读缓冲区有数据-&gt;epoll检测到了会给用户通知</code></pre></div><p>​            a.用户不读数据，数据一直在缓冲区，epoll会一直通知</p><p>​            b.用户只读了一部分数据，epoll会通知</p><p>​            c.缓冲区的数据读完了，不通知</p></li><li><p>ET模式：边沿触发</p><p>假设委托内核检测读事件-&gt;检测fd的读缓冲区</p><p>​    读缓冲区有数据-&gt;epoll检测到了会给用户通知</p><p>​        a.用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了</p><p>​        b.用户只读了一部分数据，epoll不通知</p><p>​        c.缓冲区的数据读完了，不通知</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>webServer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux多进程开发</title>
    <link href="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    <url>/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><p>进程是一个独立的资源分配单元。</p><ul><li><p><strong>二进制格式标识</strong>：每个程序文件都包含用于描述可执行文件格式的元信息，内核利用此信息来解释文件中的其他信息（ELF可执行连接格式）</p></li><li><p><strong>机器语言指令</strong>：对程序算法进行编码</p></li><li><p><strong>程序入口地址</strong>：标识程序开始执行时的起始指令位置</p></li><li><p><strong>数据</strong>：程序文件包含的变量初始值和程序使用的字面量值</p></li><li><strong>符号表及重定位表</strong>：描述程序中函数和变量的位置及名称</li><li><p><strong>共享库和动态链接信息</strong>：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名</p></li><li><p><strong>其他信息</strong>：程序文件还包括许多其他信息，用于描述如何创建进程</p></li></ul><p><strong>并行</strong>：在同一时刻，有多条指令在多个处理器上同时执行</p><p><strong>并发</strong>：在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB（进程控制块），用来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体</p><ul><li><strong>进程id</strong>：pid_t类型</li><li><strong>进程状态</strong>： 就绪、运行、挂起、停止</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述<strong>虚拟地址空间</strong>信息</li><li><p>描述<strong>控制终端</strong>的信息</p></li><li><p>当前工作目录</p></li><li>umask 掩码</li><li>文件描述符表，包含很多指向file的结构体的指针</li><li>和信号相关的信息</li><li>用户id和组id</li><li>会话Sesson和进程组</li><li>进程可以使用的资源上限</li></ul><h1 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h1><p>三态模型：就绪态、运行态、阻塞态</p><p>五态模型：新建态、就绪态、运行态、阻塞态、中止态</p><ul><li>运行态：进程占有处理器正在运行</li><li>就绪态：进程具备运行条件，等待系统分配处理器以便运行。</li><li>阻塞态：进程不具备运行条件，正在等待某个事件的完成</li></ul><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221202233047379.png" class title="image-20221202233047379"><ul><li>新建态：进程背创建时的状态，尚未进入就绪队列</li><li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取后，操作系统将删除该进程。</li></ul><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221203164901201.png" class title="image-20221203164901201"><p>查看进程信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">ps aux<br>ps ajx //显示父进程、组进程、会话id<br></code></pre></td></tr></table></figure><p>实时显示进程动态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top<br></code></pre></td></tr></table></figure><p>杀死进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill [-signal] pid<br>kill -l 列出所有信号<br>kill -SIGKILL 进程ID<br>kill -9 进程id<br><br>killall name 根据进程名称杀死进程<br></code></pre></td></tr></table></figure><h1 id="父子进程虚拟地址空间情况"><a href="#父子进程虚拟地址空间情况" class="headerlink" title="父子进程虚拟地址空间情况"></a>父子进程虚拟地址空间情况</h1><p>fork()以后，子进程的用户区和父进程一样，内核去也会拷贝过来，但是pid不同。创建子进程后，它们的代码区都是一样的，不是父进程独有pid&gt;0，子进程独有pid=0</p><p>linux的fork函数是通过<strong>写时拷贝</strong>实现。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。在需要写入时才会复制地址空间。</p><p>资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享，但是fork之后父子进程共享文件</p><h1 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">set follow-fork-mode child 设置默认跟踪子进程<br>show follow-fork-mode 查看当前跟踪的进程<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">set</span> detach<span class="hljs-literal">-on-fork</span> on/off<br></code></pre></td></tr></table></figure><p>默认为on，调试当前进程时候，其他进程继续执行；off表示其他进程被挂起</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">info inferiors 查看调试的进程<br>inferior id 切换当前调试的进程<br>detach inferiors id 使进程脱离gdb调试<br></code></pre></td></tr></table></figure><h1 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h1><p>exec函数族作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内存，就是在<strong>调用进程内部执行一个可执行文件</strong></p><p>exec 函数族的函数<strong>执行成功后不会返回</strong>，因为调用进程的实体，都被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回-1。</p><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221206160645458.png" class title="image-20221206160645458"><p>l：list，参数地址列表，以空指针结尾</p><p>v：vector，村有个参数地址的指针数组的地址</p><p>p：path，按path环境变量制定的目录搜索可执行文件</p><p>e：存有环境变量字符串地址的指针数组的地址</p><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h2><p>exit：标准C库；_exit：标准UNIX库</p><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221206162634026.png" class title="image-20221206162634026"><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>父进程运行结束，子进程还在运行</p><p>当出现孤儿进程时，内核就把孤儿进程的父进程设置为init，jinit进程会循环地wait()它的已经退出的子进程。</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程，僵尸进程不能被kill -9 杀死</p><p>如果父进程不调用wait()或者waitpid()的话，进程号会被一直占用</p><h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><p>每个进程退出的时候，内核释放该进程的所有资源，包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息</p><p>父进程可以调用wait、waitpid得到它的退出状态同时清楚掉这个进程</p><p>wait()和waitpid()功能一样，<strong>wait()会阻塞</strong>，<strong>waitpid()可以设置不阻塞</strong></p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span> <span class="hljs-params">(<span class="hljs-type">int</span> *wstatus)</span>;<br><span class="hljs-comment">//参数为进程的退出状态，不接受就用NULL</span><br><span class="hljs-comment">//成功返回回收子进程的id，失败返回-1</span><br></code></pre></td></tr></table></figure><h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(pid_ pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br><span class="hljs-comment">//回收指定子进程</span><br>wait(&amp;status) = waitpid(<span class="hljs-number">-1</span>, &amp;status,<span class="hljs-number">0</span>);<br><span class="hljs-comment">//pid &lt; -1, 回收某个进程组的组id的绝对值</span><br><span class="hljs-comment">//pid = -1，回收所有子进程中的一个</span><br><span class="hljs-comment">//pid &gt; 0，回收指定的pid进程</span><br><span class="hljs-comment">//pid = 0，回收当前进程组的任意一个进程</span><br><span class="hljs-comment">//options:0表示阻塞，WNOHANG表示非阻塞</span><br><span class="hljs-comment">//返回值大于0为成功，-1为失败</span><br></code></pre></td></tr></table></figure><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>同一主机进程间</p><ul><li>UNIX进程间通信方式：匿名管道、有名管道、信号</li><li>System V进程间通信方式：消息队列、共享内存、信号量</li></ul><p>不同主机间：Socket</p><h2 id="匿名管道PIPE"><a href="#匿名管道PIPE" class="headerlink" title="匿名管道PIPE"></a>匿名管道PIPE</h2><p>所有的UNIX系统都支持。</p><p>例如统计一个目录中文件的数目命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls | wc -l<br></code></pre></td></tr></table></figure><p>shell创建了两个进程来执行ls和wc</p><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221206212000288.png" class title="image-20221206212000288"><ul><li><p>管道是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力有限。</p></li><li><p>管道拥有的文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</p></li><li><p>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</p></li><li><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</p></li><li><p>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</p></li><li>从管道读数据时一次性操作的，数据一旦被独奏，它就从管道中被抛弃，释放空间以便写更多的数据</li><li>匿名管道只能在具有共同祖先的进程之间使用</li></ul><p>管道的数据结构：<strong>循环队列</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span>;<br><span class="hljs-comment">//pipefd[0]读端，pipefd[1]写端</span><br><span class="hljs-comment">//成功返回0，失败返回-1</span><br></code></pre></td></tr></table></figure><p>管道默认是阻塞的；如果管道中没有数据，read阻塞；如果管道满了，write阻塞。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ulimit -a 查看管道缓冲大小<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">fpathconf</span><span class="hljs-params">(pipefd[<span class="hljs-number">0</span>], <span class="hljs-type">int</span> name)</span>;<br><span class="hljs-comment">//查看管道缓冲大小</span><br></code></pre></td></tr></table></figure><p>设置管道为非阻塞：（如将管道读端设置为非阻塞）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> flags = fcntl(fd[<span class="hljs-number">0</span>], F_GETFL);  <span class="hljs-comment">//获取原来的flag</span><br>flags |= O_NOBLOCK;                 <span class="hljs-comment">//设置新的flag</span><br>fcntl(fd[<span class="hljs-number">0</span>], F_SETFL, flags);       <span class="hljs-comment">//设置新的宏值</span><br></code></pre></td></tr></table></figure><p>匿名管道通信实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    实现 ps aux | grep xxx父子进程间通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    子进程： ps aux，子进程结束后，将数据发送给父进程</span><br><span class="hljs-comment">    父进程： 获取到数据，过滤</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//创建一个管道</span><br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(fd);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//父进程</span><br>        <span class="hljs-comment">//从管道里读取</span><br>        close(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>((len = read(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//过滤数据输出</span><br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br>           <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-number">1024</span>);<br>        &#125;<br>        wait(<span class="hljs-literal">NULL</span>);<br>        <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid  == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//子进程</span><br>        <span class="hljs-comment">//关闭读端</span><br>        close(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//文件描述符的重定向 stdout_fileno -&gt; fd[1]</span><br>        dup2(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<br>        <span class="hljs-comment">//执行ps auxaz  </span><br>        execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        perror(<span class="hljs-string">&quot;execlp&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="管道的读写特点"><a href="#管道的读写特点" class="headerlink" title="管道的读写特点"></a>管道的读写特点</h2><p>读管道：</p><ul><li>管道中有数据，read返回实际读到的字节数</li><li>管道中无数据<ul><li>写端被全部关闭，read返回0</li><li>写端没有完全关闭，read阻塞等待</li></ul></li></ul><p>写管道：</p><ul><li>管道读端全部被关闭，进程异常终止（进程受到SIGPIPE信号）</li><li>管道读端没有全部关闭<ul><li>管道已满，write阻塞</li><li>管道没有满，write将数据写入，并返回实际写入的字节数</li></ul></li></ul><h2 id="有名管道FIFO"><a href="#有名管道FIFO" class="headerlink" title="有名管道FIFO"></a>有名管道FIFO</h2><p>有名管道(<strong>FIFO</strong>)可以在无亲缘关系的进程间通信。</p><p>不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中</p><p>与PIPE的不同之处</p><ul><li>FIFO是文件系统的特殊文件，内容存放于内存中</li><li>FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用</li><li>FIFO有名字，不相关的进程可以通过打开有名管道进行通信</li></ul><p>创建有名管道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfifo 名字<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br>- pathname: 管道名称的路径<br>- mode :文件的权限<br></code></pre></td></tr></table></figure><h2 id="内存映射Memory-mapped-I-O"><a href="#内存映射Memory-mapped-I-O" class="headerlink" title="内存映射Memory-mapped I/O"></a>内存映射Memory-mapped I/O</h2><p>将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-comment">//返回创建的内存的首地址，失败返回</span><br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><strong>void *addr：NULL</strong>，由内核指定</li><li><strong>length</strong>：要映射的数据的长度，建议使用文件的长度<br>  获取文件的长度：stat lseek</li><li><strong>prot</strong>：对申请的内存映射区的操作权限<ul><li>PROT_EXEC : 可执行</li><li>PROT_READ : 读</li><li>PROT_WRITE : 写</li><li>PROT_NONE : 没有权限<br>常用：PROT_READ、PROT_WRITE|PROT_READ</li></ul></li><li><strong>flags</strong>：<ul><li>MAP_SHARED ：映射区的数据会自动和磁盘文件进行同步</li><li>MAP_PRIVATE : 不同步</li></ul></li><li><strong>fd</strong> : 需要映射的那个文件的文件描述符<br>  通过open得到，文件的大小不为0，并且指定的权限不能和prot有冲突</li><li><strong>offset</strong> : 偏移量，一般不用，必须指定4K的整数倍</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;)<br><span class="hljs-comment">//释放内存映射</span><br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><strong>addr</strong>：释放的内存的首地址</li><li><strong>length</strong>：要释放的内存的值的大小，要和mmap函数中的值的大小一致</li></ul><p>一些问题：</p><ul><li>可以对mmap的返回值进行++操作，但是munmap()会错误</li><li>open()函数中的权限建一和PROT参数的权限保持一致</li><li>文件偏移量必须是1024的整数倍</li><li>mmap后关闭文件描述符，对mmap映射没有影响</li><li>ptr越界操作的是非法内存，属于段错误</li></ul><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>是事件发生时对进程的通知机制，有时称为<strong>软件中断</strong>，是一种异步通信的方式</p><p>使用信号的目的：</p><ul><li>让进程知道已经发生了一个特定的事情</li><li>强迫进程执行它自己代码中的信号处理程序</li></ul><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221208100340784.png" class title="image-20221208100340784"><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221208101612238.png" class title="image-20221208101612238"><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221208101802836.png" class title="image-20221208101802836"><img src="/2022/12/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/image-20221208101821351.png" class title="image-20221208101821351"><p>查看信号的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man 7 signal<br></code></pre></td></tr></table></figure><p>信号的五种默认处理动作</p><ul><li>Term : 终止进程</li><li>Ign : 当前进程忽略掉这个信号</li><li>Core : 终止进程，并生成一个Core文件</li><li>Stop：暂停当前进程</li><li>Cont：继续执行当前被暂停的进程</li></ul><p>信号的几种状态：产生、未决、递达</p><p>SIGKILL和SIGSTOP信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p><p>常用的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//给某个进程pid，发送某个信号sig</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span><br></code></pre></td></tr></table></figure><p>pid：&gt;0发给指定进程； =0发送给当前进程； =-1发送给每一个有权接收这个信号的进程； &lt;-1这个pid等于某个进程组的ID取反</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//给当前进程发送信号</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">reise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br></code></pre></td></tr></table></figure><p>sig：要发送的信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//发送SIGABORT信号发送给当前的进程，杀死当前的进程</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//设置定时器，函数调用时开始倒计时，当倒数计时为0时，函数给当前进程发送SIGALARM信号</span><br>unsighed <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br></code></pre></td></tr></table></figure><p>返回值：倒计时剩余的时间</p><p>SIGALARM ： 默认终止当前的进程，每一个进程都有且只有唯一的一个定时器</p><p>但是实际时间 = 内核时间 + 用户时间 + 消耗的时间</p><p>定时器与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时</p><p>多次调用alarm只会有一个生效，后定义的alarm会把前面的取消掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//设置定时器，代替alarm函数，精度为微秒，可以周期性定时</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_value, </span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> itimerval *old_value)</span>;<br></code></pre></td></tr></table></figure><p>which：定时器以什么时间计时</p><div class="code-wrapper"><pre><code class="hljs">- ITIME_REAL：真实时间SIGALRM- ITIME_VIRTUAL：用户时间，发送SIGVTALRM- ITIMER_PROF：以该进程在用户态和内核态下消耗的时间来计算，发送SIGPROF</code></pre></div><p>new_value ：设置定时器的属性</p><p>old_value：记录上一次的定时的时间参数</p><p>信号捕捉函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//设置某个信号的捕捉行为</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br></code></pre></td></tr></table></figure><p>signum： 要捕捉的信号</p><p>handler：捕捉到的信号要怎么处理</p><div class="code-wrapper"><pre><code class="hljs">- SIG_IGN:忽略信号- SIG_DFL:使用信号的默认行为- 回调函数：内核调用，程序员只负责写</code></pre></div><p>函数指针：int类型的参数表示捕捉到的信号的值</p><p>返回值</p><div class="code-wrapper"><pre><code class="hljs">- 成功：返回上一次注册的信号处理函数的地址。第一次返回NULL- 失败：返回SIG_ERR，设置错误号</code></pre></div><p>不能捕捉SIHKILL、SIGSTOP</p><h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>对自定义的信号集的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//清空信号集中的数据，将信号集中的所有的标志位记为0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">//将信号集中的所有数据标为1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">//将信号集的某一信号对应的标志位为1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">//将信号集的某一信号对应的标志位为1，表示不阻塞</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">//判断某个信号是否阻塞</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>,<span class="hljs-type">int</span> signum)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 检查或修改信号阻塞集，根据 how 指定的⽅法对进程的阻塞集合进⾏修改，</span><br><span class="hljs-comment">* 新的信号阻塞集由 set 指定，⽽原先的信号阻塞集合由 oldset 保存.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @param how 信号阻塞集合的修改⽅法，有 3 种情况:</span><br><span class="hljs-comment">* (1) SIG_BLOCK：向信号阻塞集合中添加 set 信号集，</span><br><span class="hljs-comment">* 新的信号掩码是set和旧信号掩码的并集。相当于 mask =</span><br><span class="hljs-comment">mask|set;</span><br><span class="hljs-comment">* (2) SIG_UNBLOCK：从信号阻塞集合中删除 set 信号集，</span><br><span class="hljs-comment">* 从当前信号掩码中去除 set 中的信号。相当于 mask = mask &amp; ~</span><br><span class="hljs-comment">set;</span><br><span class="hljs-comment">* (3) SIG_SETMASK：将信号阻塞集合设为 set 信号集，</span><br><span class="hljs-comment">* 相当于原来信号阻塞集的内容清空，然后按照 set 中的信号重新设置</span><br><span class="hljs-comment">信号阻塞集。相当于mask = set.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @set 要操作的信号集地址,若 set 为 NULL，则不改变信号阻塞集合，函数只把当前信</span><br><span class="hljs-comment">号阻塞集合保存到 oldset 中.</span><br><span class="hljs-comment">* @oldset 保存原先信号阻塞集地址.</span><br><span class="hljs-comment">* @return 成功: 0; 失败: -1，失败时错误代码只可能是 EINVAL，表示参数 how 不</span><br><span class="hljs-comment">合法.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webServer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.30</title>
    <link href="/2022/12/01/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-30/"/>
    <url>/2022/12/01/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-30/</url>
    
    <content type="html"><![CDATA[<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.<a href="https://leetcode.cn/problems/rotate-image/description/">旋转图像</a></h1><p>先将矩阵转置，然后再对每一行进行反转，最后得到的矩阵就是顺时针旋转90度的</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; n;j++)&#123;<br>                <span class="hljs-type">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> k = matrix[i].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(k &gt; j)&#123;<br>                <span class="hljs-type">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[i][k];<br>                matrix[i][k] = temp;<br>                j++;k--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.<a href="https://leetcode.cn/problems/merge-intervals/description/">合并区间</a></h1><p>先将区间按左边界从小到大排序，然后合并</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,vector&lt;<span class="hljs-type">int</span>&gt; b )</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> length = intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(),intervals.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; length;i++)&#123;<br>            <span class="hljs-type">int</span> begin = intervals[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//i-1的左边界</span><br>            <span class="hljs-type">int</span> end = intervals[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">//i-1的右边界</span><br>            <span class="hljs-keyword">while</span>(i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end)&#123;<span class="hljs-comment">//合并区间</span><br>                end = <span class="hljs-built_in">max</span>(end,intervals[i][<span class="hljs-number">1</span>]);<span class="hljs-comment">//选取i的右边界和上一个的end的最大值</span><br>                <span class="hljs-keyword">if</span>(i == length<span class="hljs-number">-1</span>) flag = <span class="hljs-literal">true</span>;<span class="hljs-comment">//到最后一个区间</span><br>                i++;<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(&#123;begin,end&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<span class="hljs-comment">//最后一个区间没有被合并</span><br>            result.<span class="hljs-built_in">push_back</span>(&#123;intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238.除自身以外数组的乘积"></a>238.<a href="https://leetcode.cn/problems/product-of-array-except-self/description/?languageTags=cpp">除自身以外数组的乘积</a></h1><p>双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size(),<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> , j = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++,j--)&#123;<br>            res[i] *= left;<br>            res[j] *= right;<br>            left *= nums[i];<br>            right *= nums[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.29</title>
    <link href="/2022/11/29/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-29/"/>
    <url>/2022/11/29/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-29/</url>
    
    <content type="html"><![CDATA[<h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.<a href="https://leetcode.cn/problems/counting-bits/">比特位计数</a></h1><p>偶数：dp[i] = dp[i/2]，i/2 相比 i 是右移一位，去掉末尾的0，他们的“1”的个数应该是一样的</p><p>奇数：dp[i] = dp[i-1]+1。相比上一个的偶数就是末尾加1</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = i;i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i] = dp[i/<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647.回文子串"></a>647.<a href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a></h1><p>i表示左边，j表示右边</p><ul><li>i与j下标相同，dp[i][j]为true</li><li>i与j下标差一个,dp[i][j]为true</li><li>其他情况，则判断dp[i+1][j-1]的情况，如果它为true，则dp[i][j]也为true</li></ul><p>初始化时全为false，就不用判断s[i]和s[j]不相等的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span> (n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>;i &gt;=<span class="hljs-number">0</span> ;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                    <span class="hljs-keyword">if</span>(j-i &lt;= <span class="hljs-number">1</span>)&#123;<br>                        result ++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>])&#123;<br>                        result ++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85.最大矩形"></a>85.<a href="https://leetcode.cn/problems/maximal-rectangle/description/?languageTags=cpp">最大矩形</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                    dp[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dp[i][j<span class="hljs-number">-1</span>]) +<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(m+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>                vec[i+<span class="hljs-number">1</span>] = dp[i][j];<br>            &#125;<br>            stack&lt;<span class="hljs-type">int</span>&gt; st;<br>            st.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; vec.<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-keyword">while</span>(vec[st.<span class="hljs-built_in">top</span>()] &gt; vec[i])&#123;<br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> h = vec[mid];<br>                    result = <span class="hljs-built_in">max</span>(result,w*h);<br>                &#125;<br>                st.<span class="hljs-built_in">emplace</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.28</title>
    <link href="/2022/11/28/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-28/"/>
    <url>/2022/11/28/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-28/</url>
    
    <content type="html"><![CDATA[<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.<a href="https://leetcode.cn/problems/maximal-square/description/?languageTags=cpp">最大正方形</a></h1><p>dp[i][j]表示以该点为右下角的顶点的最大的正方形的边长</p><p>选取左边、上边、做上边的最小值，这样右下角如果是2，最大的正方形边长就是2；如果是3，最大的正方形边长就是3.。。。依次类推。然后result记录这个最大的dp[i][j]的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span> &amp;&amp; n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            result = <span class="hljs-built_in">max</span>(result,dp[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>            result = <span class="hljs-built_in">max</span>(result,dp[<span class="hljs-number">0</span>][j]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j]),dp[i][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                result = <span class="hljs-built_in">max</span>(result,dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result*result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.<a href="https://leetcode.cn/problems/perfect-squares/description/?languageTags=cpp">完全平方数</a></h1><p>dp[i]由dp[i-j<em>j]推出,所以dp[i-j\</em>j]+1凑成dp[i]，每次选d[i-j*j]+1和dp[i]的最小值</p><p>外层遍历背包，内层遍历物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span> (n+<span class="hljs-number">1</span>,INT_MAX);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j*j &lt;= i;j++)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i-j*j]+<span class="hljs-number">1</span>,dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h1><p>设加法总和x，减法总和就sum-x，</p><p>题目要求x- ( sum - x ) = target ，所以x=(target+sum)/2</p><p>问题就是装满x容量的背包有几种方法</p><p>dp[j]表示填满j容量的背包有dp[j]种方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>((target+sum)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> bagSize = (target+sum)/<span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagSize+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagSize; j &gt;= nums[i];j--)&#123;<br>                dp[j] += dp[j-nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.27</title>
    <link href="/2022/11/27/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-27/"/>
    <url>/2022/11/27/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-27/</url>
    
    <content type="html"><![CDATA[<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152.乘积最大子数组"></a>152.乘积最大子数组</h1><p>dpMax[i]指的是以nums[i]为结尾的连续子数组乘积的最大值，dpMin[i]相反</p><p>如果nums[i] &gt;=0那么最大值就是dpMax[i-1]*nums[i]和nums[i]比较</p><p>如果nums[i] &lt; 0那么最大值就是dpMin[i-1]*nums[i]和dpMax[i-1]相比较，最小值乘以一个负数就是一个较大的正数</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpMax</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpMin</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dpMax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dpMin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result = dpMax[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)&#123;<br>            dpMax[i] = <span class="hljs-built_in">max</span>(nums[i],<span class="hljs-built_in">max</span>(dpMax[i<span class="hljs-number">-1</span>]*nums[i],dpMin[i<span class="hljs-number">-1</span>]*nums[i]));<br>            dpMin[i] = <span class="hljs-built_in">min</span>(nums[i],<span class="hljs-built_in">min</span>(dpMin[i<span class="hljs-number">-1</span>]*nums[i],dpMax[i<span class="hljs-number">-1</span>]*nums[i]));<br>            result = <span class="hljs-built_in">max</span>(result,dpMax[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.<a href="https://leetcode.cn/problems/coin-change/description/">零钱兑换</a></h1><p>dp[i]表示凑足i元至少需要dp[i]元，初始化dp为容量：amount+1，大小都为amount+1</p><p>外层for循环遍历背包多少钱，内层for循环遍历物品硬币</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>,amount+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; dp.<span class="hljs-built_in">size</span>();i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> coin : coins)&#123;<br>               <span class="hljs-keyword">if</span>(i - coin &lt; <span class="hljs-number">0</span>)&#123;<br>                   <span class="hljs-keyword">continue</span>;<br>               &#125;<br>               dp[i] = <span class="hljs-built_in">min</span>(dp[i],dp[i-coin]+<span class="hljs-number">1</span>);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> (amount+<span class="hljs-number">1</span> == dp[amount]) ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312.戳气球"></a>312.<a href="https://leetcode.cn/problems/burst-balloons/description/?languageTags=cpp">戳气球</a></h1><p>没看懂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//vector&lt;vector&lt;int&gt;&gt; dp;</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">1</span>);<br>nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> dp);<br><span class="hljs-comment">//dp.resize(510,vector&lt;int&gt;(510));</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt;= n - len + <span class="hljs-number">1</span>; l++) &#123;<br><span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l; k &lt;= r; k++) &#123;<br>dp[l][r] = <span class="hljs-built_in">max</span>(dp[l][r], dp[l][k - <span class="hljs-number">1</span>] + nums[l - <span class="hljs-number">1</span>] * nums[k] * nums[r + <span class="hljs-number">1</span>] + dp[k + <span class="hljs-number">1</span>][r]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n];<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.26</title>
    <link href="/2022/11/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-26/"/>
    <url>/2022/11/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-26/</url>
    
    <content type="html"><![CDATA[<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.<a href="https://leetcode.cn/problems/word-break/description/?languageTags=cpp">单词拆分</a></h1><p>dp[i]：字符串长度为i，dp[i]为true指可以拆分为在字典中出现的单词</p><p>递推公式：如果dp[j]是true且[j,i]这段字符串在字典中出现，则dp[i]就为true</p><p>所以主循环i从1到s.size()，然后j从0到i-1，外层遍历背包，内层遍历物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set <span class="hljs-title">wordSet</span> <span class="hljs-params">(wordDict.begin(),wordDict.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++)&#123;<br>                string str = s.<span class="hljs-built_in">substr</span>(j,i-j);<br>                <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(str) != wordSet.<span class="hljs-built_in">end</span>() &amp;&amp; dp[j])&#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.<a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">分割等和子集</a></h1><p>dp[j]表示最大可以凑成的j的子集总和为dp[j]，</p><p>target为 数组和/2</p><p>外层遍历背包，内层从target开始倒序遍历，试着减去nums[i]</p><p>最后判断dp[target]是否等于target，dp[target]=target</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//和为奇数，一定凑不起来</span><br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target;j &gt;= nums[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target] == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.<a href="https://leetcode.cn/problems/edit-distance/description/">编辑距离</a></h1><p>dp[i][j]表示长度为i-1的word1和长度为j-1的word2的最近编辑距离为dp[i][j]</p><p>递推时如果word1[i-1] == word2[j-1]，就让dp[i][j] = dp[i-1][j-1]</p><p>如果不相等，就执行增删改的操作dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1中取最小的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= word1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= word2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.25</title>
    <link href="/2022/11/25/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-25/"/>
    <url>/2022/11/25/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-25/</url>
    
    <content type="html"><![CDATA[<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h1><p>dp[i]表示到这家为止最高的抢的钱</p><p>对于dp[i]要么这家不抢，就是dp[i-1]，要么就是这家抢了，就是dp[i-2]+nums[i],两个去较大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>       <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>       <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>       dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>       dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span> (nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; n;i++)&#123;<br>           dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i],dp[i<span class="hljs-number">-1</span>]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="337-打家劫舍III"><a href="#337-打家劫舍III" class="headerlink" title="337.打家劫舍III"></a>337.打家劫舍III</h1><p>树形结构的dp，用一个两个大小的数组来记录这个节点的状态,dp[0]表示不偷，dp[1]表示偷</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; dp = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<br>        vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<br>        <span class="hljs-comment">//dp[0]表示不抢这个节点、dp[1]表示抢这个节点</span><br>        <span class="hljs-comment">//不偷这个节点，子节点都可以选择偷或者不偷</span><br>        <span class="hljs-type">int</span> val1 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>])+<span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">//偷这个节点</span><br>        <span class="hljs-type">int</span> val2 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;val1,val2&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; n;i++)&#123;<br>            <span class="hljs-comment">//i&lt;2的情况根据一般式推出来</span><br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>                dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],-prices[i]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//没持有，两种情况：前一天抛出或者前一天也没有</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>            <span class="hljs-comment">//持有股票，两种情况，前一天持有或者前前天买股票</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-2</span>][<span class="hljs-number">0</span>]-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.24</title>
    <link href="/2022/11/24/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-24/"/>
    <url>/2022/11/24/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-24/</url>
    
    <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.<a href="https://leetcode.cn/problems/maximum-subarray/description/?languageTags=cpp">最大子数组和</a></h1><p>直译（暴力解法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT_MIN;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            count += nums[i];<br>            <span class="hljs-keyword">if</span>(count &gt; result) result = count;<br>            <span class="hljs-keyword">if</span>(count &lt; <span class="hljs-number">0</span>) count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>动态规划：</p><p>dp[i]: 第i个位置的最大连续子串的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+nums[i],nums[i]);<br>            result = <span class="hljs-built_in">max</span>(result,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.<a href="https://leetcode.cn/problems/unique-paths/description/">不同路径</a></h1><p>动态规划：dp[i][j]表示有多少种路径，由于只能往右、下走，所以只能来源于dp[i-1][j]和dp[i][j-1]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.<a href="https://leetcode.cn/problems/minimum-path-sum/description/">最小路径和</a></h1><p>与上一题相似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//最上边和最左边只能有一种走法，只能是前一个dp＋现在的值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ;i &lt; n;i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-comment">//选出相邻的左边和上边的最小值</span><br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>])+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.23</title>
    <link href="/2022/11/23/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-23/"/>
    <url>/2022/11/23/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-23/</url>
    
    <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></h1><p>状态机：</p><p><script type="math/tex">i</script>表示第几天，$k$表示交易数的上限，<script type="math/tex">0、1</script>表示当天是不抛出还是抛出</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span> (dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>] , dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>]-prices[i]);<br>dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span> (dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i] , dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>只能买入一只股票，k为1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n ;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                dp[i][<span class="hljs-number">1</span>] = -prices[i]; <br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//今天没卖</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>            <span class="hljs-comment">//今天卖了</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.<a href="https://leetcode.cn/problems/climbing-stairs/description/">爬楼梯</a></h1><p>第<script type="math/tex">i</script>个楼梯=第<script type="math/tex">i-1</script>个楼梯  走一步 + 第<script type="math/tex">i-2</script>个楼梯 走两步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i] = dp[i<span class="hljs-number">-1</span>]+d[i<span class="hljs-number">-2</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n ;i++)&#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.<a href="https://leetcode.cn/problems/regular-expression-matching/description/?languageTags=cpp">正则表达式匹配</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;<span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(p.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;;i += <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; p.<span class="hljs-built_in">size</span>() || p[ i<span class="hljs-number">-1</span> ]!=<span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;<br>            dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-comment">//初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=s.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= p.<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j &lt; p.<span class="hljs-built_in">size</span>() &amp;&amp; p[j] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    dp[i][j] = dp[i][j<span class="hljs-number">-1</span>];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] || p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-2</span>] || p[j<span class="hljs-number">-2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    &#123;<br>                        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>                    &#125;<br>                    dp[i][j] = dp[i][j] || dp[i][j<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  dp[s.<span class="hljs-built_in">size</span>()][p.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.22</title>
    <link href="/2022/11/23/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-22/"/>
    <url>/2022/11/23/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-22/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><p>如果回文串的长度是奇数，则它有一个中心字符；如果是回文串的长度是偶数，则有两个中心字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//找到s[i]为中心的回文串</span><br>            string s1 = <span class="hljs-built_in">palindrome</span>(s,i,i);<br>            <span class="hljs-comment">//找到s[i],s[i+1]为中心的回文串</span><br>            string s2 = <span class="hljs-built_in">palindrome</span>(s,i,i+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//更新结果</span><br>            res = res.<span class="hljs-built_in">size</span>() &gt; s1.<span class="hljs-built_in">size</span>() ? res : s1;<br>            res = res.<span class="hljs-built_in">size</span>() &gt; s2.<span class="hljs-built_in">size</span>() ? res : s2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">palindrome</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[left] == s[right])&#123;<br>            left--;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>()+left+<span class="hljs-number">1</span>,s.<span class="hljs-built_in">begin</span>()+right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="240-搜索二维矩阵II"><a href="#240-搜索二维矩阵II" class="headerlink" title="240.搜索二维矩阵II"></a>240.搜索二维矩阵II</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!matrix.<span class="hljs-built_in">size</span>() || !matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//左上角和右上角</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target) i++;<span class="hljs-comment">//排除一行</span><br>            <span class="hljs-keyword">else</span> j--;<span class="hljs-comment">//排除一列</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h1><p>dp[i]为nums中第i个数结尾的最长子串的长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n ;i++)&#123;<br>            <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j] &gt; max &amp;&amp; nums[j<span class="hljs-number">-1</span>] &lt; nums[i<span class="hljs-number">-1</span>]) max = dp[j];<br>            &#125;<br>            dp[i] = max+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(),dp.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.21</title>
    <link href="/2022/11/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-21/"/>
    <url>/2022/11/21/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-21/</url>
    
    <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h1><p>二分查找，虽然数组整体不是有序的，但是它的局部是有序的。在常规的二分查找时查看当前以mid为分割位置分割出来的两个部分[left,mid]和[mid+1,right]哪个部分是有序的</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left  = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(target == nums[mid]) <span class="hljs-keyword">return</span> mid;<br>            <br>            <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[mid])&#123;<br>                <span class="hljs-comment">//target值在left和mid之间，将范围缩小至[left,mid-1]</span><br>                <span class="hljs-keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid])&#123;<br>                    right = mid <span class="hljs-number">-1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-comment">//讲范围缩小至[mid+1,right]</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//target的值介于mid和right之间，将范围缩小至[mid+1,right]</span><br>                <span class="hljs-keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right])&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将范围缩小至[left,mid-1]</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> leftBorder  = <span class="hljs-built_in">getLeftBorder</span>(nums,target);<br>        <span class="hljs-type">int</span> rightBorder = <span class="hljs-built_in">getRightBorder</span>(nums,target);<br>        <span class="hljs-keyword">if</span>(leftBorder == <span class="hljs-number">-2</span> || rightBorder == <span class="hljs-number">-2</span>) <span class="hljs-keyword">return</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">if</span>(rightBorder - leftBorder &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> &#123;leftBorder+<span class="hljs-number">1</span>,rightBorder<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLeftBorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftBorder = <span class="hljs-number">-2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                leftBorder = right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftBorder;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRightBorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> rightBorder = <span class="hljs-number">-2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>                rightBorder = left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rightBorder;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h1><p>不会</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//中位数 = （left + right）/2</span><br>        <span class="hljs-type">int</span> left = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> right = (m + n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">findKth</span>(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, left) + <span class="hljs-built_in">findKth</span>(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, right)) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>    <span class="hljs-comment">//在两个有序数组中找到第k个元素（例如找第一个元素，k=1，即nums[0]）</span><br>    <span class="hljs-comment">//i: nums1的起始位置 j: nums2的起始位置（i，j都是从0开始）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> i, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//若nums1为空（或是说其中数字全被淘汰了）</span><br>        <span class="hljs-comment">//在nums2中找第k个元素，此时nums2起始位置是j，所以是j+k-1</span><br>        <span class="hljs-keyword">if</span>(i &gt;= nums1.<span class="hljs-built_in">size</span>())    <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//nums2同理</span><br>        <span class="hljs-keyword">if</span>(j &gt;= nums2.<span class="hljs-built_in">size</span>())    <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">min</span>(nums1[i], nums2[j]);<br><br>        <span class="hljs-comment">//这两个数组的第K/2小的数字，若不足k/2个数字则赋值整型最大值，以便淘汰另一数组的前k/2个数字</span><br>        <span class="hljs-type">int</span> midVal1 = (i + k/<span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums1.<span class="hljs-built_in">size</span>()) ? nums1[i + k/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : INT_MAX;<br>        <span class="hljs-type">int</span> midVal2 = (j + k/<span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums2.<span class="hljs-built_in">size</span>()) ? nums2[j + k/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : INT_MAX;<br>        <span class="hljs-comment">//二分法核心部分</span><br>        <span class="hljs-keyword">if</span>(midVal1 &lt; midVal2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKth</span>(nums1, i + k/<span class="hljs-number">2</span>, nums2, j, k - k/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKth</span>(nums1, i, nums2, j + k/<span class="hljs-number">2</span>, k - k/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.20</title>
    <link href="/2022/11/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-20/"/>
    <url>/2022/11/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-20/</url>
    
    <content type="html"><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.<a href="https://leetcode.cn/problems/jump-game/description/">跳跃游戏</a></h1><p>不管跳几次，每次都取最大值，就是覆盖范围</p><p>局部最优解：每次取最大的跳跃步数；整体最优解：最后得到整体的最大覆盖范围，看能不能到达终点</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt;=cover;i++)&#123;<br>            cover = <span class="hljs-built_in">max</span>(cover,i + nums[i]);<br>            <span class="hljs-keyword">if</span>(cover &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.<a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">根据身高重建队列</a></h1><p>局部最优解：按身高高的，people的k来插入，插入操作过后的people满足队列属性</p><p>全局最优：最后都做完插入操作，整个队列都满足</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a,vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    &#125; <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; people.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>];<br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position,people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> que;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621.任务调度器"></a>621.任务调度器</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : tasks)&#123;<br>            cnt[item-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt_max = <span class="hljs-number">0</span>,equal_cnt_max = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item :cnt)&#123;<br>            cnt_max = <span class="hljs-built_in">max</span>(item , cnt_max);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">25</span> ;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(cnt_max == cnt[i])&#123;<br>                equal_cnt_max++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">max</span>((cnt_max<span class="hljs-number">-1</span>)*n+equal_cnt_max+cnt_max,(<span class="hljs-type">int</span>)tasks.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.19</title>
    <link href="/2022/11/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-19/"/>
    <url>/2022/11/19/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-19/</url>
    
    <content type="html"><![CDATA[<h1 id="671-合并二叉树"><a href="#671-合并二叉树" class="headerlink" title="671.合并二叉树"></a>671.<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">合并二叉树</a></h1><p>递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-literal">nullptr</span> &amp;&amp; root2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>((root1 != <span class="hljs-literal">nullptr</span> ? root1-&gt;val:<span class="hljs-number">0</span>) + (root2 != <span class="hljs-literal">nullptr</span> ? root2-&gt;val:<span class="hljs-number">0</span>));<br>        root-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1 != <span class="hljs-literal">nullptr</span> ? root1-&gt;left : <span class="hljs-literal">nullptr</span>,root2 != <span class="hljs-literal">nullptr</span>?root2-&gt;left:<span class="hljs-literal">nullptr</span>);<br>        root-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1 != <span class="hljs-literal">nullptr</span> ? root1-&gt;right : <span class="hljs-literal">nullptr</span>,root2 != <span class="hljs-literal">nullptr</span>?root2-&gt;right:<span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.<a href="https://leetcode.cn/problems/number-of-islands/description/">岛屿数量</a></h1><p>每发现一个岛屿(grid[i][j]=1) 就深搜让这块岛被淹（减少维护visited数组）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; grid.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    res ++;<br>                    <span class="hljs-built_in">dfs</span>(grid,i,j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= grid.<span class="hljs-built_in">size</span>() || j &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207.课程表"></a>207.<a href="https://leetcode.cn/problems/course-schedule/description/?languageTags=cpp">课程表</a></h1><p>拓扑排序，先创建一个邻接表和入度表，然后每次将入度为0的节点入队，删除这个节点和与之相关联的边，最后判断cnt是否与节点数相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegree</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses,v);<span class="hljs-comment">//构建临接表（用vector储存临接点，方便访问）</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prerequisites.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>indegree[prerequisites[i][<span class="hljs-number">0</span>]]++;<br>graph[prerequisites[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">0</span>]);<span class="hljs-comment">//存的是出边</span><br>&#125;<br><span class="hljs-comment">//将入度为0的顶点入队</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (indegree[i] == <span class="hljs-number">0</span>)<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> temp = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>cnt++;<br><span class="hljs-comment">//更新：</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[temp].<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>indegree[graph[temp][i]]--;<br><span class="hljs-keyword">if</span> (indegree[graph[temp][i]] == <span class="hljs-number">0</span>)<span class="hljs-comment">//放在这里做！只判断邻接点。</span><br>q.<span class="hljs-built_in">push</span>(graph[temp][i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt == numCourses;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.18</title>
    <link href="/2022/11/18/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-18/"/>
    <url>/2022/11/18/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-18/</url>
    
    <content type="html"><![CDATA[<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.<a href="https://leetcode.cn/problems/subsets/description/">子集</a></h1><p>回溯</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(<span class="hljs-number">0</span>,nums);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex,vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(i+<span class="hljs-number">1</span>,nums);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79.单词搜索"></a>79.<a href="https://leetcode.cn/problems/word-search/description/">单词搜索</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[i].<span class="hljs-built_in">size</span>(); j++)<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,word,<span class="hljs-number">0</span>,i,j)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <br>    &#125;<br>    <span class="hljs-type">int</span> u[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, v[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">//方向数组</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string&amp; word,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(board[x][y] != word[index]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(index == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//将访问过的节点标为&#x27;.&#x27;</span><br>        <span class="hljs-type">char</span> temp = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-comment">//寻找上下左右四个位置</span><br>            <span class="hljs-type">int</span> a = x + u[i], b = y + v[i];<br>            <span class="hljs-comment">//出界或者走到已经搜索过的位置</span><br>            <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= board.<span class="hljs-built_in">size</span>() || b &lt; <span class="hljs-number">0</span> || b &gt;= board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || board[a][b] == <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,word,index+<span class="hljs-number">1</span>,a,b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//回溯</span><br>        board[x][y] = temp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="301-删除无效括号"><a href="#301-删除无效括号" class="headerlink" title="301.删除无效括号"></a>301.<a href="https://leetcode.cn/problems/remove-invalid-parentheses/description/?languageTags=cpp">删除无效括号</a></h1><p>不会，看题解的</p><p>三步：</p><ol><li>获取不合法的左右括号数</li><li>判断当前的字符串是否合法</li><li>删除左右括号</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeInvalidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//找出不合格的左右括号数</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span> , right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s)&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">0</span>) left--;<br>                <span class="hljs-keyword">else</span> right++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>,left,right);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string s)</span></span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>               count--;<br>               <span class="hljs-keyword">if</span>(count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i != index &amp;&amp; s[i] == s[i<span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//删左括号</span><br>            <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                <span class="hljs-built_in">dfs</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i) + s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, s.<span class="hljs-built_in">length</span>() - i - <span class="hljs-number">1</span>), i, left - <span class="hljs-number">1</span>, right);<br>            &#125;<br>            <span class="hljs-comment">//删右括号</span><br>            <span class="hljs-keyword">if</span>(right &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-built_in">dfs</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i) + s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, s.<span class="hljs-built_in">length</span>() - i - <span class="hljs-number">1</span>), i, left, right - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.16</title>
    <link href="/2022/11/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-16/"/>
    <url>/2022/11/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-16/</url>
    
    <content type="html"><![CDATA[<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.<a href="https://leetcode.cn/problems/next-permutation/">下一个排列</a></h1><p>从后向前找到第一个小于后一个元素的值，记为i</p><p>再从后向前找到第一个大于nums[i]的值的索引，记为j</p><p>交换nums[i]和nums[j]，再将i+1到结尾的序列反转</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>])&#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[j]);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>,nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.<a href="https://leetcode.cn/problems/sort-colors/description/">颜色分类</a></h1><p>双指针，zero保存0，two保存2，中间碰到1只让i加1就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> zero = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> two = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(i &lt; two)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[zero]);<br>                zero++;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                two--;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[two]);<br>            &#125;<br>        &#125;   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a>287.<a href="https://leetcode.cn/problems/find-the-duplicate-number/description/">寻找重复数</a></h1><p>利用快慢指针，仿照环形链表II，把两个重复数和之间的看成一个环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node = nums[node];<br></code></pre></td></tr></table></figure><p>让fast每次移动两个，slow每次移动一个，找到有环之后，再让finder从0开始，slow从当前位置开始，当finder和slow相遇就是重复数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            fast = nums[nums[fast]];<br>            slow = nums[slow];<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> finder = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            finder = nums[finder];<br>            slow = nums[slow];<br>            <span class="hljs-keyword">if</span>(finder == slow)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.17</title>
    <link href="/2022/11/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-17/"/>
    <url>/2022/11/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-17/</url>
    
    <content type="html"><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.<a href="https://leetcode.cn/problems/generate-parentheses/description/">括号生成</a></h1><p>输入n，生成2n个长度的，n个左括号，n个右括号；用left和right记录还要加入多少个左括号或者右括号，每次递归加入左右括号时让left或right减1</p><p>终止条件：当left和right的值都为0时将子串加入到result中</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        string str;<br>        <span class="hljs-built_in">backtracking</span>(n,n,str);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,string &amp;str)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(right &lt; left) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br><br>        str.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        <span class="hljs-built_in">backtracking</span>(left<span class="hljs-number">-1</span>,right,str);<br>        str.<span class="hljs-built_in">pop_back</span>();<br><br>        str.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-built_in">backtracking</span>(left,right<span class="hljs-number">-1</span>,str);<br>        str.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.<a href="https://leetcode.cn/problems/combination-sum/description/">组合总和</a></h1><p>参数：目前的和sum，目标的和targetSum，目前遍历到的位置index，candidates</p><p>终止条件：当目前的和sum等于目标的和targetSum时终止</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates,<span class="hljs-type">int</span> targetSum,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; targetSum) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(sum == targetSum)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index ;i &lt; candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates,targetSum,sum,i);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            sum -= candidates[i];<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.<a href="https://leetcode.cn/problems/permutations/description/">全排列</a></h1><p>参数：数据是否被用过used，nums</p><p>终止条件：path的长度和nums的长度相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(used,nums);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used,vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>           result.<span class="hljs-built_in">push_back</span>(path);<br>       &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(used,nums);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.15</title>
    <link href="/2022/11/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-15/"/>
    <url>/2022/11/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-15/</url>
    
    <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><p>两次遍历，将不等于0的元素依次向前，记下0元素的位置index，把后面的元素全变为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> ;<br>       &#125;<br>       <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>           <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)&#123;<br>               nums[index++] = nums[i];<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index ;i &lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>           nums[i] = <span class="hljs-number">0</span>;<br>       &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一次遍历：利用快排的思想，选取中间元素0，将不等于0的元素和等于0的元素交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> temp = nums[i];<br>                nums[i] = <span class="hljs-number">0</span>;<br>                nums[index++] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.<a href="https://leetcode.cn/problems/3sum/description/">三数之和</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>() ;i++)&#123;<br>            <span class="hljs-comment">//对a去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i],nums[left],nums[right]&#125;);<br>                    <span class="hljs-comment">//对b、c去重</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right<span class="hljs-number">-1</span>]) right--;<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) left++;<br>                    left++;<br>                    right --;<br>                &#125;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.<a href="https://leetcode.cn/problems/container-with-most-water/description/">盛最多水的容器</a></h1><p>每次移动比较矮的板子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br><br>       <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> j = height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>       <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>           res = height[i] &lt; height[j]?<br>           <span class="hljs-built_in">max</span>(res,(j-i)*height[i++]):<br>           <span class="hljs-built_in">max</span>(res,(j-i)*height[j--]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.14</title>
    <link href="/2022/11/14/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-14/"/>
    <url>/2022/11/14/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-14/</url>
    
    <content type="html"><![CDATA[<h1 id="239-滑动窗口的最大值"><a href="#239-滑动窗口的最大值" class="headerlink" title="239.滑动窗口的最大值"></a>239.<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">滑动窗口的最大值</a></h1><p>要找的是最大值，如果用大根堆维护最大值，就找不到每一个数据所在的位置，删除时候也不好删除</p><p>自定义一个单调队列，实现push,pop,front，没有必要维护全部元素只要维护窗口里的最大值就行</p><p>窗口移动的时候，先pop掉前一个元素，然后push加入当前的元素，然后再把front加入到result中</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        deque&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//窗口的最大值一直放在队列头</span><br>            <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>(); <br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;<span class="hljs-comment">//把窗口里小于当前值从后到前抛出，然后加入</span><br>            <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>() &amp;&amp; que.<span class="hljs-built_in">back</span>()&lt;value)&#123;<br>                que.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            que.<span class="hljs-built_in">push_back</span>(value);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;<span class="hljs-comment">//pop(nums[i-k])，只有到合适时候再将它删除</span><br>            <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">front</span>() == value)&#123;<br>                 que.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        MyQueue myQueue;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            myQueue.<span class="hljs-built_in">push</span>(nums[i]);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        result.<span class="hljs-built_in">push_back</span>(myQueue.<span class="hljs-built_in">front</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k ;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            myQueue.<span class="hljs-built_in">pop</span>(nums[i-k]);<br>            myQueue.<span class="hljs-built_in">push</span>(nums[i]);<br>            result.<span class="hljs-built_in">push_back</span>(myQueue.<span class="hljs-built_in">front</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h1><p>用一个大小为k的大顶堆，先用一个map对nums的所有数字计数，然后再遍历map，挑出其中的最大的k个数据入堆。最后将堆中的元素输出即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">myCompirsion</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;lhs,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;rhs)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,myCompirsion&gt; queue;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            mp[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>();it++)&#123;<br>            queue.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span>(queue.<span class="hljs-built_in">size</span>() &gt; k) queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            result[i] = queue.<span class="hljs-built_in">top</span>().first;<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?languageTags=cpp">数组中的第k个最大元素</a></h1><p>改进后的快排</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-type">int</span> leftIndex = left;<br>        <span class="hljs-type">int</span> rightIndex = right;<br>        <span class="hljs-type">int</span> n =<span class="hljs-built_in">rand</span>()%(right - left +<span class="hljs-number">1</span>)+left;<br>        <span class="hljs-built_in">swap</span>(nums[left],nums[n]);<br>        <span class="hljs-keyword">while</span>(leftIndex&lt;rightIndex)&#123;<br>            <span class="hljs-keyword">while</span>(leftIndex &lt; rightIndex &amp;&amp; nums[rightIndex]&lt;= nums[left]) --rightIndex;<br>            <span class="hljs-keyword">while</span>(leftIndex &lt; rightIndex &amp;&amp; nums[leftIndex]&gt;=nums[left]) ++leftIndex;<br>            <span class="hljs-built_in">swap</span>(nums[leftIndex],nums[rightIndex]);<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[leftIndex],nums[left]);<br>        <span class="hljs-keyword">if</span>(leftIndex &lt; k<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(nums,leftIndex+<span class="hljs-number">1</span>,right,k);<br>        <span class="hljs-keyword">if</span>(leftIndex &gt; k<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(nums,left,leftIndex<span class="hljs-number">-1</span>,k);<br>        <span class="hljs-keyword">return</span> nums[leftIndex];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.12</title>
    <link href="/2022/11/13/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-12/"/>
    <url>/2022/11/13/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-12/</url>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a></h1><p>递归法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(rightDepth,leftDepth)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>迭代法：和层序遍历差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            depth++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>                TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="437-路径总和III"><a href="#437-路径总和III" class="headerlink" title="437.路径总和III"></a>437.<a href="https://leetcode.cn/problems/path-sum-iii/description/">路径总和III</a></h1><p>先调用dfs开始查找路径。由于题目上说不一定从根节点开始，所以调用完根节点的dfs后再调用root-&gt;left的根节点和root-&gt;right的根节点。</p><p>dfs函数的设计就是每次让targetSum减去root-&gt;val，判断targetSum是否等于0来决定这个节点是否合格，然后修改全局变量count统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root,targetSum);<br>        <span class="hljs-built_in">pathSum</span>(root-&gt;left,targetSum);<br>        <span class="hljs-built_in">pathSum</span>(root-&gt;right,targetSum);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">long</span> <span class="hljs-type">long</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        sum -= root-&gt;val;<br>        <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>) count++;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,sum);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,sum); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124.二叉树中的最大路径和"></a>124.<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">二叉树中的最大路径和</a></h1><p>调用自身求出一个节点为根节点的左侧最长路径left和右侧最长路径right，那么经过该节点的最长路径就是left+right，接着从根节点开始dfs，不断更新全局变量res</p><p>left和right分别为根节点左子树和右子树的最大路径和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = INT_MIN;<span class="hljs-comment">//题目里有负数，要设置成最小值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;left),<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;right),<span class="hljs-number">0</span>);<br><br>        res = <span class="hljs-built_in">max</span>(res,left+right+root-&gt;val);<span class="hljs-comment">//比较当前最大路径和左右子树最长路径加上根节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left+root-&gt;val,right+root-&gt;val);<span class="hljs-comment">//返回左右子树的较长的路径加上根节点的值</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.13</title>
    <link href="/2022/11/13/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-13/"/>
    <url>/2022/11/13/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-13/</url>
    
    <content type="html"><![CDATA[<h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.<a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a></h1><p>某条路径可以看作左子树向下遍历经过的最多的节点数left+右子树向下遍历经过的最多的节点数right+1(节点自身)，这样设置一个全局变量res，递归搜索每一个节点就更新它的最大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res<span class="hljs-number">-1</span>;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left);<span class="hljs-comment">//左子树的最大深度</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<span class="hljs-comment">//右子树的最大深度</span><br>        res = <span class="hljs-built_in">max</span>(res,right+left+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回子树的最大深度</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="94-验证二叉搜索树"><a href="#94-验证二叉搜索树" class="headerlink" title="94.验证二叉搜索树"></a>94.<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">验证二叉搜索树</a></h1><p>二叉搜索树中序遍历是递增的，所以设置一个前驱节点prev，递归遍历如果prev的值大于等于现在节点的值就返回false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* prev = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//中序遍历为递增序列</span><br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">if</span>(prev!=<span class="hljs-literal">nullptr</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        prev = root;<br><br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br>        <br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="538-把二叉搜索树转换成累加树"><a href="#538-把二叉搜索树转换成累加树" class="headerlink" title="538.把二叉搜索树转换成累加树"></a>538.<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">把二叉搜索树转换成累加树</a></h1><p>用”中序遍历”：只不过是按右中左的顺序遍历，就能从最大值遍历到最小值，每一个节点都加上它的上一个遍历的节点的值，最终得到就是累加树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        root-&gt;val += prev;<br>        prev = root-&gt;val;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.11</title>
    <link href="/2022/11/11/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-11/"/>
    <url>/2022/11/11/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-11/</url>
    
    <content type="html"><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">二叉树的最近公共祖先</a></h1><p>从底层往上层遍历，要使用后序遍历，同时要搜索的是整棵二叉树，要用left和right接住每次递归产生的结果，然后再进行进一步的操作</p><p>终止条件是root为q或者p或者为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(left !=<span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.<a href="https://leetcode.cn/problems/invert-binary-tree/description/">翻转二叉树</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>                TreeNode* curr = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(curr-&gt;left,curr-&gt;right);<br>                <span class="hljs-keyword">if</span>(curr-&gt;left) q.<span class="hljs-built_in">push</span>(curr-&gt;left);<br>                <span class="hljs-keyword">if</span>(curr-&gt;right) q.<span class="hljs-built_in">push</span>(curr-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="297-二叉树的序列化和反序列化"><a href="#297-二叉树的序列化和反序列化" class="headerlink" title="297.二叉树的序列化和反序列化"></a>297.<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/?languageTags=cpp">二叉树的序列化和反序列化</a></h1><p>层序遍历，空节点用#代替</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string str;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node)<br>                str += (<span class="hljs-built_in">to_string</span>(node-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//空节点设置#</span><br>                str += <span class="hljs-string">&quot;#,&quot;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        str.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string&amp; str)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-type">int</span> size = str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i == size || str[i] == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(str.<span class="hljs-built_in">substr</span>(pre, i-pre));<br>                pre = i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(vector&lt;string&gt;&amp; data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>())   <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//第一个元素为根节点</span><br>        string root_val = data[<span class="hljs-number">0</span>];<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(root_val));<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><span class="hljs-comment">//从第二个元素开始遍历</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ) &#123;<br>            TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>           <br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//左节点</span><br>            string left_val = data[i++];<br>            <span class="hljs-keyword">if</span> (left_val == <span class="hljs-string">&quot;#&quot;</span>)<br>                node-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">else</span><br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(left_val));<br>            q.<span class="hljs-built_in">push</span>(node-&gt;left);<br><br>           <span class="hljs-comment">//右节点</span><br>            string right_val = data[i++];<br>            <span class="hljs-keyword">if</span> (right_val == <span class="hljs-string">&quot;#&quot;</span>)<br>                node-&gt;right = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">else</span><br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(right_val));<br>            q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        vector&lt;string&gt; str = <span class="hljs-built_in">split</span>(data);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(str);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.10</title>
    <link href="/2022/11/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-10/"/>
    <url>/2022/11/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-10/</url>
    
    <content type="html"><![CDATA[<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.<a href="https://leetcode.cn/problems/symmetric-tree/description/">对称二叉树</a></h1><p>递归的终止条件是两个节点都为空，如果有一方不为空另一方位空    或者两方的值不相等就返回false</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root-&gt;left,root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* left,TreeNode* right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left ==<span class="hljs-literal">nullptr</span> &amp;&amp; right ==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right !=<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(left-&gt;left,right-&gt;right) &amp;&amp; <span class="hljs-built_in">helper</span>(left-&gt;right,right-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="105-从前序与中序遍历构造二叉树"><a href="#105-从前序与中序遍历构造二叉树" class="headerlink" title="105.从前序与中序遍历构造二叉树"></a>105.<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">从前序与中序遍历构造二叉树</a></h1><p>和人脑想前序与中序遍历构造二叉树一样，从前序的第一个位置找到根节点，然后在中序遍历找到根节点，中序遍历一分为二，leftInorder和rightInorder。利用leftInorder的长度在前序遍历中让preorder一分为二为leftPreorder和rightPreorder，然后递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(preorder,inorder);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> rootVal = root-&gt;val;<br>        <span class="hljs-keyword">if</span>(inorder.<span class="hljs-built_in">size</span>() ==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">int</span> index;<br>        <span class="hljs-keyword">for</span>(index = <span class="hljs-number">0</span>;index &lt;inorder.<span class="hljs-built_in">size</span>();index++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[index] == rootVal) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(),inorder.begin()+index)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin()+index+<span class="hljs-number">1</span>,inorder.end())</span></span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPreorder</span><span class="hljs-params">(<span class="hljs-number">1</span>+preorder.begin(),<span class="hljs-number">1</span>+preorder.begin()+leftInorder.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPreorder</span><span class="hljs-params">(<span class="hljs-number">1</span>+preorder.begin()+leftInorder.size(),preorder.end())</span></span>;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftPreorder,leftInorder);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightPreorder,rightInorder);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.<a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">不同的二叉搜索树</a></h1><p>n=1：共1棵二叉树    dp[1]=1</p><p>n=2：共2棵二叉树    dp[2]=2</p><p>n=3：以1为根节点的二叉树+以2为根节点的二叉树+以3为根节点的人二叉树</p><p>以1为根节点的二叉树：右子树有2个元素<em>左子树有0个元素dp[2]\</em>dp[0]</p><p>以2为根节点的二叉树：右子树有1个元素<em>左子树有1个元素dp[1]\</em>dp[1]</p><p>以3为根节点的二叉树：右子树有0个元素<em>左子树有2个元素dp[0]\</em>dp[2]</p><p>所以递推公式：</p><p>dp[i] += dp[j-1]+dp[i-j];</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= i;j++)&#123;<br>                dp[i] += dp[j<span class="hljs-number">-1</span>]*dp[i-j]; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.09</title>
    <link href="/2022/11/09/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-09/"/>
    <url>/2022/11/09/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-09/</url>
    
    <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树的中序遍历</a></h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        res.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span>(node-&gt;left) <span class="hljs-built_in">traversal</span>(node-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">if</span>(node-&gt;right) <span class="hljs-built_in">traversal</span>(node-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res; <br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span>)&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                st.<span class="hljs-built_in">push</span>(node);<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><p>注意控制每层的元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-type">int</span> length = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; length;i++)&#123;<br>                TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="76-最小覆盖字串"><a href="#76-最小覆盖字串" class="headerlink" title="76.最小覆盖字串"></a>76.<a href="https://leetcode.cn/problems/minimum-window-substring/description/">最小覆盖字串</a></h1><p>滑动窗口，用一个need和window，need表示字符串t的字母——数量键值对，window表示目前的窗口内的字母——数量的键值对。</p><p>窗口维护一个左闭右开的区间[left,right)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; need,window;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:t)&#123;<br>            need[c]++;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<span class="hljs-comment">//左闭右开区间</span><br>        <span class="hljs-type">int</span> vaild = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, len = INT_MAX;<br>        <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">//移入窗口的字符</span><br>            <span class="hljs-type">char</span> c = s[right];<br>            right++;<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c))&#123;<br>                window[c]++;<br>                <span class="hljs-keyword">if</span>(need[c] == window[c]) vaild++;<br>            &#125;<br>            <span class="hljs-comment">//判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span>(vaild == need.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">if</span>(right - left &lt; len)&#123;<br>                    start = left;<br>                    len = right - left;<br>                &#125;<br>                <span class="hljs-comment">//即将要移除的字符</span><br>                <span class="hljs-type">char</span> d = s[left];<br>                <span class="hljs-comment">//缩小窗口</span><br>                left++;<br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>                    <span class="hljs-keyword">if</span>(need[d] == window[d]) vaild--;<br>                    window[d]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == INT_MAX?<span class="hljs-string">&quot;&quot;</span>:s.<span class="hljs-built_in">substr</span>(start,len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.08</title>
    <link href="/2022/11/08/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-08/"/>
    <url>/2022/11/08/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-08/</url>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长字串</a></h1><p>用一个滑动窗口和哈希表，从0处开始，用right如果碰到没有被加入的就加入，如果碰到已经加入的，就计算i到right之间的距离，与以前计算出来的比较，取较大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">-1</span>;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; set;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; len ; i++)&#123;<br>            <span class="hljs-comment">//去除i之前的一位</span><br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>)&#123;<br>                set.<span class="hljs-built_in">erase</span>(s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//只要没碰到，就往set里加</span><br>            <span class="hljs-keyword">while</span>(right+<span class="hljs-number">1</span> &lt;len &amp;&amp; !set.<span class="hljs-built_in">count</span>(s[right+<span class="hljs-number">1</span>]))&#123;<br>                ++right;<br>                set.<span class="hljs-built_in">insert</span>(s[right]);<br>            &#125;<br>            <span class="hljs-comment">//得到的长度与之前的比较，取较大值</span><br>            res = <span class="hljs-built_in">max</span>(res,right-i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h1><p>将nums的所有元素都保存到set里，然后遍历set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            set.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item:set)&#123;<br>           <span class="hljs-comment">//如果没有该数的上一位</span><br>           <span class="hljs-keyword">if</span>(!set.<span class="hljs-built_in">count</span>(item<span class="hljs-number">-1</span>))&#123;<br>               <span class="hljs-type">int</span> currentNum = item;<br>               <span class="hljs-type">int</span> currentLen = <span class="hljs-number">1</span>;<br>               <span class="hljs-comment">//继续看有没有下一位</span><br>               <span class="hljs-keyword">while</span>(set.<span class="hljs-built_in">count</span>(currentNum+<span class="hljs-number">1</span>))&#123;<br>                   currentLen++;<br>                   currentNum++;<br>               &#125;<br>               res = <span class="hljs-built_in">max</span>(res,currentLen);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h1><p>用滑动窗口，在字符串s中构造一个长度与p相同的滑动窗口，维护窗口中每种字母的数量；当窗口中的字母的数量种类和p中的字母的数量种类相同时，说明是异位词</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> sLen = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> pLen = p.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(pLen &gt; sLen )<span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sSet</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pSet</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-comment">//找到p字符串中的字母的数量种类</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; pLen;i++)&#123;<br>            pSet[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sSet[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sSet == pSet) res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//此时开始查找0+1位的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; sLen-pLen;i++)&#123;<br>            sSet[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            sSet[s[i+pLen]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span>(sSet == pSet)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.07</title>
    <link href="/2022/11/07/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-07/"/>
    <url>/2022/11/07/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-07/</url>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">电话号码的字母组合</a></h1><p>回溯三部曲：</p><ol><li><p>确定回溯的参数：</p><p>用一个索引index表示现在到dights的哪一个</p><p>result保存最后的结果</p><p>string类型的s用于保存某个数字对应的字母，比如2对应“abc”，那么s保存这个字符串的子串</p></li><li><p>终止条件：</p><p>当index等于dights的长度时，递归终止</p></li><li><p>单层处理逻辑：</p><p>将index对应的字符串letters取出来，然后用for循环处理这个字符串</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br>    string s;<br>    string mp[<span class="hljs-number">10</span>]=&#123;<br>        <span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-string">&quot;mno&quot;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>,<span class="hljs-string">&quot;tuv&quot;</span>,<span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        s.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-built_in">traversal</span>(digits,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; digits,<span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(index == digits.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[index]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        string letters = mp[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;letters.<span class="hljs-built_in">size</span>();i++)&#123;<br>            s.<span class="hljs-built_in">push_back</span>(letters[i]);<br>            <span class="hljs-built_in">traversal</span>(digits,index+<span class="hljs-number">1</span>);<br>            s.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.<a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h1><p>同一组字母异位词有相同数量的字母，用key-value的形式保存它们的关键字和对应的字母</p><p>将每个字母异位词排序，如果是一组它们就有相同的key，用map保存</p><p>最后再取出这些vector<string\> </string\></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string,vector&lt;string&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;str : strs)&#123;<br>            string key = str;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(),key.<span class="hljs-built_in">end</span>());<br>            mp[key].<span class="hljs-built_in">emplace_back</span>(str);<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>();it != mp.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            result.<span class="hljs-built_in">emplace_back</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">找到所有数组中消失的数字</a></h1><p>用set保存存在的数字，再去检查[1,n]里是否有这个数字，没有就加进答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            set.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;   <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(!set.<span class="hljs-built_in">count</span>(i))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.06</title>
    <link href="/2022/11/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-06/"/>
    <url>/2022/11/06/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-06/</url>
    
    <content type="html"><![CDATA[<p>单调栈模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; st;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span>(特殊情况)<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[st.<span class="hljs-built_in">top</span>()] xx nums[i])&#123;<br>        操作<br>    &#125;<br>    st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.<a href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a></h1><p>单调栈栈头到栈底应该是从小到大，当遍历heights时，如果发现heights[i]大于栈顶的元素，说明就发现了凹槽。这个时候，凹槽的底部就是栈顶的元素；heights[i]就是右边界；栈顶的第二个元素就是左边界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//将第一个元素放进</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//从第二个开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; height.<span class="hljs-built_in">size</span>() ; i++)&#123;<br>            <span class="hljs-comment">//碰到比栈顶元素还小的，就入栈</span><br>            <span class="hljs-keyword">if</span>(height[i] &lt; height[st.<span class="hljs-built_in">top</span>()])&#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-comment">//碰到和栈顶元素一样的，将旧的抛出，新的入栈</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(height[i] == height[st.<span class="hljs-built_in">top</span>()])&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-comment">//发现有凹槽</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[st.<span class="hljs-built_in">top</span>()] &lt; height[i])&#123;<br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//栈顶元素就是凹槽底部</span><br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>                        <span class="hljs-comment">//高度选左右边界的较小值减去凹槽底部</span><br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()],height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> r = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                        sum += h*r;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?languageTags=cpp&amp;topicTags=monotonic-stack">柱状图中最大的矩形</a></h1><p>在heights的前后加上0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);<br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; heights.<span class="hljs-built_in">size</span>() ; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[st.<span class="hljs-built_in">top</span>()] &gt; heights[i])&#123;<br>                <span class="hljs-type">int</span> temp = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>()+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right = i<span class="hljs-number">-1</span>;<br>                res = <span class="hljs-built_in">max</span>(res,(right-left+<span class="hljs-number">1</span>)*heights[temp]);<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.<a href="https://leetcode.cn/problems/daily-temperatures/description/?languageTags=cpp&amp;topicTags=monotonic-stack">每日温度</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span> <span class="hljs-params">(temperatures.size(),<span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; temperatures.<span class="hljs-built_in">size</span>() ; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[st.<span class="hljs-built_in">top</span>()] &lt; temperatures[i])&#123;<br>                <span class="hljs-type">int</span> temp = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                answer[temp] = i - temp;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.05</title>
    <link href="/2022/11/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-05/"/>
    <url>/2022/11/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-05/</url>
    
    <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.<a href="https://leetcode.cn/problems/valid-parentheses/description/?languageTags=cpp">有效的括号</a></h1><p>不匹配的情况：</p><ul><li>括号多余，能匹配的字符串一定是偶数个，如果是奇数个字符，一定不匹配</li><li>对应的括号不匹配（如‘ ( ’和’ } ‘)）</li><li>长度虽然是偶数，但是有两个左括号或者右括号</li></ul><p>匹配左括号时，将右括号入栈，这样在遍历过程中只要判断栈顶的元素是否等于右括号；如果左括号入栈，还要分三种情况判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. <a href="https://leetcode.cn/problems/min-stack/description/">最小栈</a></h1><p>使用链栈，并且内含成员变量minNum，每次push和pop时维护这个minNum，其它和链栈的操作一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>    <span class="hljs-built_in">Node</span>():<span class="hljs-built_in">val</span>(INT_MIN),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> value):<span class="hljs-built_in">val</span>(value),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> minNum;<span class="hljs-comment">//记录最小的元素</span><br>    Node* HS;<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        HS = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        minNum = INT_MAX;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//如果val小于minNum，更新</span><br>        <span class="hljs-keyword">if</span>(minNum &gt; val) minNum = val;<br>        Node* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val);<br>        node-&gt;next = HS-&gt;next;<br>        HS-&gt;next = node;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        HS-&gt;next = HS-&gt;next-&gt;next;<br>        minNum=INT_MAX;<br>        Node* temp = HS-&gt;next;<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(minNum &gt; temp-&gt;val)&#123;<br>                minNum = temp-&gt;val;<br>            &#125;<br>            temp = temp-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> HS-&gt;next-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.<a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></h1><p>所有有效的括号串之间都是不相交的，如果遍历过程中发现某个i不匹配，下个有效括号串就从i+1开始找</p><p>用栈去判断括号的有效性，对于每一个右括号，都去求右括号为端点的最长合法括号的左端点，再去维护一个res，表示最长的有小括号的长度，每次找到左端点和右端点后更新这个值，这个值就是最后的答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<span class="hljs-comment">//栈用来保存下标，当前待匹配的左括号的位置</span><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录新的可能有效的括号的起始位置</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) st.<span class="hljs-built_in">push</span>(i);<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//s[i]是反括号</span><br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//匹配成功</span><br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-comment">//此时栈如果为空，start就是此次的左端点</span><br>                    <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) res = <span class="hljs-built_in">max</span>(res,i-start+<span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">//此时栈如果不为空，栈顶元素的下一个元素就是左端点（此时和）匹配的（被弹出了）</span><br>                    <span class="hljs-keyword">else</span> res = <span class="hljs-built_in">max</span>(res,i-st.<span class="hljs-built_in">top</span>()+<span class="hljs-number">1</span><span class="hljs-number">-1</span>);<br>                &#125;<br>                <span class="hljs-comment">//遇到右括号且栈为空，说明不可能构成有效括号</span><br>                <span class="hljs-keyword">else</span> start = i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.04</title>
    <link href="/2022/11/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-04/"/>
    <url>/2022/11/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-04/</url>
    
    <content type="html"><![CDATA[<h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?languageTags=cpp">二叉树展开为链表</a></h1><p>先序遍历：中-&gt;左-&gt;右，对于每个节点，遍历顺序为自己-&gt;左边的-&gt;右边的</p><p>从root开始遍历每一个节点，如果该节点有左子树，让每个节点的右子树都挂到左子树的右子树上，再将左子树变成右子树</p><p>例：初始：<img src="/2022/11/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-04/image-20221104193215240.png" class title="image-20221104193215240"></p><p>到节点1时：</p><img src="/2022/11/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-04/image-20221104193944134.png" class title="image-20221104193944134"><p>到节点2时就将4开头的右子树挂到左子树3下，将右子树改成左子树</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-comment">//当有左子树时</span><br>                TreeNode* target_parent = root-&gt;left;<span class="hljs-comment">//记下当前的左子树</span><br>                <span class="hljs-keyword">while</span>(target_parent-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-comment">//找到左子树的最右的节点</span><br>                    target_parent = target_parent-&gt;right;<br>                &#125;<br>                target_parent-&gt;right = root-&gt;right;<span class="hljs-comment">//将当前的root节点的右子树接到左子树下</span><br>                root-&gt;right = root-&gt;left;<span class="hljs-comment">//将root的右子树改成左子树</span><br>                root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            root = root-&gt;right;<span class="hljs-comment">//继续操作下一个右子树</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23.合并K个升序链表"></a>23.<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a></h1><p>这道题刚开始想是写个合并两个有序链表的函数，然后遍历lists，两两合并，发现超时了</p><p>这道题与合并两个升序链表的区别是，那道题是维护两个值的最小值，我们只需要比较两个数就能得出来，而这道题是维护k个数的最小值，所以要用到优先级队列</p><p>STL提供priority_queue容器，由于是自定义的类ListNode，需要重写它的比较的函数；如果是基本数据类型，使用less就是大顶堆，greater就是小顶堆。对于自定义的数据类型，重载&gt;用小顶堆，重载&lt;用大顶堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Status</span>&#123;<br><span class="hljs-type">int</span> val;<br>ListNode* ptr;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-type">const</span> Status &amp;rhs) <span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> val &gt; rhs.val;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以重载()，这样每次pop和push的时候都会对堆里的元素重新排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* a,ListNode* b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        priority_queue&lt;ListNode* , vector&lt;ListNode*&gt; , cmp&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; lists.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(lists[i]);<br>        &#125;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* temp = dummyHead;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            ListNode* node = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            temp-&gt;next = node;<br>            temp = temp-&gt;next;<br>            <span class="hljs-keyword">if</span>(node-&gt;next != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(node-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146.LRU缓存"></a>146.<a href="https://leetcode.cn/problems/lru-cache/description/?languageTags=cpp">LRU缓存</a></h1><p>使用哈希表+双端队列</p><p>逐出最久未使用的关键字，使用一个双端队列，将最新的节点（每次get和put都要更新）放到队头，这样不常使用的就放到队尾。哈希表负责get和put，也就是看元素在不在缓存里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *prev;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> v):<span class="hljs-built_in">key</span>(k),<span class="hljs-built_in">val</span>(v),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span>&#123;<br>    Node* begin;<br>    Node* end;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//begin和end都不指的具体的节点，都是虚拟节点，这样就不用考虑特殊情况</span><br>    <span class="hljs-built_in">DoubleLinkedList</span>()&#123;<br>        begin = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>);<br>        end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>);<br>        begin-&gt;next = end;<br>        end-&gt;prev = begin;<br>    &#125;<br>    <span class="hljs-comment">//讲节点放到前端</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(Node* node)</span></span>&#123;<br>        node-&gt;next = begin-&gt;next;<br>        node-&gt;prev = begin;<br>        node-&gt;next-&gt;prev = node;<br>        begin-&gt;next = node;<br>    &#125;<br>    <span class="hljs-comment">//删除节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span> <span class="hljs-params">(Node* node)</span></span>&#123;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">//删除队尾的节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">erase</span>(end-&gt;prev);<br>    &#125;<br>    <span class="hljs-comment">//返回队尾的节点</span><br>    <span class="hljs-function">Node* <span class="hljs-title">back</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> end-&gt;prev;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,Node*&gt; mp;<br>    DoubleLinkedList* node_list;<br>    <span class="hljs-type">int</span> capacity; <br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>        node_list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DoubleLinkedList</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(key) == mp.<span class="hljs-built_in">end</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        Node* node = mp[key];<br>        node_list-&gt;<span class="hljs-built_in">erase</span>(node);<br>        node_list-&gt;<span class="hljs-built_in">push_front</span>(node);<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">//如果已经存在这个key</span><br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(key) != mp.<span class="hljs-built_in">end</span>())&#123;<br>            Node* node = mp[key];<br>            node-&gt;val = value;<br>            node_list-&gt;<span class="hljs-built_in">erase</span>(node);<br>            node_list-&gt;<span class="hljs-built_in">push_front</span>(node);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">size</span>() == capacity)&#123;<br>                mp.<span class="hljs-built_in">erase</span>(node_list-&gt;<span class="hljs-built_in">back</span>()-&gt;key);<br>                node_list-&gt;<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key,value);<br>            mp[key]=node;<br>            node_list-&gt;<span class="hljs-built_in">push_front</span>(node);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022.11.03</title>
    <link href="/2022/11/03/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-03/"/>
    <url>/2022/11/03/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-03/</url>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.<a href="https://leetcode.cn/problems/linked-list-cycle/description/">环形链表</a></h1><p>快慢指针，每次让快指针走两步，慢指针走一步</p><p>如果存在环，则两个指针一定会碰头</p><p>初始化时候，fast和slow都可以指向head，这个根据判断fast和slow相等的位置而定，如果while循环里第一步就先判断了这俩是否相等，那初始化就不能让它们指向同一个节点了</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       ListNode* fast = head;<br>       ListNode* slow = head;<br>       <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>)&#123;<br>           <span class="hljs-keyword">if</span>(fast-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           fast = fast-&gt;next-&gt;next;<br>           slow = slow-&gt;next;<br>           <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II</a></h1><p>本题不仅要判断是否有环，而且还要解出哪个节点是环的入口</p><p>在上一题的基础上，当fast和slow指向同一个节点时：</p><img src="/2022/11/03/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2022-11-03/image-20221103174320239.png" class title="image-20221103174320239"><p>设头节点到进入环的节点距离为x，环的开始的节点到fast和slow相遇的节点距离为y，剩下的环的长度为z</p><p>假设slow在走第一圈时就相遇</p><p>fast走过：x+y+n*(z+y)</p><p>slow走过：x+y</p><p>fast每次比slow多走一步，所以有<script type="math/tex">2*(x+y)=x+y+n*(z+y)</script></p><p>化简得：$x=n*(z+y)-y=(n-1)(y+z)+z$</p><p>当n为1时（特值法吧），x=z,所以求出z就求出了环的起始节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>       ListNode* fast = head;<br>       ListNode* slow = head;<br>       <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>           fast = fast-&gt;next-&gt;next;<br>           slow = slow-&gt;next;<br>           <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>               ListNode* index1=fast;<br>               ListNode* index2=head;<br>               <span class="hljs-keyword">while</span>(index1 != index2)&#123;<br>                   index1 = index1-&gt;next;<br>                   index2 = index2-&gt;next;<br>               &#125;<br>               <span class="hljs-keyword">return</span> index2;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.<a href="https://leetcode.cn/problems/sort-list">排序链表</a></h1><p>链表比较适合分割，不适合大量的去交换节点，用归并排序比较好，该题可以分解成找到链表的中间节点+对两个有序链表排序</p><p>找链表的中间节点可以用双指针，让fast走slow的两倍，这样当fast到末尾时slow就指向中间节点</p><p>找到中间节点时候记得把slow-&gt;next=null切断这条链表，这样才变成两条链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* head1=head;<br>        ListNode* head2=<span class="hljs-built_in">find_mid</span>(head);<br><br>        head1 = <span class="hljs-built_in">sortList</span>(head1);<br>        head2 = <span class="hljs-built_in">sortList</span>(head2);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(head1,head2);<br>    &#125;<br><span class="hljs-comment">//找到链表的中间节点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">find_mid</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* fast = head-&gt;next;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next !=<span class="hljs-literal">nullptr</span>)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        ListNode* mid = slow-&gt;next;<br>        slow-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-comment">//合并两条有序链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* head1,ListNode* head2)</span></span>&#123;<br>        ListNode* dummyHead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* temp=dummyHead;<br>        <span class="hljs-keyword">while</span>(head1 != <span class="hljs-literal">nullptr</span> &amp;&amp; head2 !=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head1-&gt;val &gt;= head2-&gt;val)&#123;<br>                temp-&gt;next = head2;<br>                head2 = head2-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp-&gt;next = head1;<br>                head1 = head1-&gt;next;<br>            &#125;<br>            temp = temp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head1 != <span class="hljs-literal">nullptr</span>)&#123;<br>            temp-&gt;next = head1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head2 != <span class="hljs-literal">nullptr</span>)&#123;<br>            temp-&gt;next = head2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>输入输出接口</title>
    <link href="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="I-O接口的发展"><a href="#I-O接口的发展" class="headerlink" title="I/O接口的发展"></a>I/O接口的发展</h1><h2 id="程序查询I-O方式"><a href="#程序查询I-O方式" class="headerlink" title="程序查询I/O方式"></a>程序查询I/O方式</h2><p>精髓：CPU主动去查询外设</p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025085638996.png" class title="image-20221025085638996"><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断源：凡是向CPU提出中断请求的各种因素，统称为中断源</p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025085808476.png" class title="image-20221025085808476"><h2 id="直接内存存取"><a href="#直接内存存取" class="headerlink" title="直接内存存取"></a>直接内存存取</h2><p>特点：</p><ul><li>IO与主存之间有一条直接的数据通路，二者可直接进行信息交换</li><li>CPU在IO与内存交换数据的过程中，可继续工作，效率提高</li></ul><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025085928600.png" class title="image-20221025085928600"><h2 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h2><p>通道是一个特殊的处理器，有自己的通道指令，但受CPU控制</p><p>通道可以<strong>代替CPU来控制IO设备以及控制IO与主机进行数据交换</strong></p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025090039451.png" class title="image-20221025090039451"><h2 id="外围处理机"><a href="#外围处理机" class="headerlink" title="外围处理机"></a>外围处理机</h2><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025090102553.png" class title="image-20221025090102553"><h1 id="I-O接口的组成与工作原理"><a href="#I-O接口的组成与工作原理" class="headerlink" title="I/O接口的组成与工作原理"></a>I/O接口的组成与工作原理</h1><p>接口时两个系统或两个部件之间的衔接部分</p><ul><li>软件接口</li><li>硬件接口</li></ul><p>I/O接口是<strong>连接主机与I/O设备之间的中间电路或部件</strong>，由<strong>硬件电路和相应的控制软件</strong>构成，是信息传送的桥梁和纽带</p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025090853964.png" class title="image-20221025090853964"><p><strong>端口</strong>：I/O接口电路中可通过<strong>编程寻址并进行读写的寄存器</strong><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025091432753.png" class title="image-20221025091432753"></p><ul><li>数据端口：暂存数据信息</li><li>控制端口：接受控制信息</li><li>状态端口：反应接口外设的状态信息</li></ul><p>接口由数据缓冲寄存器DBR、状态寄存器、命令寄存器、端口地址译码、控制逻辑和中断逻辑组成</p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/image-20221025092211126.png" class title="image-20221025092211126"><p>I/O编制的方法：</p><ul><li>统一编址：I/O与内存统一进行编制</li><li>独立编址：I/O与内存有各自独立的地址空间，互不干扰</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lab10-Priority Queues</title>
    <link href="/2022/10/07/cs61b/lab10-Priority-Queues/"/>
    <url>/2022/10/07/cs61b/lab10-Priority-Queues/</url>
    
    <content type="html"><![CDATA[<p>优先队列的特点是元素正常入队，按照优先级的大小进行出队</p><p>堆是另一种与优先队列不同的数据结构</p><p>一般来说，堆是用来实现优先队列的，非严格意义上，优先队列可以等同于堆</p><p>用数组模拟一个小顶堆（二叉树，但是根节点永远是最小值），其中数组的索引为0的地方为null，方便换算索引</p><p>Node节点：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> T myItem;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> myPriority;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item, <span class="hljs-type">double</span> priority)</span> &#123;<br>        myItem = item;<br>        myPriority = priority;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">item</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> myItem;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">priority</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> myPriority;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> myItem.toString() + <span class="hljs-string">&quot;, &quot;</span> + myPriority;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中myPriority为优先级，本题为小顶堆，此值越小优先级越高</p><p>位置为index的节点：父节点：index/2，左右节点分别为：index<em>2，index\</em>2+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayHeap</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExtrinsicPQ</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node[] contents;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayHeap</span><span class="hljs-params">()</span> &#123;<br>        contents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayHeap</span>.Node[<span class="hljs-number">16</span>];<br><br>        <span class="hljs-comment">/* Add a dummy item at the front of the ArrayHeap so that the getLeft,</span><br><span class="hljs-comment">         * getRight, and parent methods are nicer. */</span><br>        contents[<span class="hljs-number">0</span>] = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">/* Even though there is an empty spot at the front, we still consider</span><br><span class="hljs-comment">         * the size to be 0 since nothing has been inserted yet. */</span><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the index of the node to the left of the node at i.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Your code here! */</span><br>        <span class="hljs-keyword">return</span> i*<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the index of the node to the right of the node at i.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rightIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Your code here! */</span><br>        <span class="hljs-keyword">return</span> i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the index of the node that is the parent of the node at i.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parentIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Your code here! */</span><br>        <span class="hljs-keyword">return</span> i/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets the node at the ith index, or returns null if the index is out of</span><br><span class="hljs-comment">     * bounds.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!inBounds(index)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> contents[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns true if the index corresponds to a valid item. For example, if</span><br><span class="hljs-comment">     * we have 5 items, then the valid indices are 1, 2, 3, 4, 5. Index 0 is</span><br><span class="hljs-comment">     * invalid because we leave the 0th entry blank.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inBounds</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> ((index &gt; size) || (index &lt; <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Swap the nodes at the two indices.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> getNode(index1);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> getNode(index2);<br>        contents[index1] = node2;<br>        contents[index2] = node1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比较重要的几个方法：</p><ul><li>添加节点：将节点添加在最右节点上，然后判断该节点的优先级和父节点的优先级的关系，交换节点直到该节点的值是优先级比父节点的优先级小，这一方法也叫swim</li><li>删除最小的节点：将根节点和最右节点的值交换，删除此时的最右节点，然后判断根节点和左右节点的值的关系，交换节点直到该节点的优先级大于子节点的优先级，这一方法也叫skin</li></ul><p>swim和skin:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Bubbles up the node currently at the given index.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// Throws an exception if index is invalid. DON&#x27;T CHANGE THIS LINE.</span><br>    validateSinkSwimArg(index);<br>    <span class="hljs-comment">/** <span class="hljs-doctag">TODO:</span> Your code here. */</span><br>    <span class="hljs-keyword">if</span>(index&gt;<span class="hljs-number">1</span>&amp;&amp;contents[index].myPriority&lt;contents[parentIndex(index)].myPriority)&#123;<br>        swap(index,parentIndex(index));<br>        swim(parentIndex(index));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Bubbles down the node currently at the given index.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// Throws an exception if index is invalid. DON&#x27;T CHANGE THIS LINE.</span><br>    validateSinkSwimArg(index);<br>    <span class="hljs-comment">/** <span class="hljs-doctag">TODO:</span> Your code here. */</span><br>   <span class="hljs-keyword">if</span>(leftIndex(index)&lt;=size)&#123;<span class="hljs-comment">//至少有一个左节点</span><br>       <span class="hljs-comment">//判断是否有右节点，再判断左右节点的优先级</span><br>       <span class="hljs-type">int</span> minIndex=leftIndex(index);<br>       <span class="hljs-comment">//右节点存在并且右节点的值更小（优先级更大）</span><br>       <span class="hljs-keyword">if</span>(inBounds(rightIndex(index))&amp;&amp;contents[rightIndex(index)].myPriority&lt;contents[minIndex].myPriority)&#123;<br>           minIndex++;<br>       &#125;<br>       <span class="hljs-comment">//左右节点互相比较，得到的节点为minIndex，如果minIndex的优先级比index更小（值更大），结束</span><br>       <span class="hljs-keyword">if</span>(contents[minIndex].myPriority&gt;=contents[index].myPriority) <span class="hljs-keyword">return</span>;<br>       swap(minIndex,index);<br>       sink(minIndex);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>刚开始用的迭代的方法，有些困难，用递归会简单很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts an item with the given priority value. This is enqueue, or offer.</span><br><span class="hljs-comment"> * To implement this method, add it to the end of the ArrayList, then swim it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item, <span class="hljs-type">double</span> priority)</span> &#123;<br>    <span class="hljs-comment">/* If the array is totally full, resize. */</span><br>    <span class="hljs-keyword">if</span> (size + <span class="hljs-number">1</span> == contents.length) &#123;<br>        resize(contents.length * <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Your code here! */</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item,priority);<br>    <span class="hljs-type">int</span> index=++size;<br>    contents[index]=node;<br>    swim(index);<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the Node with the smallest priority value, but does not remove it</span><br><span class="hljs-comment"> * from the heap. To implement this, return the item in the 1st position of the ArrayList.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Your code here! */</span><br>    <span class="hljs-keyword">return</span> contents[<span class="hljs-number">1</span>].myItem;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the Node with the smallest priority value, and removes it from</span><br><span class="hljs-comment"> * the heap. This is dequeue, or poll. To implement this, swap the last</span><br><span class="hljs-comment"> * item from the heap into the root position, then sink the root. This is</span><br><span class="hljs-comment"> * equivalent to firing the president of the company, taking the last</span><br><span class="hljs-comment"> * person on the list on payroll, making them president, and then demoting</span><br><span class="hljs-comment"> * them repeatedly. Make sure to avoid loitering by nulling out the dead</span><br><span class="hljs-comment"> * item.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">removeMin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Your code here! */</span><br>    <span class="hljs-comment">//记录根节点（优先级最高的节点）</span><br>    T val=contents[<span class="hljs-number">1</span>].myItem;<br>    <span class="hljs-comment">//交换最小节点和最右叶子节点</span><br>    swap(<span class="hljs-number">1</span>,size);<br>    <span class="hljs-comment">//删除最右叶子节点</span><br>    contents[size--]=<span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//让根节点下沉到合适位置</span><br>    sink(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the number of items in the PQ. This is one less than the size</span><br><span class="hljs-comment"> * of the backing ArrayList because we leave the 0th element empty. This</span><br><span class="hljs-comment"> * method has been implemented for you.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Change the node in this heap with the given item to have the given</span><br><span class="hljs-comment">     * priority. You can assume the heap will not have two nodes with the same</span><br><span class="hljs-comment">     * item. Check item equality with .equals(), not ==. This is a challenging</span><br><span class="hljs-comment">     * bonus problem, but shouldn&#x27;t be too hard if you really understand heaps</span><br><span class="hljs-comment">     * and think about the algorithm before you start to code.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changePriority</span><span class="hljs-params">(T item, <span class="hljs-type">double</span> priority)</span> &#123;<br>        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Your code here! */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>            <span class="hljs-keyword">if</span>(contents[i].myItem.equals(item))&#123;<span class="hljs-comment">//找到该节点</span><br>                <span class="hljs-type">double</span>  prev=contents[i].myPriority;<br>                contents[i].myPriority=priority;<br>                <span class="hljs-keyword">if</span>(prev&gt;priority)&#123;<span class="hljs-comment">//优先级变大，往上游</span><br>                    swim(i);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    sink(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateSinkSwimArg</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot sink or swim nodes with index 0 or less&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt; size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot sink or swim nodes with index greater than current size.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (contents[index] == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot sink or swim a null node.&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">/** Helper function to resize the backing array when necessary. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        Node[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayHeap</span>.Node[capacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">this</span>.contents.length; i++) &#123;<br>            temp[i] = <span class="hljs-built_in">this</span>.contents[i];<br>        &#125;<br>        <span class="hljs-built_in">this</span>.contents = temp;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个作业不要求有完美的答案，所以最后得分乘2</p><img src="/2022/10/07/cs61b/lab10-Priority-Queues/image-20221007224105538.png" class title="image-20221007224105538"><img src="/2022/10/07/cs61b/lab10-Priority-Queues/image-20221007224115140.png" class title="image-20221007224115140">]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HW3-Hashing</title>
    <link href="/2022/10/07/cs61b/HW3-Hashing/"/>
    <url>/2022/10/07/cs61b/HW3-Hashing/</url>
    
    <content type="html"><![CDATA[<h1 id="SimpleOoage"><a href="#SimpleOoage" class="headerlink" title="SimpleOoage"></a>SimpleOoage</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>重写equals方法需要满足：</p><ul><li>自反性：<code>x.equals(x)</code>对于任何非null都必须为true</li><li>对称性：<code>x.equals(y)</code>必须与<code>y.equals(x)</code>任何非null的x和y返回相同的值</li><li><p>传递性：如果有<code>x.equals(y)</code>和<code>y.equals(z)</code>,那么<code>x.equals(z)</code>对于非空的x，y，z结果应该一致</p></li><li><p>一致性：<code>x.equals(y)</code>多次调用必须返回相同的结果</p></li></ul><p>此外相同的对象必须有相同的hashCode，必须重写hashCode()方法</p><p>重写equals方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">boolean</span> <span class="hljs-params">(Object o)</span>&#123;<br><span class="hljs-keyword">if</span>(o==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果o为null，返回false</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>==o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果this和o为同一个对象，返回true</span><br><span class="hljs-keyword">if</span>(getClass()!=o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果this和o为不为同一个类，返回false</span><br>A Ao=(A) o;<br>    <span class="hljs-comment">//逐项比较是否是属性是否相同</span><br><span class="hljs-keyword">return</span> Object.equals(<span class="hljs-built_in">this</span>.第一个属性,o.第一个属性)&amp;&amp;Object.equals(<span class="hljs-built_in">this</span>.第二个属性,o.第二个属性)&amp;&amp;·······; <br>&#125;<br></code></pre></td></tr></table></figure><p>最后重写SimpleOoage方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>       <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Write this method.</span><br>       <span class="hljs-comment">//如果o为空，一定返回false</span><br>       <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       <span class="hljs-comment">//检查this和o是否时同一对象，</span><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>==o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">//检查this和o是否是同一个类</span><br>       <span class="hljs-keyword">if</span>(getClass()!=o.getClass())&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-comment">//检查this和o的各项属性是否相等</span><br>       SimpleOomage so=(SimpleOomage) o;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.red==so.red&amp;&amp;<span class="hljs-built_in">this</span>.blue==so.blue&amp;&amp;<span class="hljs-built_in">this</span>.green==so.green;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h2><p>给定的hashCode方法过于简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!USE_PERFECT_HASH) &#123;<br>        <span class="hljs-keyword">return</span> red + green + blue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Write a perfect hash function for Simple Oomages.</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-number">61</span>*(<span class="hljs-number">61</span>*(red*<span class="hljs-number">61</span>+green)+blue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>评估hashCode：测试哈希碰撞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OomageTestUtility</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">haveNiceHashCodeSpread</span><span class="hljs-params">(List&lt;Oomage&gt; oomages, <span class="hljs-type">int</span> M)</span> &#123;<br><br>        <span class="hljs-type">int</span> [] buckets=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; oomages.size();i++)&#123;<br>            <span class="hljs-type">int</span> bucketNum=(oomages.get(i).hashCode()&amp;<span class="hljs-number">0x77FFFFFF</span>)%M;<br>            buckets[bucketNum]++;<br>            <span class="hljs-keyword">if</span>(buckets[bucketNum]&gt;= oomages.size()/<span class="hljs-number">2.5</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; buckets.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(buckets[i]&lt;= oomages.size()/<span class="hljs-number">50</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用提供给的可视化工具，查看发现当“桶”的个数M为5的倍数时，哈希碰撞明显增多，原因时SimpleOoage的red，blue，green参数都是5的倍数，设计的哈希函数得到的结果也是5的倍数</p><p>M=15：</p><img src="/2022/10/07/cs61b/HW3-Hashing/image-20221007194506463.png" class title="image-20221007194506463"><p>M=10：</p><img src="/2022/10/07/cs61b/HW3-Hashing/image-20221007194541403.png" class title="image-20221007194541403"><p>但是M=9：</p><img src="/2022/10/07/cs61b/HW3-Hashing/image-20221007194600794.png" class title="image-20221007194600794"><p>所以需要在hashCode计算时，讲red，green，blue的值除以5</p><h1 id="ComplexOomage"><a href="#ComplexOomage" class="headerlink" title="ComplexOomage"></a>ComplexOomage</h1><p>这个类的hashCode看起来是没问题的，要编写一个测试类，找出它的hashCode问题</p><p>hashCode：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : params) &#123;<br>        total = total * <span class="hljs-number">256</span>;<br>        total = total + x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行给出的Hint.java，结果：<img src="/2022/10/07/cs61b/HW3-Hashing/image-20221007200004195.png" class title="image-20221007200004195"></p><p>256二进制表示就是一个1后8个0，int的表示范围是一个1后32个0，只要乘四次就能越界而让hashCode失效，只要让Params的后四位为1就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWithDeadlyParams</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Oomage&gt; deadlyList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-type">int</span> deadlyListSize=<span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;deadlyListSize;i++)&#123;<br>        <span class="hljs-type">int</span> N= StdRandom.uniform(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br>        ArrayList&lt;Integer&gt; params=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;N-<span class="hljs-number">4</span>;j++)&#123;<br>            params.add(StdRandom.uniform(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=N-<span class="hljs-number">4</span>;j&lt;N;j++)&#123;<br>            params.add(<span class="hljs-number">1</span>);<br>        &#125;<br>        deadlyList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComplexOomage</span>(params));<br>    &#125;<br>    assertTrue(OomageTestUtility.haveNiceHashCodeSpread(deadlyList, <span class="hljs-number">10</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>测试后，报错，说明成功<img src="/2022/10/07/cs61b/HW3-Hashing/image-20221007201355466.png" class title="image-20221007201355466"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lab9-TreeMap、HashMap</title>
    <link href="/2022/10/07/cs61b/lab9-TreeMap%E3%80%81HashMap/"/>
    <url>/2022/10/07/cs61b/lab9-TreeMap%E3%80%81HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="BSTMap"><a href="#BSTMap" class="headerlink" title="BSTMap"></a>BSTMap</h1><p>用<a href="https://www.malchinee.top/2022/09/02/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉搜索树</a>结构实现一个Map，要求至少实现get，size，put方法</p><p>可选的实现remove方法和迭代器iterator，KeySet</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTMap</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;K&gt;, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map61B</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-comment">/* (K, V) pair stored in this Node. */</span><br>        <span class="hljs-keyword">private</span> K key;<br>        <span class="hljs-keyword">private</span> V value;<br><br>        <span class="hljs-comment">/* Children of this Node. */</span><br>        <span class="hljs-keyword">private</span> Node left;<br>        <span class="hljs-keyword">private</span> Node right;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(K k, V v)</span> &#123;<br>            key = k;<br>            value = v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node root;  <span class="hljs-comment">/* Root node of the tree. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">/* The number of key-value pairs in the tree */</span><br>    <span class="hljs-comment">/* Creates an empty BSTMap. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.clear();<br>    &#125;<br><br>    <span class="hljs-comment">/* Removes all of the mappings from this map. */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-literal">null</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns the value mapped to by KEY in the subtree rooted in P.</span><br><span class="hljs-comment">     *  or null if this map contains no mapping for the key.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> V <span class="hljs-title function_">getHelper</span><span class="hljs-params">(K key, Node p)</span> &#123;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (key.compareTo(p.key)&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> getHelper(key,p.left);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(p.key)&gt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> getHelper(key, p.right);<br>        <span class="hljs-keyword">return</span> p.value;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or null if this</span><br><span class="hljs-comment">     *  map contains no mapping for the key.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-keyword">return</span> getHelper(key,root);<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns a BSTMap rooted in p with (KEY, VALUE) added as a key-value mapping.</span><br><span class="hljs-comment">      * Or if p is null, it returns a one node BSTMap containing (KEY, VALUE).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">putHelper</span><span class="hljs-params">(K key, V value, Node p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">null</span>)&#123;<br>            size++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (key.compareTo(p.key)&lt;<span class="hljs-number">0</span>)p.left=putHelper(key,value,p.left);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.compareTo(p.key)&gt;<span class="hljs-number">0</span>)p.right=putHelper(key,value,p.right);<br>        <span class="hljs-keyword">else</span> p.value=value;<br>        <span class="hljs-keyword">return</span> p;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** Inserts the key KEY</span><br><span class="hljs-comment">     *  If it is already present, updates value to be VALUE.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        root=putHelper(key,value,root);<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns the number of key-value mappings in this map. */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">//////////////// EVERYTHING BELOW THIS LINE IS OPTIONAL ////////////////</span><br><br>    <span class="hljs-comment">/* Returns a Set view of the keys contained in this map. */</span><br>    <span class="hljs-comment">//将所有的key保存为一个set集合</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Set&lt;K&gt; keySet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        keySetHelper(root,keySet);<br>        <span class="hljs-keyword">return</span> keySet;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keySetHelper</span><span class="hljs-params">(Node node,Set&lt;K&gt; keySet)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        keySetHelper(node.left,keySet);<br>        keySet.add(node.key);<br>        keySetHelper(node.right,keySet);<br><br>    &#125;<br><br>    <span class="hljs-comment">/** Removes KEY from the tree if present</span><br><span class="hljs-comment">     *  returns VALUE removed,</span><br><span class="hljs-comment">     *  null on failed removal.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//待删除节点</span><br>        Node targetNode=search(key);<br>        <span class="hljs-comment">//待删除节点为空</span><br>        <span class="hljs-keyword">if</span>(targetNode==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//保存待删除节点的value</span><br>        V val=targetNode.value;<br>        <span class="hljs-comment">//如果要删除根节点并且该TreeMap只有一个节点</span><br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;root.key.compareTo(key)==<span class="hljs-number">0</span>)&#123;<br>            root=<span class="hljs-literal">null</span>;<br>            size--;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        <span class="hljs-comment">//待删除节点的父节点</span><br>        Node parent=searchParent(key);<br>        <span class="hljs-comment">//待删除的节点是叶子节点</span><br>        <span class="hljs-keyword">if</span>(targetNode.left==<span class="hljs-literal">null</span>&amp;&amp;targetNode.right==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(parent.left!=<span class="hljs-literal">null</span>&amp;&amp;parent.left==targetNode)&#123;<br>                parent.left=<span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> parent.right=<span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(targetNode.left!=<span class="hljs-literal">null</span>&amp;&amp;targetNode.right!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//待删除节点是两棵子树的节点</span><br>            <span class="hljs-comment">//找到该节点的右子树的最小值</span><br>            Node minNode=delRightTreeMin(targetNode);<br>            targetNode.key=minNode.key;<br>            targetNode.value= minNode.value;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//只有左子树或者右子树</span><br>            <span class="hljs-keyword">if</span>(targetNode.left!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//有左子树</span><br>                <span class="hljs-keyword">if</span>(parent!=<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(parent.left==targetNode)&#123;<br>                        parent.left=targetNode.left;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        parent.right=targetNode.left;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    root=targetNode.left;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//有右子树</span><br>                <span class="hljs-keyword">if</span>(parent!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//有父节点</span><br>                    <span class="hljs-keyword">if</span>(parent.left==targetNode)&#123;<span class="hljs-comment">//父节点的左子树是targetNode</span><br>                        parent.left=targetNode.right;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//父节点的右子树是targetNode</span><br>                        parent.right=targetNode.right;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//无父节点，即删除根节点</span><br>                    root=targetNode.right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">delRightTreeMin</span><span class="hljs-params">(Node node)</span>&#123;<br>        Node target=node;<br>        <span class="hljs-keyword">while</span>(target.left!=<span class="hljs-literal">null</span>)&#123;<br>            target=target.left;<br>        &#125;<br>        remove(target.key);<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>    <span class="hljs-comment">/** Removes the key-value entry for the specified key only if it is</span><br><span class="hljs-comment">     *  currently mapped to the specified value.  Returns the VALUE removed,</span><br><span class="hljs-comment">     *  null on failed removal.</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-comment">//找到要删除的节点</span><br>        Node node=search(key);<br>        <span class="hljs-keyword">if</span>(node.value!=value)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> remove(key);<br>    &#125;<br><br>    <span class="hljs-comment">//找到删除的节点，如果找不到就返回null</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">search</span><span class="hljs-params">(K key)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> searchHelper(key,root);<br>    &#125;<br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">searchHelper</span><span class="hljs-params">(K key,Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(key.compareTo(node.key)==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.compareTo(node.key)&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node.left==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> searchHelper(key,node.left);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(node.right==<span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> searchHelper(key,node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//找到删除节点的父节点</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">searchParent</span><span class="hljs-params">(K key)</span>&#123;<br>        <span class="hljs-keyword">return</span> searchParentHelper(key,root);<br>    &#125;<br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">searchParentHelper</span><span class="hljs-params">(K key,Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>((node.left!=<span class="hljs-literal">null</span>&amp;&amp;node.left.key.compareTo(key)==<span class="hljs-number">0</span>)||<br>                (node.right!=<span class="hljs-literal">null</span>&amp;&amp;node.right.key.compareTo(key)==<span class="hljs-number">0</span>))&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>       <span class="hljs-keyword">if</span>(key.compareTo(node.key)&lt;<span class="hljs-number">0</span>&amp;&amp;node.left!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> searchParentHelper(key,node.left);<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.compareTo(node.key)&gt;<span class="hljs-number">0</span>&amp;&amp;node.right!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> searchParentHelper(key,node.right);<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;K&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BSTIterator</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;K&gt;&#123;<br>        <span class="hljs-keyword">private</span> Iterator &lt;K&gt; curr;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTIterator</span><span class="hljs-params">()</span>&#123;<br>            curr=keySet().iterator();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> curr.hasNext();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> K <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> curr.next();<br>        &#125;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>之前没有实现过的是Iterator迭代器和KeySet方法</p><p>新建迭代器方法实现一个构造函数、hasNext()、next()方法即可，其实是利用了Set集合的iterator</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>MyHashMap类用到了已经提供的ArrayMap类，ArrayMap类用两条数组，一条表示key，另一条表示value。</p><p>在加入一条key-value时先计算key的hash值，然后再在对应的ArrayMap[hash(key)]中插入这条key-value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map61B</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">MAX_LF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75</span>;<br><br>    <span class="hljs-keyword">private</span> ArrayMap&lt;K, V&gt;[] buckets;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadFactor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size / buckets.length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHashMap</span><span class="hljs-params">()</span> &#123;<br>        buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>[DEFAULT_SIZE];<br>        <span class="hljs-built_in">this</span>.clear();<br>    &#125;<br><br>    <span class="hljs-comment">/* Removes all of the mappings from this map. */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.buckets.length; i += <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">this</span>.buckets[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** Computes the hash function of the given key. Consists of</span><br><span class="hljs-comment">     *  computing the hashcode, followed by modding by the number of buckets.</span><br><span class="hljs-comment">     *  To handle negative numbers properly, uses floorMod instead of %.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numBuckets</span> <span class="hljs-operator">=</span> buckets.length;<br>        <span class="hljs-keyword">return</span> Math.floorMod(key.hashCode(), numBuckets);<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns the value to which the specified key is mapped, or null if this</span><br><span class="hljs-comment">     * map contains no mapping for the key.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>       <span class="hljs-keyword">return</span> buckets[hash(key)].get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/* Associates the specified value with the specified key in this map. */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-comment">//需要扩充buckets</span><br>        <span class="hljs-keyword">if</span>(loadFactor()&gt;MAX_LF)&#123;<br>            resize(buckets.length*<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-comment">//只有第一次加才会size++</span><br>        <span class="hljs-keyword">if</span>(!containsKey(key))&#123;<br>            size++;<br>        &#125;<br>        buckets[hash(key)].put(key,value);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newLength)</span>&#123;<br>        ArrayMap&lt;K, V&gt;[] temp=buckets;<br>        buckets=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>[newLength];<br>        clear();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.length;i++)&#123;<br>            Set&lt;K&gt; set=temp[i].keySet();<br>            Iterator&lt;K&gt; it=set.iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                K nextKey=it.next();<br>                put(nextKey,temp[i].get(nextKey));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns the number of key-value mappings in this map. */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">//////////////// EVERYTHING BELOW THIS LINE IS OPTIONAL ////////////////</span><br><br>    <span class="hljs-comment">/* Returns a Set view of the keys contained in this map. */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span> &#123;<br>        Set&lt;K&gt; keySet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; buckets.length;i++)&#123;<br>            keySet.addAll(buckets[i].keySet());<br>        &#125;<br>        <span class="hljs-keyword">return</span> keySet;<br>    &#125;<br><br>    <span class="hljs-comment">/* Removes the mapping for the specified key from this map if exists.</span><br><span class="hljs-comment">     * Not required for this lab. If you don&#x27;t implement this, throw an</span><br><span class="hljs-comment">     * UnsupportedOperationException. */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-comment">//如果不包含这个key</span><br>        <span class="hljs-keyword">if</span>(!containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        V val=buckets[hash(key)].remove(key);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-comment">/* Removes the entry for the specified key only if it is currently mapped to</span><br><span class="hljs-comment">     * the specified value. Not required for this lab. If you don&#x27;t implement this,</span><br><span class="hljs-comment">     * throw an UnsupportedOperationException.*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        V val=buckets[hash(key)].remove(key);<br>        <span class="hljs-keyword">if</span>(val!=value) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;K&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMapIterator</span>();<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br>       <span class="hljs-keyword">private</span> Iterator&lt;K&gt; curr;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMapIterator</span><span class="hljs-params">()</span>&#123;<br>           curr=keySet().iterator();<br>       &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> curr.hasNext();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> curr.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：<img src="/2022/10/07/cs61b/lab9-TreeMap%E3%80%81HashMap/image-20221007155107425.png" class title="image-20221007155107425"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>存储系统2</title>
    <link href="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/"/>
    <url>/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/</url>
    
    <content type="html"><![CDATA[<h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><p>主存由RAM和ROM芯片组成</p><p><strong>系统程序区</strong>存放的是不需要改动也不允许改动的系统程序，由ROM实现</p><p><strong>系统程序工作区</strong>是系统程序在工作时写入并读出临时数据的，由RAM实现</p><p><strong>用户程序区</strong>存放的是用户的程序与数据，这些信息是可读、可改写的，由RAM实现</p><script type="math/tex; mode=display">主存储器的容量=存储单元数×字节</script><p>一个处理器对应的主存储器的<strong>最大存储单元数</strong>是由其<strong>地址总线的线数</strong>决定的</p><p><strong>存储器扩展</strong>：将若干存储芯片连接在一起组成特定机器的存储系统</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006081708991.png" class title="image-20221006081708991"><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h3><p>只增加存储字长，存储单元个数不变</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006082531543.png" class title="image-20221006082531543"><h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>增加存储单元个数，不扩展字长</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006084038617.png" class title="image-20221006084038617"><p>分时工作</p><h3 id="字、位同时扩展"><a href="#字、位同时扩展" class="headerlink" title="字、位同时扩展"></a>字、位同时扩展</h3><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006085809079.png" class title="image-20221006085809079"><p>4位-&gt;8位，位扩展，每两个一组</p><p>1k-&gt;4k，字扩展，用2-4译码器控制四组中只有一组工作</p><h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><h3 id="连接线："><a href="#连接线：" class="headerlink" title="连接线："></a>连接线：</h3><p>精髓：CPU与存储器通过三总线的连接<img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006091243613.png" class title="image-20221006091243613"></p><h3 id="三类线连接的注意事项"><a href="#三类线连接的注意事项" class="headerlink" title="三类线连接的注意事项"></a>三类线连接的注意事项</h3><ol><li><p>CPU的数据线与存储芯片的数据线连接</p><p>CPU数据线与存储系统数据线应匹配（是否进行位扩展）</p></li><li><p>地址线连接：</p><p>当CPU的地址线N=存储芯片的地址线K时-&gt;直接相连</p><p>当CPU的地址线N&gt;存储芯片的地址线K时-&gt;将CPU的地址线分成两部分<img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006091606897.png" class title="image-20221006091606897"></p><p>片选信号的三种形成方法：全译码、部分译码、线选法</p></li><li><p>控制线连接比较简单</p></li></ol><h3 id="片选信号形成方法："><a href="#片选信号形成方法：" class="headerlink" title="片选信号形成方法："></a>片选信号形成方法：</h3><ul><li><p><strong>全译码方法</strong>：除了将地址总线的低位地址直接连接至各存储芯片的地址线外，将所有<strong>余下的高位地址全部用于译码</strong>，译码输出作为各存储芯片片选信号<img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006092547885.png" class title="image-20221006092547885"></p></li><li><p><strong>部分译码法</strong>：只选用地址总线高位地址的一部分进行译码，以产生各个存储器芯片的片选信号<img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006092906339.png" class title="image-20221006092906339"></p><p>A18既可以是0，也可以是1；两套地址，指向同一个单元</p></li><li><p><strong>线选法</strong>：当存储器容量不大，所使用的存储芯片数量不多，而CPU寻址空间远远大于存储器容量时，可用<strong>高位地址线直接作为存储芯片的片选信号，每一根地址线选通一块芯片</strong><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006094002212.png" class title="image-20221006094002212"></p><p>优点：无须使用片选译码器</p><p>缺点：存储地址空间被分成了相互隔离的区段，造成地址空间的不连续（片选线多于一位“0”以及片选线全为“1”的地址空间不能使用）<img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221006094215137.png" class title="image-20221006094215137"></p></li></ul><p>例：</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221011083732663.png" class title="image-20221011083732663"><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221011084510267.png" class title="image-20221011084510267"><p>两片1K×4位RAM字扩展成2K×4位的一块大芯片，$A_{13}—A_{11}$连接CBA，两块芯片的CBA不能相等，$\overline{Y_4}$有效时访问ROM，$\overline{Y_5}$有效时访问RAM</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221011085625816.png" class title="image-20221011085625816"><p>常用单位：32768=32K，65536=64K，1024=1K</p><h2 id="提升主存储器访问带宽的方法"><a href="#提升主存储器访问带宽的方法" class="headerlink" title="提升主存储器访问带宽的方法"></a>提升主存储器访问带宽的方法</h2><ul><li>采用高速器件</li><li>采用层次结构Cache-主存</li><li>调整主存结构：通过引入并行处理技术来提高主存储器访问带宽<ul><li>多端口RAM</li><li>多模块存储器</li></ul></li></ul><h3 id="双口RAM"><a href="#双口RAM" class="headerlink" title="双口RAM"></a>双口RAM</h3><p>具有两套读/写控制逻辑的RAM，<strong>具有两个独立的端口，L和R</strong>，分别具有各自的：地址总线、数据总线和、控制总线</p><p>当两个端口的访问地址不同时，这两个访问可以同时进行；当发生访问冲突时，由片内仲裁逻辑决定哪个端口先进行访问</p><p>双端口RAM常作为流水线处理器的计算机主存储器</p><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>分类：</p><ul><li><p><strong>单体多字存储器</strong></p><p><strong>多个存储器模块共用一套地址逻辑</strong>。这样一个访存地址就可以把存储于多个存储器模块中相同地址单元的多字一并读出，然后依次将它们送给处理器</p><p>前提：指令和数据在内存中必须是<strong>连续存放</strong>的</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221011092808469.png" class title="image-20221011092808469"><p>在一个存取周期内，从一个地址取出4条指令，再逐条将指令送给CPU去执行，每隔四分之一存取周期，主存向CPU送一条指令</p><p>类似”位扩展“</p></li><li><p>多体并行存储器</p><p>由N个<strong>容量相同、字长相同</strong>的存储器模块组成。它的各个存储器模块分别拥有<strong>独立的地址逻辑</strong></p><p>只要连续访问的存储单元不在同一个存储器模块中，这些模块就可以相互<strong>错开1/N周期启动、交叉占用系统的地址总线、数据总线和控制总线</strong></p><p>模N交叉存储器提供的存储容量为单体存储器的<strong>N</strong>倍，<strong>地址总线宽度要大于单体存储器的地址总线宽度</strong>，多出去的那部分地址用于生成不同存储体的片选信号</p><p>区分存储器的体号，可以在左边的高位，也可以在右边的低位，可分类：</p><ul><li>高位交叉编址存储器</li></ul></li></ul><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221011094451863.png" class title="image-20221011094451863"><ul><li><p>低位交叉编制存储器</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221013082528613.png" class title="image-20221013082528613"><p>特点：地址不连续，容易形成并行工作局面</p><p>缺点：可靠性差，一个存储体失效，整个存储将崩溃</p></li></ul><h1 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h1><p>解决：主存储器的速度始终赶不上处理器的速度</p><p>用SRAM实现，容量小于主存容量，速度高于DRAM</p><p><strong>程序访问的局部性原理</strong>：在一段较短的时间间隔内，CPU所访问的程序在内存中的地址往往集中在内存某一个地址范围内</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20220901203132507.png" class title="image-20220901203132507"><p>作用：“缓存加速”，提高CPU的访问速度</p><p>通常在主存与Cache之间设置一条多字节宽的局部数据线</p><p>当Cache不命中时，CPU将在访问目标数据的同时，一并从主存读出来的M个字，并将其作为一个块传送给Cache</p><p>有Cache之后，寻址：先定位到块，然后再定位到存储单元</p><p><strong>主存和缓存的编址：</strong></p><p>规定：主存和缓存按块存储，块的大小相同，B为块长</p><p>主存储块：$M=2^m$块长：$B=2^b$</p><p>Cache块数：$C=2^c$块长 $B=2^b$</p><p>$M&gt;&gt;C$</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221013093940817.png" class title="image-20221013093940817"><p><strong>Cache标记</strong>： 表示当前存放的是哪一个主存快，相当于主存块的块号，CPU访问Cache时用贮存地址的m位与标记比较，确定是否命中</p><p>标记存放在CAM（相联存储器）中</p><p>块长一般取4~8个可编址单位</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221018162333530.png" class title="image-20221018162333530"><h2 id="Cache的地址映象："><a href="#Cache的地址映象：" class="headerlink" title="Cache的地址映象："></a>Cache的地址映象：</h2><p>由于块内地址一致，是主存块号与Cache块间的转换</p><p>主存Cache地址映象变换机构：完成主存地址到Cache地址的变换</p><ul><li><p><strong>直接映射方法</strong>：</p><script type="math/tex; mode=display">i=j\ mod\ C\ (C=2^c)</script><p>i：Cache块号；j：主存块号；C：Cache的总块数量</p><p>Cache块与主存块一对多</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221018164739579.png" class title="image-20221018164739579"><p><strong>流程</strong>：当缓存接到CPU传来的主存地址后，根据中间的c位，找到Cache子块。然后根据前t位判断是否与Cache的高t位判断是否相等</p></li><li><p><strong>全相联映射方式</strong>:</p><p>主存中的任一块可映射到Cache中的任一块，完全自由</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221018165928404.png" class title="image-20221018165928404"><p>主存共有$2^m$块，可以映射到cache中的任一块。标记位为m=t+c，访问Cache时需与全部的Cache块的标记进行比较</p></li><li><p><strong>组相联映射方式</strong>：</p><p>Cache分为Q组，每组R块</p><p>$i=j\ mod\ Q$</p><p>Q：Cache共分为Q组；j：主存某块号；i：主存j块对应的Cache组号</p><p>主存块与Cache组之间是直接映射，主存块同Cache特定组内的块时全相联映射</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221018171047994.png" class title="image-20221018171047994"></li><li><p><strong>段相联映射方式：</strong></p><p>将Cache和内存分为若干包含相同块数的段</p><p>段之间全相联映射，段内块之间直接映射</p></li></ul><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p>替换：当一个新的主存块需要拷贝到Cache，而允许存放此块的位置被其他的主存快占用时，就需要替换</p><p><strong>先进先出算法（FIFO）</strong>：将最先调入Cache的子块替换出去</p><p><strong>近期最少使用算法（LRU）</strong>：将近期内最少使用的子块替换出去</p><h2 id="Cache写操作"><a href="#Cache写操作" class="headerlink" title="Cache写操作"></a>Cache写操作</h2><ul><li><strong>写回法</strong>：<ul><li>CPU写Cache命中时，只修改Cache中的内容，而不立即写入主存，只有当该块被换出到内存时才写回主存</li><li>未命中时，将此块拷贝到Cache中进行修改，而主存的写操作统一留到该块被换出时才进行</li></ul></li><li><p><strong>全写法</strong>：</p><ul><li>Cache命中时，内存和Cache同时进行写操作</li><li>未命中时，只写入内存</li></ul></li><li><p><strong>只写主存法</strong>：</p><ul><li>写Cache命中时，信息只写入主存，同时将Cache块置为失效</li><li>写Cache未命中时，此时被写入的单元根本不在Cache中，因此只写入主存</li></ul></li></ul><h1 id="123"><a href="#123" class="headerlink" title="123"></a>123</h1><h2 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h2><p>CRC码是基于模2运算建立的校验码制</p><p>原则：</p><ul><li>部分余数首位是1，上商1；部分余数首位为0，上商0；</li><li>部分余数位数小于除数位数时，即为最后余数</li></ul><p>待编码信息：<script type="math/tex">D_{n-1}D_{n-2}...D_2D_1D_0</script></p><p>编码结果：<script type="math/tex">D_{n-1}D_{n-2}....D_2D_1D_0\ XXX... X</script>（后面共k位）</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221025080950130.png" class title="image-20221025080950130"><p><strong>结论</strong>：<script type="math/tex">M(X)X^k+R(X)</script>可以被给定的多项式<script type="math/tex">G(X)</script>除尽</p><p><strong>精髓</strong>：CRC码就是用多项式<script type="math/tex">M(x)x^k</script>除以给定的生成多项式G(X)，所得余数为校验位。为了得到k位余数，G(x)必须是k+1位</p><img src="/2022/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F2/image-20221025081650895.png" class title="image-20221025081650895"><p><strong>检错</strong>：接收方将收到的CRC码模2除G(X)，若传输无误，则余数为0</p><ul><li>如果某一位出错，则余数不为0</li><li>不同的出错位，其余数也不同</li></ul><p>纠错：</p><ul><li>出错位与余数有一定的对应关系，该对应关系与码制及G(x)有关系</li><li>纠错过程：某位出错，余数不为0，将余数补0继续作模2除，得到下一信息为的出错余数。即出错信息位对应的余数构成一个循环——“循环码”</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HW2-Percolation（并查集）</title>
    <link href="/2022/09/29/cs61b/HW2-Percolation/"/>
    <url>/2022/09/29/cs61b/HW2-Percolation/</url>
    
    <content type="html"><![CDATA[<p>这个hardware主要利用并查集（不相交集）来模拟一个情景：</p><p>在一个二维平面上，最上层是压力无穷大的水，可以敲掉二维平面的任何一块方块，模拟水渗入的过程</p><img src="/2022/09/29/cs61b/HW2-Percolation/image-20220929192001395.png" class title="image-20220929192001395"><p>关于被敲掉的方块/总方块，这个比值与整个系统是否被渗透，有一项研究，达到这个阈值，系统被渗透概率突增</p><img src="/2022/09/29/cs61b/HW2-Percolation/image-20220929192213704.png" class title="image-20220929192213704"><h1 id="Percolation-java"><a href="#Percolation-java" class="headerlink" title="Percolation.java"></a>Percolation.java</h1><p>用一位的不相交集代替二维数组，对应关系：row*N+col=一维坐标</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Percolation</span> &#123;<br>    <span class="hljs-keyword">private</span> WeightedQuickUnionUF weightedQuickUnionUF;<span class="hljs-comment">//不相交集</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] isOpen;<span class="hljs-comment">//每个各自是否被打开</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] isFull;<span class="hljs-comment">//是否被渗透</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">//保存N</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numOfOpen;<span class="hljs-comment">//保存开放的节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Percolation</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(N&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IllegalArgumentException(<span class="hljs-string">&quot;N must &gt; 0&quot;</span>);<br>        weightedQuickUnionUF=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeightedQuickUnionUF</span>(N*N);<br>        isOpen=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N][N];<br>        isFull=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N][N];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;<br>                isOpen[i][j]=<span class="hljs-literal">false</span>;<br>                isFull[i][j]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        size=N;<br>        numOfOpen=<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col)</span>&#123;<br>        <span class="hljs-keyword">return</span> row*size+col;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||row&gt;=size||col&lt;<span class="hljs-number">0</span>||col&gt;=size)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IndexOutOfBoundsException(<span class="hljs-string">&quot;row and col must between 0 and N-1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isOpen(row,col))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        isOpen[row][col]=<span class="hljs-literal">true</span>;<br>        numOfOpen++;<br>        <span class="hljs-keyword">if</span>(row!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//行不等于0，必有上一行</span><br>            <span class="hljs-keyword">if</span>(isOpen(row-<span class="hljs-number">1</span>,col))&#123;<span class="hljs-comment">//上一行打开了，把它连接起来</span><br>                weightedQuickUnionUF.union(findIndex(row,col),findIndex(row-<span class="hljs-number">1</span>,col));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFull(row-<span class="hljs-number">1</span>,col))&#123;<br>                isFull[row][col]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(row!=size-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(isOpen(row+<span class="hljs-number">1</span>,col))&#123;<span class="hljs-comment">//下一行打开了，把它连接起来</span><br>                weightedQuickUnionUF.union(findIndex(row,col),findIndex(row+<span class="hljs-number">1</span>,col));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(col!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(isOpen(row,col-<span class="hljs-number">1</span>))&#123;<span class="hljs-comment">//左边打开了，把它连接起来</span><br>                weightedQuickUnionUF.union(findIndex(row,col),findIndex(row,col-<span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFull(row,col-<span class="hljs-number">1</span>))&#123;<br>                isFull[row][col-<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(col!=size-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(isOpen(row,col+<span class="hljs-number">1</span>))&#123;<br>                weightedQuickUnionUF.union(findIndex(row,col),findIndex(row,col+<span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFull(row,col+<span class="hljs-number">1</span>))&#123;<br>                isFull[row][col]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果是第一行的话，水会灌进来</span><br>        <span class="hljs-keyword">if</span>(row==<span class="hljs-number">0</span>)&#123;<br>            isFull[row][col]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果与第一行连接，设置为full</span><br>       <span class="hljs-type">int</span> parentIndex=weightedQuickUnionUF.find(findIndex(row,col));<br>        <span class="hljs-comment">//如果它的parent节点被full，它也应该full</span><br>        <span class="hljs-keyword">if</span>(isFull[parentIndex/size][parentIndex%size])&#123;<br>            isFull[row][col]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//与该节点有关的节点应full尽full</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size*size;i++)&#123;<br>            <span class="hljs-keyword">if</span>(weightedQuickUnionUF.connected(i,findIndex(row,col))&amp;&amp;i!=findIndex(row,col)&amp;&amp; isFull[row][col])&#123;<br>                isFull[i/size][i%size]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// is the site (row, col) open?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||row&gt;=size||col&lt;<span class="hljs-number">0</span>||col&gt;=size)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IndexOutOfBoundsException(<span class="hljs-string">&quot;row and col must between 0 and N-1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> isOpen[row][col];<br>    &#125;<br>    <span class="hljs-comment">// is the site (row, col) full?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||row&gt;=size||col&lt;<span class="hljs-number">0</span>||col&gt;=size)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IndexOutOfBoundsException(<span class="hljs-string">&quot;row and col must between 0 and N-1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> isFull[row][col];<br>    &#125;<br>    <span class="hljs-comment">// number of open sites</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfOpenSites</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> numOfOpen;<br>    &#125;<br>    <span class="hljs-comment">// does the system percolate?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">percolates</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">if</span>(isFull[size-<span class="hljs-number">1</span>][i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用提供的图形化工具，测试：</p><p>input20.txt:</p><img src="/2022/09/29/cs61b/HW2-Percolation/image-20220929192400380.png" class title="image-20220929192400380"><p>会遇到一个问题，WeightedQuickUnionUF是根据大小合并的，当空的方块的大小大于有水的方块的大小，最终合并会以空的方块为Father节点，导致“水”无法流下</p><p>所以需要改变一些</p><p>最后测试（input50.txt）</p><img src="/2022/09/29/cs61b/HW2-Percolation/image-20220929204527307.png" class title="image-20220929204527307"><h1 id="PercolationStats-java"><a href="#PercolationStats-java" class="headerlink" title="PercolationStats.java"></a>PercolationStats.java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PercolationStats</span> &#123;<br>    <span class="hljs-keyword">private</span> Percolation percolation;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x[];<br>    <span class="hljs-comment">// perform T independent experiments on an N-by-N grid</span><br>    <span class="hljs-comment">//创建T个独立的Percolation平台，大小为N*N</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PercolationStats</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> T, PercolationFactory pf)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(N&lt;=<span class="hljs-number">0</span>||T&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IllegalArgumentException(<span class="hljs-string">&quot;T&lt;=0 or N&lt;=0&quot;</span>);<br>        &#125;<br>        x=<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[T];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;T;i++)&#123;<br>           percolation=pf.make(N);<br>           <span class="hljs-keyword">while</span>(!percolation.percolates())&#123;<br>               <span class="hljs-comment">//随机得到横、纵坐标</span><br>               <span class="hljs-type">int</span> row=StdRandom.uniform(<span class="hljs-number">0</span>,N);<br>               <span class="hljs-type">int</span> col=StdRandom.uniform(<span class="hljs-number">0</span>,N);<br>               percolation.open(row,col);<br>           &#125;<br>           <span class="hljs-comment">//当系统被渗透后，统计数据</span><br>           x[i]=<span class="hljs-number">1.0</span>*percolation.numberOfOpenSites()/(N*N);<br>       &#125;<br><br>    &#125;<br>    <span class="hljs-comment">// sample mean of percolation threshold</span><br>    <span class="hljs-comment">//计算样本均值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">mean</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> StdStats.mean(x);<br>    &#125;<br>    <span class="hljs-comment">// sample standard deviation of percolation threshold</span><br>    <span class="hljs-comment">//计算样本标准差</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">stddev</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> StdStats.stddev(x);<br>    &#125;<br>    <span class="hljs-comment">// low endpoint of 95% confidence interval</span><br>    <span class="hljs-comment">//计算置信区间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">confidenceLow</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> mean()-(<span class="hljs-number">1.96</span>*stddev()/Math.sqrt(x.length));<br>    &#125;<br>    <span class="hljs-comment">// high endpoint of 95% confidence interval</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">confidenceHigh</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> mean()+(<span class="hljs-number">1.96</span>*stddev()/Math.sqrt(x.length));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/29/cs61b/HW2-Percolation/image-20220929225145613.png" class title="image-20220929225145613"><p>没办法了，体现一个方法吧，随机输入文件某些文件输出错误</p><p>另一种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Percolation</span> &#123;<br>    <span class="hljs-keyword">private</span> WeightedQuickUnionUF weightedQuickUnionUF;<span class="hljs-comment">//不相交集</span><br>    <span class="hljs-keyword">private</span> WeightedQuickUnionUF noBackWashUF;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] status;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">//保存N</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numOfOpen;<span class="hljs-comment">//保存开放的节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vTop;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> vButton;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Percolation</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(N&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IllegalArgumentException(<span class="hljs-string">&quot;N must &gt; 0&quot;</span>);<br>        weightedQuickUnionUF=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeightedQuickUnionUF</span>(N*N+<span class="hljs-number">2</span>);<br>        noBackWashUF=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeightedQuickUnionUF</span>(N*N+<span class="hljs-number">1</span>);<br>        status=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N*N];<br>        size=N;<br>        numOfOpen=<span class="hljs-number">0</span>;<br>        vTop=N*N;<br>        vButton=N*N+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            noBackWashUF.union(i,vTop);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col)</span>&#123;<br>        <span class="hljs-keyword">return</span> row*size+col;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||row&gt;=size||col&lt;<span class="hljs-number">0</span>||col&gt;=size)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IndexOutOfBoundsException(<span class="hljs-string">&quot;row and col must between 0 and N-1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isOpen(row,col))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> index=findIndex(row,col);<br>        status[index]=<span class="hljs-literal">true</span>;<br>        numOfOpen++;<br>        <span class="hljs-keyword">if</span>(row==<span class="hljs-number">0</span>)&#123;<br>            weightedQuickUnionUF.union(vTop,index);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(row==size-<span class="hljs-number">1</span>)&#123;<br>            weightedQuickUnionUF.union(vButton,index);<br>        &#125;<br>       <span class="hljs-type">int</span> []colDir=&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> []rowDir=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> newRow=row+rowDir[i];<br>            <span class="hljs-type">int</span> newCol=col+colDir[i];<br>            <span class="hljs-keyword">if</span>(newRow&lt;<span class="hljs-number">0</span>||newRow&gt;=size||newCol&lt;<span class="hljs-number">0</span>||newCol&gt;=size)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> newIndex=findIndex(newRow,newCol);<br>            <span class="hljs-keyword">if</span>(isOpen(newRow,newCol))&#123;<br>                weightedQuickUnionUF.union(newIndex,index);<br>                noBackWashUF.union(newIndex,index);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">// is the site (row, col) open?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||row&gt;=size||col&lt;<span class="hljs-number">0</span>||col&gt;=size)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IndexOutOfBoundsException(<span class="hljs-string">&quot;row and col must between 0 and N-1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> status[findIndex(row,col)];<br>    &#125;<br>    <span class="hljs-comment">// is the site (row, col) full?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span>  &#123;<br>        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||row&gt;=size||col&lt;<span class="hljs-number">0</span>||col&gt;=size)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IndexOutOfBoundsException(<span class="hljs-string">&quot;row and col must between 0 and N-1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isOpen(row,col))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> noBackWashUF.connected(findIndex(row,col),vTop);<br>    &#125;<br>    <span class="hljs-comment">// number of open sites</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfOpenSites</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> numOfOpen;<br>    &#125;<br>    <span class="hljs-comment">// does the system percolate?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">percolates</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> weightedQuickUnionUF.connected(vButton,vTop);<br>    &#125;<br><br>   <br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/29/cs61b/HW2-Percolation/image-20220929233837006.png" class title="image-20220929233837006">]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>存储系统1</title>
    <link href="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/"/>
    <url>/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/</url>
    
    <content type="html"><![CDATA[<h1 id="存储器的分类与性能评价"><a href="#存储器的分类与性能评价" class="headerlink" title="存储器的分类与性能评价"></a>存储器的分类与性能评价</h1><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><p><strong>第一种分类方式</strong>：</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929000624196.png" alt="image-20220929000624196"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929000636712.png" alt="image-20220929000636712"></p><p>所有半导体存储器都是<strong>随机访问存储器</strong></p><p>所有磁表面存储器和光盘存储器都是<strong>非易失性存储器</strong></p><p><strong>第二种分类方式</strong>：</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929000729392.png" alt="image-20220929000729392"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929000818546.png" alt="image-20220929000818546"></p><p>直接访问：首先直接指出该存储器中的某个小区域（磁道）</p><p>串行访问：然后再顺序寻访，直至找到最终位置（扇区）</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929000909198.png" alt="image-20220929000909198"></p><h2 id="存储器的性能评价"><a href="#存储器的性能评价" class="headerlink" title="存储器的性能评价"></a>存储器的性能评价</h2><ul><li><p><strong>容量</strong>：存储二进制信息的数量</p><p>一个存储系统通常有若干哥存储芯片组成，存储芯片的规格表示为：</p><p><strong>存储单元数目×存储字长</strong></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929001125721.png" alt="image-20220929001125721"></p></li><li><p><strong>速度</strong>：</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929001307798.png" alt="image-20220929001307798"></p><ol><li><p><strong>存取时间</strong>Ta：从CPU给出有效地址启动依次存取操作到该操作完成所需的时间</p><p>也就是：从读/写存储器开始到存储器发出完成信号的时间</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929001425384.png" alt="image-20220929001425384"></p></li><li><p><strong>存取周期</strong>Tc：指连续两次存储器操作之间的最小时间间隔</p><p>也就是：指从一个读/写存储器操作开始到下一个存储器操作能够开始的最小时间间隔</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929001640522.png" alt="image-20220929001640522"></p></li><li><p><strong>存储器带宽</strong>：每秒传送的二进制位数</p><p>也就是：单位时间里存储器所存取的信息量</p></li></ol></li><li><p>成本：</p><p>存储系统总的拥有成本：构成整个计算机存储系统的所有存储器件及相关设备的购买成本</p><p>每存储位的成本：存储芯片的价格除以存储芯片的容量(位)</p></li><li><p>功耗：每个存储元（一个二进制存储位所对应的存储电路）消耗功率的大小</p></li><li><p>可靠性：对电磁场及温度变化等的抗干扰力。平均故障间隔时间</p></li></ul><h1 id="存储器访问的局部性原理与层次结构存储系统"><a href="#存储器访问的局部性原理与层次结构存储系统" class="headerlink" title="存储器访问的局部性原理与层次结构存储系统"></a>存储器访问的局部性原理与层次结构存储系统</h1><h2 id="存储器访问的局部性原理"><a href="#存储器访问的局部性原理" class="headerlink" title="存储器访问的局部性原理"></a>存储器访问的局部性原理</h2><p>经过对处理器访问主存储器情况的统计发现，无论是取指令还是存取数据，  <strong>处理器访问的存储单元趋向于聚集在一个相对较小的连续存储单元区域内。</strong>这种现象称为存储器访问的<strong>局部性原理</strong></p><p><strong>时间局部性</strong>：在一段较短的时间间隔内，CPU所访问的程序在内存中的地址往往集中在内存某一个地址范围内</p><p><strong>空间局部性</strong>：数据的这种分布不如指令明显，但对数组的存储和访问及工作单元的选择都以使存储器地址相对集中</p><p>把最近频繁访问的一小部分信息放在速度快、容量小的存储器中；而信息的全部放在速度慢、容量大的存储器</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929081248353.png" alt="image-20220929081248353"></p><p>计算机存储系统的层次结构中，最重要的两个层次：</p><ul><li>高速缓冲缓存器的“Cache-主存”层次</li><li>基于虚拟存储器的“主存-辅存”层次</li></ul><h2 id="层次结构存储系统"><a href="#层次结构存储系统" class="headerlink" title="层次结构存储系统"></a>层次结构存储系统</h2><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929081443203.png" alt="image-20220929081443203"></p><p>若要访问的信息在高一级存储器中找到，则称为<strong>命中</strong>，否则成为不命中或失效</p><p><strong>命中率</strong>是对层次结构存储系统中的某一级存储器来说，要访问的数据正在这一级中的比率</p><p>设第1级和第2级存储器分别用<strong>M</strong>1<strong>和M</strong>2表示。设执行一组有代表性的程序后，测得对M1和<strong>M</strong>2访问的次数分别为R<strong>1</strong>和<strong>R</strong>2<strong>，则</strong>M1的命中率H为 $\frac{R_1}{R_1+R_2}$</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929082237405.png" alt="image-20220929082237405"></p><h1 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h1><ul><li><p>随机访问半导体存储器（RAM）：可读、可写</p><p>根据存储原理</p><ul><li>静态RAM：利用MOS管触发器记忆特性来表示信息0、1</li><li>动态RAM：利用栅极电容上的电荷表示信息0、1</li></ul></li><li><p>只读半导体存储器（ROM）：不能写入新的内容</p></li></ul><p>半导体存储器它们都是随机访问型的</p><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><p>分类：<img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929083013689.png" alt="image-20220929083013689"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929083528415.png" alt="image-20220929083528415"></p><p>存储元（电路）：能够存储一位二进制位的基本电路</p><p>字节：8个存储元电路串联而成</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929083709025.png" alt="image-20220929083709025"></p><p><strong>静态</strong>：指的是内存里面的数据可以常驻其中而不需要进行随时进行存取。每6颗电子管组成一个位存储元。<strong>没有电容器</strong>，<strong>不断充电</strong>即可正常运作，因此它可以比一般的动态随即处理内存处理速度更快更稳定，往往用作<strong>高速缓存</strong></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929084044064.png" alt="image-20220929084044064"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929084050194.png" alt="image-20220929084050194"></p><p><strong>存储单元</strong>：若干个存储元组成一个信息字</p><p><strong>存储单元阵列</strong>：大量的存储单元按行、分列排列起来</p><p><strong>存储芯片</strong>：存储单元阵列+读/写控制电路+地址译码电路+控制电路</p><p>对存储器的访问是针对<strong>一个特定的存储单元</strong>进行的，而这个存储单元的选择、确定是通过<strong>对输入的地址进行译码</strong>来实现的</p><p>半导体存储器的地址译码方式：单译码、双译码</p><h4 id="单译码（线选法）"><a href="#单译码（线选法）" class="headerlink" title="单译码（线选法）"></a>单译码（线选法）</h4><p>只用<strong>一个地址译码器电路</strong>来将地址信号变换为选中信号，译码器输出的每一根线可选中存储单元的各位，这种选中信号称为字选择信号</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929084853991.png" alt="image-20220929084853991"></p><p>MOS管-&gt;触发器电路-&gt;SRAM存储元电路-&gt;存储单元-&gt;存储矩阵-&gt;芯片-&gt;内存条</p><h4 id="双译码（重合法）"><a href="#双译码（重合法）" class="headerlink" title="双译码（重合法）"></a>双译码（重合法）</h4><p>使用两个译码电路（X译码器和Y译码器）分别产生行选择信号和列选择信号，行选择信号和列选择信号同时有效的存储单元被选中的存储单元</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929090422007.png" alt="image-20220929090422007"></p><p>无论什么译码方式，需要的地址线的根数都一样</p><h4 id="典型芯片-Intel-2114"><a href="#典型芯片-Intel-2114" class="headerlink" title="典型芯片 Intel 2114"></a>典型芯片 Intel 2114</h4><p>芯片规格：1K*4位</p><p>有1K=1024个存储单元、4个存储元电路，欲访问该存储芯片，需要10根地址线、4根数据线</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929091405644.png" alt="image-20220929091405644"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929091411642.png" alt="image-20220929091411642"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929092453660.png" alt="image-20220929092453660"></p><h4 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h4><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929093015217.png" alt="image-20220929093015217"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929093422683.png" alt="image-20220929093422683"></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929093504452.png" alt="image-20220929093504452"></p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20220929093954272.png" alt="image-20220929093954272"></p><p>SRAM不适合大体积大容量</p><p>DRAM只需要一个MOS管和一个电容就能存储0/1</p><p>DRAM靠电容存储的电荷来表示信息 -&gt;电容上的电荷会发生泄漏 -&gt;需要定时充电以维持存储内容 -&gt;需要外加<strong>刷新电路</strong></p><h4 id="刷新："><a href="#刷新：" class="headerlink" title="刷新："></a>刷新：</h4><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20221004081232488.png" alt="image-20221004081232488"></p><p><strong>刷新周期：</strong></p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20221004081311009.png" alt="image-20221004081311009"></p><p>集中刷新：</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20221004081622418.png" alt="image-20221004081622418"></p><p>分散刷新：使内存的工作周期变长</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20221004081818640.png" alt="image-20221004081818640"></p><p>异步刷新：在一个刷新间隔内，均匀进行逐行刷新</p><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20221004082230503.png" alt="image-20221004082230503"></p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>向ROM写入原始信息的过程为“编程”，“编程”方法不同，分类：</p><ul><li><p>掩膜型MROM</p><p>包含MOS管：0；不包含MOS管：1</p></li><li><p>可编程PROM</p><p>出厂数据全为0，用户可写入1，分类：</p><ul><li>熔丝烧断型：熔丝断为1；熔丝未断为0</li><li>PN节击穿型</li></ul></li><li><p>可擦除的可编程的EPROM</p></li><li><p>可用电擦除的可编程EEPROM</p></li></ul><p><img src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F1/image-20221004093039954.png" alt="image-20221004093039954"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不相交集</title>
    <link href="/2022/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/"/>
    <url>/2022/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>这个数据结构主要是想表示各个数据之间的关系，哪些是有联系的，哪些是没有联系的</p><h1 id="原始的"><a href="#原始的" class="headerlink" title="原始的"></a>原始的</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjSets</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DisJSets</span><span class="hljs-params">(<span class="hljs-type">int</span> numElements)</span>&#123;<br>s= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [numElements];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length;i++)&#123;<br>s[i]=-<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> root1,<span class="hljs-type">int</span> root2)</span>&#123;<br>s[root2]=root1;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">if</span>(s[x]&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> find(s[x]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>起初将数组所有元素置为-1，当连接两个数据是，就让被连接的s[root2]的数据变为连接的root1</p><h1 id="按高度求并"><a href="#按高度求并" class="headerlink" title="按高度求并"></a>按高度求并</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> root1,<span class="hljs-type">int</span> root2)</span>&#123;<br><span class="hljs-keyword">if</span>(s[root2]&lt;s[root1])&#123;<br>s[root1]=s[root2];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(s[root1]==s[root2])&#123;<span class="hljs-comment">//root2更深</span><br>s[root1]--;<br>&#125;<br>s[root2]=s[root1];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进后的union方法，在合并两个集合时，会先判断哪个集合高度小，将高度小的集合加入到高度大的集合中，根节点的s[i]表示的是节点的高度的负数-1.</p><p>除了按高度求并还可以按大小求并，让每个根的元素包含它的大小的负值，当union被执行时，要检查树的大小，新的大小就是老的大小的和</p><h1 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">if</span>(s[x]&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> s[x]=find(s[x]);<br>&#125;<br></code></pre></td></tr></table></figure><p>路径压缩与按大小求并完全兼容，与按高度求并不完全兼容</p><p>在查找时将所有节点的父亲都改为根节点，可以减少树的高度</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeightedQuickUnionUF</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;   <span class="hljs-comment">// parent[i] = parent of i</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] size;     <span class="hljs-comment">// size[i] = number of sites in subtree rooted at i</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;      <span class="hljs-comment">// number of components</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeightedQuickUnionUF</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>  <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>        validate(p);<br>        <span class="hljs-keyword">while</span> (p != parent[p])<br>            p = parent[p];<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validate</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> parent.length;<br>        <span class="hljs-keyword">if</span> (p &lt; <span class="hljs-number">0</span> || p &gt;= n) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;index &quot;</span> + p + <span class="hljs-string">&quot; is not between 0 and &quot;</span> + (n-<span class="hljs-number">1</span>));  <br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(p) == find(q);<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootP</span> <span class="hljs-operator">=</span> find(p);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootQ</span> <span class="hljs-operator">=</span> find(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// make smaller root point to larger one</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &lt; size[rootQ]) &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125;<br>        count--;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.malchinee.top/2022/09/29/HW2-Percolation/">应用</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HW1-GuitarString</title>
    <link href="/2022/09/25/cs61b/HW1-GuitarString/"/>
    <url>/2022/09/25/cs61b/HW1-GuitarString/</url>
    
    <content type="html"><![CDATA[<h1 id="BoundedQueue"><a href="#BoundedQueue" class="headerlink" title="BoundedQueue"></a>BoundedQueue</h1><p>是一个单向的最简单的队列的接口，只需要实现先进先出的即可，另外还需要实现一个迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> synthesizer;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BoundedQueue</span> &lt;T&gt;  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span>;<span class="hljs-comment">//返回队列大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">fillCount</span><span class="hljs-params">()</span>;<span class="hljs-comment">//返回队列有多少个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(T x)</span>;<span class="hljs-comment">//将x添加到队尾</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span>;<span class="hljs-comment">//将元素从队列头删除</span><br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<span class="hljs-comment">//返回队列头但是不删除</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> fillCount()==<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span>  capacity()==fillCount();<br>    &#125;<br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="AbstractBoundedQueue"><a href="#AbstractBoundedQueue" class="headerlink" title="AbstractBoundedQueue"></a>AbstractBoundedQueue</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> synthesizer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBoundedQueue</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BoundedQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> fillCount;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fillCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> fillCount;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ArrayRingBuffer"><a href="#ArrayRingBuffer" class="headerlink" title="ArrayRingBuffer"></a>ArrayRingBuffer</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make sure to make this class a part of the synthesizer package</span><br> <span class="hljs-keyword">package</span> synthesizer;<br><span class="hljs-keyword">import</span> org.hamcrest.internal.ArrayIterator;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> Make sure to make this class and all of its methods public</span><br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> Make sure to make this class extend AbstractBoundedQueue&lt;t&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayRingBuffer</span>&lt;T&gt;  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">AbstractBoundedQueue</span>&lt;T&gt;&#123;<br>    <span class="hljs-comment">/* Index for the next dequeue or peek. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> first;            <span class="hljs-comment">// index for the next dequeue or peek</span><br>    <span class="hljs-comment">/* Index for the next enqueue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> last;<br>    <span class="hljs-comment">/* Array for storing the buffer data. */</span><br>    <span class="hljs-keyword">private</span> T[] rb;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create a new ArrayRingBuffer with the given capacity.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayRingBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Create new array with capacity elements.</span><br>        <span class="hljs-comment">//       first, last, and fillCount should all be set to 0.</span><br>        <span class="hljs-comment">//       this.capacity should be set appropriately. Note that the local variable</span><br>        <span class="hljs-comment">//       here shadows the field we inherit from AbstractBoundedQueue, so</span><br>        <span class="hljs-comment">//       you&#x27;ll need to use this.capacity to set the capacity.</span><br>        rb=(T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>        first=<span class="hljs-number">0</span>;<br>        last=<span class="hljs-number">0</span>;<br>        fillCount=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity=capacity;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rb.length;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fillCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> fillCount;<br>    &#125;;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">plusOne</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">return</span> (index+<span class="hljs-number">1</span>)%rb.length;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adds x to the end of the ring buffer. If there is no room, then</span><br><span class="hljs-comment">     * throw new RuntimeException(&quot;Ring buffer overflow&quot;). Exceptions</span><br><span class="hljs-comment">     * covered Monday.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(T x)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Enqueue the item. Don&#x27;t forget to increase fillCount and update last.</span><br>        <span class="hljs-keyword">if</span>(capacity()==fillCount())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列满，不能添加&quot;</span>);<br>        &#125;<br>        rb[last]=x;<br>        fillCount++;<br>        last=plusOne(last);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Dequeue oldest item in the ring buffer. If the buffer is empty, then</span><br><span class="hljs-comment">     * throw new RuntimeException(&quot;Ring buffer underflow&quot;). Exceptions</span><br><span class="hljs-comment">     * covered Monday.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Dequeue the first item. Don&#x27;t forget to decrease fillCount and update</span><br>        <span class="hljs-keyword">if</span>(fillCount==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，无法删除&quot;</span>);<br>        &#125;<br>        T val=rb[first];<br>        rb[first]=<span class="hljs-literal">null</span>;<br>        fillCount--;<br>        first=plusOne(first);<br>            <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Return oldest item, but don&#x27;t remove it.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the first item. None of your instance variables should change.</span><br>        <span class="hljs-keyword">if</span>(fillCount==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，无元素&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rb[first];<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> f=first;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> count&lt;fillCount;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            T val=rb[f];<br>            f=plusOne(f);<br>            count++;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> When you get to part 5, implement the needed code to support iteration.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现迭代器时需要创建一个内部类，实现hasNext()、next()方法</p><h1 id="GuitarString"><a href="#GuitarString" class="headerlink" title="GuitarString"></a>GuitarString</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make sure to make this class a part of the synthesizer package</span><br><span class="hljs-keyword">package</span> synthesizer;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">//Make sure this class is public</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuitarString</span> &#123;<br>    <span class="hljs-comment">/** Constants. Do not change. In case you&#x27;re curious, the keyword final means</span><br><span class="hljs-comment">     * the values cannot be changed at runtime. We&#x27;ll discuss this and other topics</span><br><span class="hljs-comment">     * in lecture on Friday. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SR</span> <span class="hljs-operator">=</span> <span class="hljs-number">44100</span>;      <span class="hljs-comment">// Sampling Rate</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">DECAY</span> <span class="hljs-operator">=</span> <span class="hljs-number">.996</span>; <span class="hljs-comment">// energy decay factor</span><br><br>    <span class="hljs-comment">/* Buffer for storing sound data. */</span><br>    <span class="hljs-keyword">private</span> BoundedQueue&lt;Double&gt; buffer;<br><br>    <span class="hljs-comment">/* Create a guitar string of the given frequency.  */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GuitarString</span><span class="hljs-params">(<span class="hljs-type">double</span> frequency)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Create a buffer with capacity = SR / frequency. You&#x27;ll need to</span><br>        <span class="hljs-comment">//       cast the result of this divsion operation into an int. For better</span><br>        <span class="hljs-comment">//       accuracy, use the Math.round() function before casting.</span><br>        <span class="hljs-comment">//       Your buffer should be initially filled with zeros.</span><br><br>        buffer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayRingBuffer</span>&lt;Double&gt;((<span class="hljs-type">int</span>)(Math.round(SR/frequency)));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-type">int</span>)Math.round(SR/frequency);i++)&#123;<br>            buffer.enqueue(<span class="hljs-number">0.0</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/* Pluck the guitar string by replacing the buffer with white noise. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pluck</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Dequeue everything in the buffer, and replace it with random numbers</span><br>        <span class="hljs-comment">//       between -0.5 and 0.5. You can get such a number by using:</span><br>        <span class="hljs-comment">//       double r = Math.random() - 0.5;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//       Make sure that your random numbers are different from each other.</span><br>        <span class="hljs-type">double</span> number;<br>        Set&lt;Double&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(set.size()&lt;buffer.fillCount())&#123;<br>           number=Math.random()-<span class="hljs-number">0.5</span>;<br>           <span class="hljs-keyword">if</span>(!set.contains(number))&#123;<br>               set.add(number);<br>           &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;buffer.fillCount();i++)&#123;<br>            buffer.dequeue();<br>            buffer.enqueue(set.iterator().next());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Advance the simulation one time step by performing one iteration of</span><br><span class="hljs-comment">     * the Karplus-Strong algorithm.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tic</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Dequeue the front sample and enqueue a new sample that is</span><br>        <span class="hljs-comment">//       the average of the two multiplied by the DECAY factor.</span><br>        <span class="hljs-comment">//       Do not call StdAudio.play().</span><br>       <span class="hljs-type">double</span> first=buffer.dequeue();<br>       <span class="hljs-type">double</span> second=buffer.peek();<br>       buffer.enqueue(<span class="hljs-number">0.5d</span>*(first+second)*DECAY);<br>    &#125;<br><br>    <span class="hljs-comment">/* Return the double at the front of the buffer. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the correct thing.</span><br>        <span class="hljs-keyword">return</span> buffer.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><img src="/2022/09/25/cs61b/HW1-GuitarString/image-20220925153745315.png" class title="image-20220925153745315"></strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>proj1A-dataStructers</title>
    <link href="/2022/09/21/cs61b/proj1A-dataStructers/"/>
    <url>/2022/09/21/cs61b/proj1A-dataStructers/</url>
    
    <content type="html"><![CDATA[<p>project 1A编写两个类实现双端队列，一个用链表，一个用循环数组</p><h1 id="编写LinkedListDeque-java"><a href="#编写LinkedListDeque-java" class="headerlink" title="编写LinkedListDeque.java"></a>编写LinkedListDeque.java</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListDeque</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">public</span> T val;<br>        <span class="hljs-keyword">public</span> Node prev;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val=item;<br>            prev=<span class="hljs-literal">null</span>;<br>            next=<span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Node first;<span class="hljs-comment">//双端队列的第一个元素</span><br>    <span class="hljs-keyword">private</span> Node last;<span class="hljs-comment">//双端队列的最后一个元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">//size方法要用恒定时间，创建成员变量</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造器，创建一个空的链表的双端队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedListDeque</span><span class="hljs-params">()</span>&#123;<br>        first=<span class="hljs-literal">null</span>;<br>        last=<span class="hljs-literal">null</span>;<br>        size=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在双端队列得前面添加一个类型的项目</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(T item)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item);<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">this</span>.first=newNode;<br>            <span class="hljs-built_in">this</span>.last=newNode;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">this</span>.first.prev=newNode;<br>            newNode.next=<span class="hljs-built_in">this</span>.first;<br>            <span class="hljs-built_in">this</span>.first=newNode;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在双端队列的后面添加一个类型的项目</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(T item)</span>&#123;<br>        Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item);<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">this</span>.first=newNode;<br>            <span class="hljs-built_in">this</span>.last=newNode;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">this</span>.last.next=newNode;<br>            newNode.prev=last;<br>            <span class="hljs-built_in">this</span>.last=newNode;<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果deque为空，则返回true，否则返回false</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回双端队列中的项目数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从头到尾打印双端队列中的项目，用空格分割</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDeque</span><span class="hljs-params">()</span>&#123;<br>        Node temp=<span class="hljs-built_in">this</span>.first;<br>        <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">null</span>)&#123;<br>            System.out.print(temp.val+<span class="hljs-string">&quot; &quot;</span>);<br>            temp=temp.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除并返回双端队列前面的项目，如果不存在这样的项目，则返回null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">1</span>)&#123;<br>            T val=first.val;<br>            first=<span class="hljs-literal">null</span>;<br>            last=<span class="hljs-literal">null</span>;<br>            size--;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        T val=first.val;<br>        <span class="hljs-comment">//头节点的下一个的前驱为null</span><br>        first.next.prev=<span class="hljs-literal">null</span>;<br>        first=first.next;<br>        size--;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除并返回双端队列后面的项目，如果不存在这样的项目，则返回null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size==<span class="hljs-number">1</span>)&#123;<br>            T val=last.val;<br>            first=<span class="hljs-literal">null</span>;<br>            last=<span class="hljs-literal">null</span>;<br>            size--;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        T val=last.val;<br>        last.prev.next=<span class="hljs-literal">null</span>;<br>        last=last.prev;<br>        size--;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取给定索引处的项目，0是第一个，1是下一个，依次类推，如果不存在这样的项目，返回null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>       <span class="hljs-keyword">if</span>(index&gt;=size||size&lt;<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>        Node temp=first;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;index;i++)&#123;<br>           temp=temp.next;<br>       &#125;<br>        <span class="hljs-keyword">return</span> temp.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getRecursive</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(size&lt;<span class="hljs-number">0</span>||index&gt;=size)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> recursive(<span class="hljs-number">0</span>,index,<span class="hljs-built_in">this</span>.first);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">recursive</span><span class="hljs-params">(<span class="hljs-type">int</span> temp,<span class="hljs-type">int</span> index,Node curr)</span>&#123;<br>        <span class="hljs-keyword">if</span>(temp==index)&#123;<br>            <span class="hljs-keyword">return</span> curr.val;<br>        &#125;<br>     <span class="hljs-keyword">return</span> recursive(temp+<span class="hljs-number">1</span>,index,curr.next);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在LinkedListDequeTest.java中运行测试：</p><img src="/2022/09/21/cs61b/proj1A-dataStructers/image-20220921215027140.png" class title="image-20220921215027140"><h1 id="编写ArrayDeque-java"><a href="#编写ArrayDeque-java" class="headerlink" title="编写ArrayDeque.java"></a>编写ArrayDeque.java</h1><p>循环链表要求适时对数组的长度做出改变，使用率至少为25%，当数组内的数据个数过多时，要对数组扩容；当删除了大部分数据时，要对数组缩小。</p><p>成员变量：</p><p>front：指的是数据所在的第一个位置的前一个</p><p>back：指的是数据所在的最后一个位置的后一个</p><p>front和back都没有指向有数据的位置</p><img src="/2022/09/21/cs61b/proj1A-dataStructers/image-20220921220002934.png" class title="image-20220921220002934"><p>取余运算：</p><ul><li>结果的符号：结果的符号与被除数的符号相同</li><li>X%y中如果x&lt;y则结果为X</li><li>0%X结果为0</li><li>X%0错误</li></ul><p>首先需要用到Math包中的方法：floorMod(x,y)取模</p><ul><li>与y的符号相同</li><li>x&gt;y：结果的绝对值与%运算相同</li><li>x&lt;y：符号相同：结果的绝对值为y-x；符号不同，结果的绝对值与%运算相同</li></ul><p>在碰到循环数组时，就不用担心front和back的符号问题，比如在添加第一个数据使用addFirst方法时，初始front为0，添加一个应该索引为7，此时Math.floorMod(-1,8)结果是7正好符合</p><p>先做出基本的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDeque</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T data[];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>  front;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> back;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//初始大小为8</span><br>        data=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-comment">//front和back都指向addFirst和addLast的位置</span><br>        front=<span class="hljs-number">0</span>;<br>        back=<span class="hljs-number">1</span>;<br>        size=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(T item)</span>&#123;<br>        data[front]=item;<br>        size++;<br>        <span class="hljs-comment">//将front&quot;前移&quot;</span><br>        front=Math.floorMod(front-<span class="hljs-number">1</span>,data.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(T item)</span>&#123;<br>       data[back]=item;<br>       size++;<br>       <span class="hljs-comment">//将back&quot;后移&quot;</span><br>       back=Math.floorMod(back+<span class="hljs-number">1</span>,data.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> data[Math.floorMod(front+<span class="hljs-number">1</span>, data.length)];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> data[Math.floorMod(back-<span class="hljs-number">1</span>, data.length)];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDeque</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Math.floorMod(front+<span class="hljs-number">1</span>, data.length);i!=back;i=Math.floorMod(i+<span class="hljs-number">1</span>, data.length))&#123;<br>            System.out.print(data[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       T val=data[Math.floorMod(front+<span class="hljs-number">1</span>, data.length)];<br>       front=Math.floorMod(front+<span class="hljs-number">1</span>,data.length);<br>       data[front]=<span class="hljs-literal">null</span>;<br>       size--;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        T  val=data[Math.floorMod(back-<span class="hljs-number">1</span>, data.length)];<br>        back=Math.floorMod(back-<span class="hljs-number">1</span>, data.length);<br>        size--;<br>        data[back]=<span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>||isEmpty()||index&gt;=size)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        index=Math.floorMod(Math.floorMod(front+<span class="hljs-number">1</span>, data.length)+index, data.length);<br>      <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后添加resize()方法，在每次增加和删除时调用resize方法</p><p>扩容或者缩小的思路是，先用tempArr存储目前的data，然后记录此时有数据的头和尾，分别保存在begin和end中，然后重置front和back，遍历tempArr，将tempArr中的数据存放到data中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(size== data.length)&#123;<br>        expand();<br>    &#125;<br>    <span class="hljs-keyword">if</span>((size&lt;data.length*<span class="hljs-number">0.25</span>)&amp;&amp;data.length&gt;<span class="hljs-number">8</span>)&#123;<br>        reduce();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">()</span> &#123;<br>    resizeHelper(data.length/<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">()</span> &#123;<br>    resizeHelper(data.length*<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resizeHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> newLength)</span>&#123;<br>    <span class="hljs-comment">//记录此时的数组</span><br>    T [] tempArr=data;<br>    <span class="hljs-comment">//旧数组的第一个有数据的位置</span><br>    <span class="hljs-type">int</span> begin=Math.floorMod(front+<span class="hljs-number">1</span>, data.length);<br>    <span class="hljs-comment">//旧数组的最后一个有数据的位置</span><br>    <span class="hljs-type">int</span> end=Math.floorMod(back-<span class="hljs-number">1</span>, data.length);<br>    <span class="hljs-comment">//扩容数组</span><br>    data= (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newLength];<br><br>    <span class="hljs-comment">//重新设置新数组的front和back</span><br>    front=<span class="hljs-number">0</span>;<br>    back=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//从旧数组的第一个有数据的位置开始向后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i!=end;i=Math.floorMod(i+<span class="hljs-number">1</span>, tempArr.length))&#123;<br>        data[back]=tempArr[i];<br>        back=Math.floorMod(back+<span class="hljs-number">1</span>,data.length);<br>    &#125;<br>    <span class="hljs-comment">//但是end也是存储着数据的地方</span><br>    data[back]=tempArr[end];<br>    back=Math.floorMod(back+<span class="hljs-number">1</span>, data.length);<br>&#125;<br></code></pre></td></tr></table></figure><p>提交得：</p><img src="/2022/09/21/cs61b/proj1A-dataStructers/image-20220922192736794.png" class title="image-20220922192736794"><h1 id="Project-1B"><a href="#Project-1B" class="headerlink" title="Project 1B"></a>Project 1B</h1><p>主要是编写测试类，用1A的一些类完成一些工作，难度不大</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lab3-Junit单元测试</title>
    <link href="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="测试算术"><a href="#测试算术" class="headerlink" title="测试算术"></a>测试算术</h1><p>运行ArithmeticTest</p><img src="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/image-20220921093817237.png" class title="image-20220921093817237"><img src="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/image-20220921093937213.png" class title="image-20220921093937213"><p>Arithmetic.java中的sum编写错误，改过来就行</p><h1 id="测试IntList"><a href="#测试IntList" class="headerlink" title="测试IntList"></a>测试IntList</h1><p>把在lab2中写的IntList放到lab3中的IntList包中</p><p>先在IntListTest.java中编写一个测试反转表reverse的方法，此时先不需要创建真的reverse的方法，可以返回null，目的就是体会编写测试方法的过程</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">testReverse</span><span class="hljs-params">()</span>&#123;<br>       IntList A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntList</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntList</span>(<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntList</span>(<span class="hljs-number">3</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntList</span>(<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>))));<br>      IntList B=IntList.reverse(A);<br><br>       <span class="hljs-keyword">while</span>(A.rest!=<span class="hljs-literal">null</span>)&#123;<br>           assertNotEquals(A.first,B.first);<br>           A=A.rest;<br>           B=B.rest;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>然后在IntList.java中编写reverse方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntList <span class="hljs-title function_">reverse</span><span class="hljs-params">(IntList A)</span> &#123;<br>       IntList pre=<span class="hljs-literal">null</span>;<br>       IntList curr=A;<br>       <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>           IntList temp=curr.rest;<br>           curr.rest=pre;<br>           pre=curr;<br>           curr=temp;<br>       &#125;<br>       <span class="hljs-keyword">return</span> pre;<br>   &#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/image-20220921095424099.png" class title="image-20220921095424099"><h1 id="Debugging之谜"><a href="#Debugging之谜" class="headerlink" title="Debugging之谜"></a>Debugging之谜</h1><p>测试出问题的代码在Filk.java中还是在HorribleSteve.java中</p><img src="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/image-20220921100839824.png" class title="image-20220921100839824"><p>测试当a，b都为128时两者是否相等</p><p>编写flikTest.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFile</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">int</span> a=<span class="hljs-number">128</span>;<br>       <span class="hljs-type">int</span> b=<span class="hljs-number">128</span>;<br>       assertEquals(<span class="hljs-literal">true</span>,Flik.isSameNumber(a,b));<br>       a=-<span class="hljs-number">10</span>;b=-<span class="hljs-number">10</span>;<br>       assertEquals(<span class="hljs-literal">true</span>,Flik.isSameNumber(a,b));<br>       a=<span class="hljs-number">10</span>;<br>       assertEquals(<span class="hljs-literal">false</span>,Flik.isSameNumber(a,b));<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>测试后：<img src="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/image-20220921100924748.png" class title="image-20220921100924748"></p><p>说明问题在Flik.java中</p><p>实际上问题是java的自动装箱机制造成的，0~127将int自动装箱成Integer类型，是一个对象（可以编写程序打印它们的地址得到），但是从128开始即使是相同的int基本类型装箱成Integer类型，由于是不同的类型，装箱成不同的对象，用==比较自然得到false，应该用equals</p><img src="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/image-20220921101405833.png" class title="image-20220921101405833"><p>测试得：<img src="/2022/09/21/cs61b/lab3-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/image-20220921101420804.png" class title="image-20220921101420804"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>proj0-模拟宇宙</title>
    <link href="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/"/>
    <url>/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/</url>
    
    <content type="html"><![CDATA[<p>project0项目是构建一个宇宙模型，没有什么数据结构使用，主要体现一些java语法，文档中给出了大致框架，只需要编写行星类Planet和NBody类，编写一些成员函数即可</p><p>文件结构：给出的examples包是例子，里面可以运动demo，要实现的类在proj0目录下</p><p>Planet类：</p><p>函数用到物理知识</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Planet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> xxPos;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> yyPos;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> xxVel;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> yyVel;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> mass;<br>    <span class="hljs-keyword">public</span> String imgFileName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Planet</span><span class="hljs-params">(<span class="hljs-type">double</span> xP,<span class="hljs-type">double</span> yP,<span class="hljs-type">double</span> xV,<span class="hljs-type">double</span> yV,<span class="hljs-type">double</span> m,String img )</span>&#123;<br>        xxPos=xP;        <span class="hljs-comment">//当前x位置</span><br>        yyPos=yP;           <span class="hljs-comment">//当前y位置</span><br>        xxVel=xV;       <span class="hljs-comment">//在x方向上的当前速度</span><br>        yyVel=yV;       <span class="hljs-comment">//在y方向上的当前速度</span><br>        mass=m;         <span class="hljs-comment">//它的质量</span><br>        imgFileName=img;        <span class="hljs-comment">//与描绘行星图像对应的文件名</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Planet</span><span class="hljs-params">(Planet p)</span>&#123;<br>        <span class="hljs-built_in">this</span>.xxPos=p.xxPos;<br>        <span class="hljs-built_in">this</span>.yyPos=p.yyPos;<br>        <span class="hljs-built_in">this</span>.xxVel=p.xxVel;<br>        <span class="hljs-built_in">this</span>.yyVel=p.yyVel;<br>        <span class="hljs-built_in">this</span>.mass=p.mass;<br>        <span class="hljs-built_in">this</span>.imgFileName=p.imgFileName;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920195921591.png" class title="image-20220920195921591"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcDistance</span><span class="hljs-params">(Planet p)</span>&#123;<br>       <span class="hljs-type">double</span> deltX=<span class="hljs-built_in">this</span>.xxPos-p.xxPos;<br>       <span class="hljs-type">double</span> deltY=<span class="hljs-built_in">this</span>.yyPos-p.yyPos;<br>       <span class="hljs-keyword">return</span> Math.sqrt(deltX*deltX+deltY*deltY);<br> <br>   <br></code></pre></td></tr></table></figure><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920195826167.png" class title="image-20220920195826167"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcForceExertedBy</span><span class="hljs-params">(Planet p)</span>&#123;<br>      <span class="hljs-type">double</span> distance=<span class="hljs-built_in">this</span>.calcDistance(p);<br>      <span class="hljs-keyword">return</span> (<span class="hljs-number">6.67e-11</span>)*<span class="hljs-built_in">this</span>.mass*p.mass/(distance*distance);<br>  &#125;<br><br> <br></code></pre></td></tr></table></figure><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920195838119.png" class title="image-20220920195838119"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 返回两星球在X上的分力</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcForceExertedByX</span><span class="hljs-params">(Planet p)</span>&#123;<br>       <span class="hljs-type">double</span> deltX=p.xxPos-<span class="hljs-built_in">this</span>.xxPos;<br>       <span class="hljs-keyword">return</span> (deltX*<span class="hljs-built_in">this</span>.calcForceExertedBy(p))/<span class="hljs-built_in">this</span>.calcDistance(p);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 返回两星球在Y上的分力</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcForceExertedByY</span><span class="hljs-params">(Planet p)</span>&#123;<br>       <span class="hljs-type">double</span> deltY=p.yyPos-<span class="hljs-built_in">this</span>.yyPos;<br>       <span class="hljs-keyword">return</span> (deltY*<span class="hljs-built_in">this</span>.calcForceExertedBy(p))/<span class="hljs-built_in">this</span>.calcDistance(p);<br>   &#125;<br><br></code></pre></td></tr></table></figure><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920195847494.png" class title="image-20220920195847494"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 给定行星数组，返回这些行星对该行星X方向的分力</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> planets</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcNetForceExertedByX</span><span class="hljs-params">(Planet[] planets)</span>&#123;<br>        <span class="hljs-type">double</span> netForceX=<span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (Planet planet:planets)&#123;<br>            <span class="hljs-keyword">if</span>(!planet.equals(<span class="hljs-built_in">this</span>))&#123;<br>                netForceX+=<span class="hljs-built_in">this</span>.calcForceExertedByX(planet);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> netForceX;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 给定行星数组，返回这些行星对该行星Y方向的分力</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> planets</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcNetForceExertedByY</span><span class="hljs-params">(Planet[] planets)</span>&#123;<br>        <span class="hljs-type">double</span> netForceY=<span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span>(Planet planet:planets)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.equals(planet))&#123;<br>                netForceY+=<span class="hljs-built_in">this</span>.calcForceExertedByY(planet);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> netForceY;<br>    &#125;<br>   <br></code></pre></td></tr></table></figure><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920195900483.png" class title="image-20220920195900483"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">double</span> dt,<span class="hljs-type">double</span> fx,<span class="hljs-type">double</span> fy)</span>&#123;<br>      <span class="hljs-type">double</span> ax=fx/<span class="hljs-built_in">this</span>.mass;<br>      <span class="hljs-type">double</span> ay=fy/<span class="hljs-built_in">this</span>.mass;<br>      xxVel+=dt*ax;<br>      yyVel+=dt*ay;<br>      xxPos+=dt*xxVel;<br>      yyPos+=dt*yyVel;<br>   &#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920200007699.png" class title="image-20220920200007699">编写NBody类：这里用到了框架提供的In类，提供了读文件的各种方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">NBody</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">readRadius</span><span class="hljs-params">(String filename)</span>&#123;<br>        In in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">In</span>(filename);<br>        <span class="hljs-type">int</span> first=in.readInt();<br>        <span class="hljs-type">double</span> radius=in.readDouble();<br>        <span class="hljs-keyword">return</span> radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Planet[] readPlanets(String planetsTxtPath) &#123;<br>        In in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">In</span>(planetsTxtPath);<br>        <span class="hljs-type">int</span> number=in.readInt();<br>        <span class="hljs-type">double</span> radius=in.readDouble();<br>        Planet[] planets=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Planet</span>[number];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;number;i++)&#123;<br>            <span class="hljs-type">double</span> xp=in.readDouble();<br>            <span class="hljs-type">double</span> yp=in.readDouble();<br>            <span class="hljs-type">double</span> xv=in.readDouble();<br>            <span class="hljs-type">double</span> yv=in.readDouble();<br>            <span class="hljs-type">double</span> m=in.readDouble();<br>            String img=in.readString();<br>            planets[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Planet</span>(xp,yp,xv,yv,m,img);<br>        &#125;<br>        <span class="hljs-keyword">return</span> planets;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920195938845.png" class title="image-20220920195938845"><img src="/2022/09/20/cs61b/proj0-%E6%A8%A1%E6%8B%9F%E5%AE%87%E5%AE%99/image-20220920195949757.png" class title="image-20220920195949757"><h3 id="编写主函数"><a href="#编写主函数" class="headerlink" title="编写主函数"></a>编写主函数</h3><p>在NBody类中添加主函数，负责绘制图像</p><p>在输入时会在命令行参数中输入三个：T表示图像持续时间，dt表示每次更新的间隔和filename要读取的宇宙的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">double</span> T=Double.parseDouble(args[<span class="hljs-number">0</span>]);<br>       <span class="hljs-type">double</span> dt=Double.parseDouble(args[<span class="hljs-number">1</span>]);<br>       String filename=args[<span class="hljs-number">2</span>];<br>       Planet[] planets=readPlanets(filename);<br>       <span class="hljs-comment">//从文件中读取宇宙的半径</span><br>       <span class="hljs-type">double</span> radius=readRadius(filename);<br>       <span class="hljs-comment">//设置宇宙半径</span><br>       StdDraw.setScale(-radius,radius);<br><br>       <span class="hljs-comment">//预渲染</span><br>       StdDraw.enableDoubleBuffering();<br>       <span class="hljs-comment">//设置开始计数</span><br>       <span class="hljs-type">double</span> t=<span class="hljs-number">0.0</span>;<br>       <span class="hljs-keyword">while</span>(t&lt;T)&#123;<br>           Double[] xF=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>[planets.length];<br>           Double[] yF=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>[planets.length];<br>           <span class="hljs-comment">//计算每个星球的受力，分X和Y方向</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; planets.length;i++)&#123;<br>               xF[i]=planets[i].calcNetForceExertedByX(planets);<br>               yF[i]=planets[i].calcNetForceExertedByY(planets);<br>           &#125;<br><br>           <span class="hljs-comment">//更新每个星球的位置</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; planets.length;i++)&#123;<br>               planets[i].update(t,xF[i],yF[i] );<br>           &#125;<br><br>           <span class="hljs-comment">//体现在图像上</span><br>           StdDraw.picture(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;images/starfield.jpg&quot;</span>);<br>           <span class="hljs-keyword">for</span>(Planet planet:planets)&#123;<br>               planet.draw();<br>           &#125;<br>           <span class="hljs-comment">//这时再展示</span><br>           StdDraw.show();<br>           <span class="hljs-comment">//每次暂停一段时间</span><br>           StdDraw.pause(<span class="hljs-number">10</span>);<br>           t+=dt;<br>       &#125;<br><br>       StdOut.printf(<span class="hljs-string">&quot;%d\n&quot;</span>,planets.length);<br>       StdOut.printf(<span class="hljs-string">&quot;%.2e\n&quot;</span>,radius);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;planets.length;i++)&#123;<br>           StdOut.printf(<span class="hljs-string">&quot;%11.4e %11.4e %11.4e %11.4e %11.4e %12s\n&quot;</span>,<br>                   planets[i].xxPos,planets[i].yyPos,planets[i].xxVel,planets[i].yyVel,planets[i].mass,planets[i].imgFileName);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>CS61B</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>总线</title>
    <link href="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/"/>
    <url>/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h1><p>计算机使用总线结构便于增减外设，同时减少了信息传输线的条数</p><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p><p>总线上信息的传送:</p><ul><li>串行</li><li>并行</li></ul><p>总线结构的计算机举例</p><ol><li><p>单总线结构框图</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919082600169.png" class title="image-20220919082600169"><p>同一时刻只能由一对设备使用总线，严重影响CPU的效率，时间延迟比较大</p></li><li><p>面向CPU的双总线结构框图</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919082813507.png" class title="image-20220919082813507"><p>但是I/O设备与主存无信息传输，只能借助CPU，加大CPU的工作负担</p></li><li><p>以存储器为中心的双总线结构框图</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919083016272.png" class title="image-20220919083016272"></li></ol><h1 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h1><p>根据连接部件不同分类：</p><ol><li>片内总线：芯片内部的总线</li></ol><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220920080331255.png" class title="image-20220920080331255"><ol><li>系统总线：计算机各部件之间的信息传输线</li></ol><ul><li><p><strong>数据总线DB</strong>：用来传输各个部件之间的<strong>数据信息</strong></p><p>双向，与机器字长、存储字长有关</p></li><li><p><strong>地址总线AB</strong>：单向、与存储地址、I/O地址有关</p><p>一组用来指出数据总线上的数据所对应的<strong>内存单元地址</strong>或<strong>I/O外设地址</strong>的总线</p><p>单向，由CPU发出；CPU可访问的<strong>存储空间大小</strong>（<strong>也叫寻址空间</strong>）为<strong>$2^n$</strong>（n为地址线的根数），寻找地址的过程为<strong>寻址过程</strong></p></li><li><p><strong>控制总线CB</strong>：各个功能部件之间相互协调工作的控制信号</p><p>有出、有入</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220920080402996.png" class title="image-20220920080402996"></li></ul><ol><li><strong>通信总线（外总线</strong>）：用于计算机系统之间或者计算机系统与其它系统之间的通信</li></ol><ul><li>串行通信总线</li><li>并行通信总线</li></ul><h1 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h1><h3 id="总线物理实现"><a href="#总线物理实现" class="headerlink" title="总线物理实现"></a>总线物理实现</h3><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919083849672.png" class title="image-20220919083849672"><p>I/O接口举例：网卡、声卡、显卡，键盘鼠标等外设受I/O接口控制</p><h3 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h3><p><strong>发送的互斥性和接受的共享性</strong></p><p>机械特性：尺寸、形状、管脚数、线和线之间的排列顺序等</p><p>电气特性：信号的<strong>传输方向</strong>和有效<strong>电平</strong>范围</p><p>功能特性：每根<strong>传输线</strong>的功能—-地址信号、数据信号、控制信号等</p><p>时间特性：信号的<strong>时序关系</strong></p><h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h3><ul><li><p>总线宽度（位宽）： <strong>数据线</strong>的根数，一次操作可传输的数据位数</p></li><li><p>工作时钟频率：控制总线中时钟信号线所提供的时钟频率</p></li><li><p>标准传输率：每秒传输的最大字节数<strong>MBps</strong></p><p>总线带宽=总线位宽X总线工作频率/8</p></li><li><p>时钟同步/异步：<strong>同步、不同步</strong></p></li><li><p>总线复用：<strong>地址线</strong>、<strong>数据线</strong>复用，可以减少总线中信号线的数量</p></li><li><p>信号线数：地址线、数据线和控制线的总和</p></li><li><p>总线控制方式：突发、自动、仲裁、逻辑、技术</p></li><li><p>其他指标：负载能力：总线上所能连接部件的最大个数</p></li></ul><h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919085301338.png" class title="image-20220919085301338"><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919085426322.png" class title="image-20220919085426322"><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><p>如上图</p><h3 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h3><ol><li><p>双总线结构</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919090333681.png" class title="image-20220919090333681"></li><li><p>三总线结构</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919090511913.png" class title="image-20220919090511913"></li><li><p>三总线结构的又一形式</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919090737580.png" class title="image-20220919090737580"><p>但是影响外部设备的工作速度</p></li><li><p>四总线结构</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919090832871.png" class title="image-20220919090832871"></li></ol><h3 id="总线结构举例"><a href="#总线结构举例" class="headerlink" title="总线结构举例"></a>总线结构举例</h3><ol><li><p>传统的微型计算机总线结构</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919091020142.png" class title="image-20220919091020142"></li><li><p>VL-BUS局部总线结构</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919091040727.png" class title="image-20220919091040727"></li><li><p>PCI总线结构</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919091133204.png" class title="image-20220919091133204"></li><li><p>多层PCI总线结构</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919091223786.png" class title="image-20220919091223786"></li></ol><h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><p>为了协调总线上各个部件堆总线的争用、避免发生总线冲突，必须有<strong>总线控制器</strong>来对总线的使用进行分配和管理</p><p>总线仲裁：当总线上多个候选的主部件同时申请使用总线时，必须有一个<strong>总线控制机构</strong>按照某种策略对申请进行裁决</p><h3 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h3><ul><li>主设备：对总线具有控制权</li><li>从设备：响应从主设备发来的总线命令</li></ul><p>方法：</p><ul><li>集中式：链式查询、计数器定时查询、独立请求方式</li><li>分布式</li></ul><h4 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h4><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919092140883.png" class title="image-20220919092140883"><p>特点：</p><ul><li>总线授权信号<strong>BG串行地</strong>从一个I/O设备传送到下一个I/O设备</li><li>优先级固定：离“总线控制部件”<strong>最近的优先级最高</strong>，<strong>最远的优先级最低</strong>。优先级通过物理上的<strong>排队电路</strong>来实现的</li><li>采用很少的几根线就能实现</li><li><strong>对电路故障很敏感</strong></li><li>若优先级高地设备频繁发出请求，则优先级低的设备可能很长时间都无法得到总线控制权</li></ul><h4 id="计数器定时查询方式"><a href="#计数器定时查询方式" class="headerlink" title="计数器定时查询方式"></a>计数器定时查询方式</h4><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919093229866.png" class title="image-20220919093229866"><p>若设备数量为n，设备地址线至少需要$Log_2^n$位宽度向上取整</p><ol><li>仲裁器接收到请求信号以后，在<strong>BS线为“0”的情况下，让计数器开始计数，计数器通过一组地址线发向各个设备</strong></li><li>每个设备接口都有一个“设备地址判别电路”，当<strong>地址线上的计数值与请求总线的设备地址相一致时，该设备将BS线设置为1</strong>，获得了总线的使用权，从而中止技术查询</li><li>从0开始，每个设备的优先级次序同“<strong>链式查询法</strong>”相同，此时优先级的顺序是固定的</li><li>若从中止点开始，则每个设备的优先级相等</li><li>可通过程序来设置计数器初值，动态来改变其优先级，可编程</li></ol><h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919093732560.png" class title="image-20220919093732560"><p>优先级在控制部件内部有一个排队器</p><p>设备有N个，需要2N条线解决</p><h3 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h3><p>解决<strong>主设备与从设备之间协调配合</strong>的关系</p><p><strong>总线传输周期</strong>：主设备和从设备之间完成一次完整、可靠的通信的时间</p><ul><li>申请分配阶段：<strong>主模块申请</strong>，总线仲裁决定</li><li>寻址阶段：主模块向从模块给出<strong>地址和命令</strong></li><li>传输阶段：主模块和从模块<strong>交换数据</strong></li><li>结束阶段：主模块<strong>撤销有关消息</strong></li></ul><p>总线通信的四种方式：</p><ul><li><p>同步通信：由<strong>定宽、定距的时标</strong>控制数据传送</p></li><li><p>异步通信：采用应答方式、没有公共时钟标准</p></li><li><p>半同步通信：同步、异步结合</p></li><li><p>分离式通信：发掘系统总线每一瞬间的潜力</p></li></ul><p>一个总线传输周期（以输入数据为例）：</p><ul><li>主模块发地址、命令 ：占用总线</li><li>从模块准备数据：不占用总线</li><li>从模块向主模块发数据：占用总线</li></ul><h4 id="同步式"><a href="#同步式" class="headerlink" title="同步式"></a>同步式</h4><p>特点：</p><ul><li><strong>强制性同步，采用同一时钟</strong>，简单易控制</li><li>对于每一个操作，每一时间都有明确的规定，显得比较死板</li><li>必须按照<strong>工作速度最慢的部件</strong>来设计时钟</li><li>当各个模块的存取时间相差较大时，会大大损失总线的工作效率</li><li>适用于<strong>总线时间较短</strong>，各模块部件存取时间比较一致的场合</li></ul><p>数据输入：</p><p>地址：平为无地址数据，分叉后为有地址数据</p><p>读命令：高电平为无效、低电平有效</p><p>数据线同理</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919095212767.png" class title="image-20220919095212767"><p>数据输出：</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919095446029.png" class title="image-20220919095446029"><p>写命令需要两个时钟周期，读命令只需要一个</p><p>应用在总线长度比较短，各个模块存取时间比较一致的情况下</p><h4 id="异步式"><a href="#异步式" class="headerlink" title="异步式"></a>异步式</h4><p>参与通信的两个部件需要感知对方操作，通过“握手”信号实现</p><ul><li>单边控制：由源部件<strong>或</strong>目的部件控制</li><li>双边控制：由源部件<strong>和</strong>目的部件控制</li></ul><p>特点：</p><ul><li>没有公共时钟</li><li>采用握手方式，请求应答方式</li><li>相互通信的设备的工作速度参差不齐</li></ul><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919100752288.png" class title="image-20220919100752288"><h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><p>同步：发送方用<strong>系统时钟前沿</strong>发信号，接收方用<strong>系统时钟后沿</strong>判断、识别</p><p>异步：允许不同速度的模块和谐工作，增加一条“等待”响应信号，$\overline{WAIT}$</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919101727665.png" class title="image-20220919101727665"><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220919101742518.png" class title="image-20220919101742518"><p>以上三种的系统总线的使用权完全由占有使用权的主模块和从模块战局，总线利用率不高</p><h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><p>在从模块准备数据的时间内，主模块让出总线的使用权</p><img src="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/image-20220922090229606.png" class title="image-20220922090229606"><p>一个总线的传输周期：</p><ul><li>子周期1：主模块申请占用总线，使用完后放弃总线的使用权</li><li>子周期2：从模块申请占用总线，将各种信息放到总线上去</li></ul><p>特点：</p><ol><li>各模块有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲</li></ol><p>以上，充分利用总线的带宽</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>datalab</title>
    <link href="/2022/09/17/CSAPP/datalab/"/>
    <url>/2022/09/17/CSAPP/datalab/</url>
    
    <content type="html"><![CDATA[<p>只需要修改bits.c文件，然后运行如下指令就可以看到得到多少分</p><figure class="highlight 1c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs 1c">make <span class="hljs-meta">&amp;&amp; ./btest</span><br></code></pre></td></tr></table></figure><p>第一个异或$\bigoplus$，不能使用|，只能用~和&amp;，使用反演率消除并运算</p><script type="math/tex; mode=display">x\bigoplus y= x\overline{y}+\overline{x}y=\overline{\overline{x\overline{y}+\overline{x}y}}=\overline{(x+\overline{y})(\overline{x}+y)}=\overline{\overline{xy}+xy}=\overline{\overline{x}\overline{y}}*\overline{xy}</script><p>第二个返回最小值，int类型有32位，应该是1后跟31个0，1左移31位即可</p><p>第三个判断是否是补码的最大值，如果是最大值</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">x</span>=01111111<br>x+<span class="hljs-attribute">1</span>=10000000<br>~<span class="hljs-attribute">x</span>=10000000<br></code></pre></td></tr></table></figure><p>可以让x+1与~x进行异或判断是否是最大值</p><p>要排除x为-1的情况，让x+1与0作异或</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">x</span>=11111111<br>x+<span class="hljs-attribute">1</span>=00000000<br>~<span class="hljs-attribute">x</span>=00000000<br></code></pre></td></tr></table></figure><p>第四个判断二进制的技术位是否都是1，偶数位不做限制。这样每四位就是1010，16进制就是A。x与1010101010这样的数作&amp;运算，再判断与101010这样的数相等就行</p><p>第五个返回x的相反数，直接~x+1</p><p>第六个判断数是否处于0x30和0x39之间，也就是0000…00110000到0000….00111001之间。对于一个x分三个部分判断：11之前的数全为0、倒数第5和第6位数为11、倒数四位数小于0xA。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
      <category>Lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-程序的机器级表示</title>
    <link href="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><p>源代码转化为可执行文件：</p><ol><li>C预处理器扩展代码。插入所有用$#include$声明指定的宏</li><li>编译器产生两个源文件的汇编代码</li><li>汇编器将汇编代码转化成二进制目标代码文件后缀.o</li><li><p>链接器将两个目标代码文件与实现库函数的代码合并，最终产生可执行文件</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1></li></ol><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915151643901.png" class title="image-20220915151643901"><p>数据传送指令有四种变种：movb（传送字节），movw（传送字），movl（传送双字），movq（传送四字）</p><h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915151838502.png" class title="image-20220915151838502"><h3 id="操作数指令符"><a href="#操作数指令符" class="headerlink" title="操作数指令符"></a>操作数指令符</h3><p>各种不同的操作数可能被分为三种类型：</p><ol><li><p>立即数：书写方式是‘$’后面用C表示法表示的整数</p></li><li><p>寄存器：16个寄存器的低位1字节，2字节，4字节或者8字节中的一个作为操作数，这些字节数分别对应于8位，16位，32位或64位</p></li><li><p>内存引用：它会根据计算出来的地址访问内存中的位置</p><p>有效地址$Imm(r_b,r_i,s)$计算为：$Imm+R[r_b]+R[r_i]*s$</p><p>分别是立即数，基址寄存器，变址寄存器，比例因子</p></li></ol><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915152843008.png" class title="image-20220915152843008"><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>最简单的形式：MOV类</p><p>表示目的操作数与源操作数的大小一致的情况</p><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915152958337.png" class title="image-20220915152958337"><p>MOV  Source Destination ，第一个操作数是源操作数，第二个操作数是目标操作数，目的操作数不能是立即数。本书是ATT格式，其他可能是inter格式的汇编代码会不一样</p><p>x86-64加一条限制：传送指令的两个操作数都不能同时指向内存位置</p><p>MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0</p><p>当立即数作为movq指令的源操作数时，只能以表示为32位补码数字形式表示，然后把这个值符号扩展得到64位的值，放到目的位置。当立即数为64位时，引入movabsq，该源操作数可以是任意的64位的立即数，但是目的操作数只能是寄存器</p><p>当源操作数的数位小于目的操作数时：</p><p>使用MOVZ类：对高位进行零扩展或者符号扩展</p><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915212856461.png" class title="image-20220915212856461"><p>缺少movzlq的原因是可以用movl指令代替</p><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915212907680.png" class title="image-20220915212907680"><p>cltq的效果总是与这条指令效果一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs x86-64">movslq %eax , %rax<br></code></pre></td></tr></table></figure><h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><p>栈指针 <strong>%rsp</strong>保存保存着栈顶元素的地址</p><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915223207358.png" class title="image-20220915223207358"><p>pushq %rbp等价于</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">subq $8,%rsp<br>movq $rbp,(%rsp)<br></code></pre></td></tr></table></figure><p>区别在于pushq指令只需要1字节存储，而上面需要8字节</p><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915223340050.png" class title="image-20220915223340050"><p>popq %rax等价于</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">mov<span class="hljs-string">q (%rsp)</span>,%rax<br>addq $8,%rsp<br></code></pre></td></tr></table></figure><h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><img src="/2022/09/15/CSAPP/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20220915225103955.png" class title="image-20220915225103955"><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>leaq指令并不是从指定的数据读取数据，而时将有效地址写入到目的数</p><p>还可以进行加法和有限的乘法运算</p><h3 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h3><p>一元操作数既是目的也是源</p><p>二元操作数的目的不能是立即数</p><h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>ALU算术逻辑单元除了执行算术和逻辑单元外，还会根据该运算的结果设置条件码寄存器</p><p>条件码寄存器</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2022/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>如果输入的值是数字：</p><p>若表的大小是10而关键字都以0为个位， Key Mod $Tablesize$ 这种哈希函数不是一个好的选择</p><p>避免上面的情况，最好的方法是保证表的大小是素数，当输入的关键字是随机整数时，散列函数不仅计算起来简单而且关键字的分配也很均匀</p><p>如果输入的值是字符串：</p><p>一种方法是把字符串的ASCLL码或Unicode码值加起来</p><h1 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现</h1><p>用链表+数组表示哈希表，哈希函数就是id mod 数组长度</p><p>设计节点Emp表示员工节点</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> Emp next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Emp</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.id=id;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Emp&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建EmpLinkedList类，表示同一个关键字下的所有Emp的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpLinkedList</span>&#123;<br>    <span class="hljs-comment">//头指针</span><br>    <span class="hljs-keyword">private</span> Emp head;<span class="hljs-comment">//默认为空</span><br><br>    <span class="hljs-comment">//添加雇员到链表</span><br>    <span class="hljs-comment">//假定添加雇员时，id是自增的，即id的分配总是从小到大，因为直接添加到最后即可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Emp emp)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            head=emp;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            Emp temp=head;<br>            <span class="hljs-keyword">while</span>(temp.next!=<span class="hljs-literal">null</span>) temp=temp.next;<br>            temp.next=emp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//遍历雇员的信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span>+(no+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;条链表为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Emp temp=head;<br>        System.out.print(<span class="hljs-string">&quot;第&quot;</span>+(no+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;条链表的信息为===》&quot;</span>);<br>        <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">null</span>)&#123;<br>            System.out.print(temp);<br>            temp=temp.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>    <span class="hljs-comment">//根据id查找雇员</span><br>    <span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">findEmpById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;链表为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Emp temp=head;<br>        <span class="hljs-type">boolean</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(temp.id==id)&#123;<br>                flag=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//这时temp就指向查找到的雇员</span><br>            &#125;<br>            temp=temp.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> temp;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;该链表为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(head.id==id&amp;&amp;head.next!=<span class="hljs-literal">null</span>)&#123;<br>            head=head.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head.id==id&amp;&amp;head.next==<span class="hljs-literal">null</span>)&#123;<br>            head=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Emp temp=head;<br><br>       <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-keyword">if</span>(temp.next==<span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(temp.next.id==id)&#123;<br>               flag=<span class="hljs-literal">true</span>;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>           temp=temp.next;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(flag)&#123;<br>           <span class="hljs-keyword">if</span>(temp.next.next==<span class="hljs-literal">null</span>)&#123;<br>               temp.next=<span class="hljs-literal">null</span>;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               temp.next=temp.next.next;<br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           System.out.println(<span class="hljs-string">&quot;未找到该id代表的节点&quot;</span>);<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>哈希表HashTab类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTab</span>&#123;<br>    <span class="hljs-keyword">private</span> EmpLinkedList[] empLinkedArray;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashTab</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>&#123;<br>        <span class="hljs-built_in">this</span>.size=size;<br>        <span class="hljs-comment">//初始化empLinkedArray</span><br>        empLinkedArray =<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpLinkedList</span>[size];<br>        <span class="hljs-comment">//这时不要忘了分别初始化每条链表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            empLinkedArray[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpLinkedList</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//添加雇员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Emp emp)</span>&#123;<br>        <span class="hljs-comment">//根据员工的id得到该员工应该添加到哪条链表</span><br>        <span class="hljs-type">int</span> empLinkedListNo=hashFun(emp.id);<br>        <span class="hljs-comment">//将employee添加到对应的链表中</span><br>        empLinkedArray[empLinkedListNo].add(emp);<br>    &#125;<br>    <span class="hljs-comment">//遍历所有的链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; empLinkedArray.length;i++)&#123;<br>            empLinkedArray[i].list(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//散列函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashFun</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-keyword">return</span> id % size;<br>    &#125;<br>    <span class="hljs-comment">//根据输入的id查找雇员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findEmpById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-type">int</span> empLinkedListNo=hashFun(id);<br>       Emp emp=empLinkedArray[empLinkedListNo].findEmpById(id);<br>       <span class="hljs-keyword">if</span>(emp!=<span class="hljs-literal">null</span>)&#123;<br>           System.out.printf(<span class="hljs-string">&quot;在第%d条链表中找到 雇员 id=%d \n&quot;</span>,empLinkedListNo+<span class="hljs-number">1</span>,emp.id);<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           System.out.println(<span class="hljs-string">&quot;未找到该雇员&quot;</span>);<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-type">int</span> empLinkedListNo=hashFun(id);<br>        empLinkedArray[empLinkedListNo].deleteById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>赫夫曼树</title>
    <link href="/2022/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2022/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>赫夫曼树用于文件压缩中</p><p>树只有在树叶上有数据。每个字符通过根节点开始，用0指示左分支，用1指示右分支而以记录路径的方法表示出来。如果字符$c_i$在深度$d_i$处并出现$f_i$次，那么这种编码的值就是$\sum d_if_i$</p><p>如果字符都只放在树上，那么任何比特序列都能被毫不含糊地译码。</p><p>这些字符代码地长度是否相同不要紧，关键是只要没有字符代码是别的字符代码地前缀就行，这样的一种编码就叫<strong>前缀码</strong></p><p>相反，如果一个字符放在非叶子节点上，那就不再能够保证译码没有二义性</p><h1 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h1><p>定义节点类，实现Comparable\<Node\>接口</Node\></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Node&gt;&#123;<br>    <span class="hljs-type">int</span> value;<br>    Node left;<br>    Node right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value=value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Node o)</span>&#123;<br>        <span class="hljs-comment">//表示从小到大排序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value-o.value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.left.preOrder();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.right.preOrder();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建一棵赫夫曼树，参数为一个数组，返回根节点</p><p>将数组放入List集合中，便于对数据进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">createHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr)</span> &#123;<br>        List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value));<br>        &#125;<br>        <span class="hljs-keyword">while</span> (nodes.size()&gt;<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//排序，从小到大</span><br>            Collections.sort(nodes);<br><br>            System.out.println(<span class="hljs-string">&quot;nodes：&quot;</span> + nodes);<br><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> nodes.get(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">//构建一棵新的二叉树</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(leftNode.value + rightNode.value);<br>            parent.left = leftNode;<br>            parent.right = rightNode;<br><br>            <span class="hljs-comment">//从ArrayList中删除处理过的二叉树</span><br>            nodes.remove(leftNode);<br>            nodes.remove(rightNode);<br>            nodes.add(parent);<br>        &#125;<br>        <span class="hljs-comment">//返回赫夫曼树的头</span><br>        <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉平衡查找树</title>
    <link href="/2022/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <url>/2022/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>AVL树时一种平衡二叉树。平衡二叉树的递归定义如下：</p><ol><li>左右子树的高度差小于1</li><li>每一个子树均为平衡二叉树</li></ol><p>再加上二叉搜索树的定义，就是一棵AVL树</p><p>我们只需要在二叉查找树的基础上，改变一些方法，就可以让一棵二叉查找树变成平衡二叉查找树</p><p>当添加一个节点后，如果树的一方高度过高，还需要对树进行旋转处理</p><p>定义节点类：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> value;<br>    Node left;<br>    Node right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value=value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//返回节点的高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Math.max(left==<span class="hljs-literal">null</span>?<span class="hljs-number">0</span>:left.height(),right==<span class="hljs-literal">null</span>?<span class="hljs-number">0</span>: right.height())+<span class="hljs-number">1</span>;<br>    &#125;<br>       <span class="hljs-comment">//返回左子树的高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftHeight</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left.height();<br>    &#125;<br>    <span class="hljs-comment">//返回右子树的高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rightHeight</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(right==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right.height();<br>    &#125;<br>     <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.infixOrder();<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.infixOrder();<br>        &#125;<br>    &#125;<br>     <span class="hljs-comment">//查找要删除的节点</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 希望删除的节点的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果找到返回该节点，否则返回null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.value==value) <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value&lt;<span class="hljs-built_in">this</span>.value)&#123;<span class="hljs-comment">//如果查找的值小于当前节点，则向左子树递归查找</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left==<span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.left.search(value);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果查找的值大于当前节点，则向右子树递归查找</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.right.search(value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找要删除节点的父节点</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 要查找的节点的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回要删除节点的父节点，如果没有就返回null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">searchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-comment">//如果当前节点就是要删除的节点的父节点就返回</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.left.value==value)||<br>                (<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.right.value==value))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果查找的值小于当前节点的值并且当前节点的左子节点不为空</span><br>        <span class="hljs-keyword">if</span>(value&lt;<span class="hljs-built_in">this</span>.value&amp;&amp;<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.left.searchParent(value);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value&gt;=<span class="hljs-built_in">this</span>.value&amp;&amp;<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.right.searchParent(value);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有找到父节点</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，还需要左旋和右旋的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//左旋转方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leftRotate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建新的节点，以当前根节点的值</span><br>        Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>        <span class="hljs-comment">//把新的节点的左子树设置成当前节点的左子树</span><br>        newNode.left=<span class="hljs-built_in">this</span>.left;<br>        <span class="hljs-comment">//把当前节点的右子树设置成当前节点的右子树的左子树</span><br>        newNode.right=<span class="hljs-built_in">this</span>.right.left;<br>        <span class="hljs-comment">//把当前节点的值换成右子节点的值</span><br>        <span class="hljs-built_in">this</span>.value=<span class="hljs-built_in">this</span>.right.value;<br>        <span class="hljs-comment">//把当前节点的右子树设置成右子树的右子树</span><br>        <span class="hljs-built_in">this</span>.right=<span class="hljs-built_in">this</span>.right.right;<br>        <span class="hljs-comment">//把当前节点的左子树设置成新节点</span><br>        <span class="hljs-built_in">this</span>.left=newNode;<br><br>    &#125;<br>    <span class="hljs-comment">//右旋转方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rightRotate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建新的节点，以当前根节点的值</span><br>        Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-built_in">this</span>.value);<br>        <span class="hljs-comment">//把新的节点的右子树设置为当前节点的右子树</span><br>        newNode.right=<span class="hljs-built_in">this</span>.right;<br>        <span class="hljs-comment">//把新的节点的左子树设置成当前节点的左子树的右子树</span><br>        newNode.left=<span class="hljs-built_in">this</span>.left.right;<br>        <span class="hljs-comment">//把当前的节点的值换成左子节点的值</span><br>        <span class="hljs-built_in">this</span>.value=<span class="hljs-built_in">this</span>.left.value;<br>        <span class="hljs-comment">//把当前节点的左子树设置成左子树的左子树</span><br>        <span class="hljs-built_in">this</span>.left=<span class="hljs-built_in">this</span>.left.left;<br>        <span class="hljs-comment">//把当前节点的右子树设置为新节点</span><br>        <span class="hljs-built_in">this</span>.right=newNode;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当添加一个节点后，如果发现该树不平衡，要进行左旋或者右旋。</p><p>如果左子树高度大于右子树高度，就进行右旋；反之左旋</p><p>当然，如果子树的左子树高度大于右子树高度，或者子树的右子树高度大于左子树高度，那么再怎么旋转都没用</p><p>按一种情况分析：当（左子树高度-右子树高度）&gt;1时</p><p>这种情况需要右旋。</p><p>在右旋之前，需要判断该节点的左子树的右子树高度是否大于它的左子树的右子树高度</p><p>如果大于，就需要先对该节点的左子树进行右旋（有点绕）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归的形式添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断传入节点的值，和当前子树的根节点值的对应关系</span><br>        <span class="hljs-keyword">if</span>(node.value&lt;<span class="hljs-built_in">this</span>.value)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//如果当前节点左子节点为空</span><br>                <span class="hljs-built_in">this</span>.left=node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.left.add(node);<span class="hljs-comment">//递归地向左子树添加</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//添加地节点地值大于当前节点的值</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-built_in">this</span>.right=node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.right.add(node);<span class="hljs-comment">//递归地向右子树添加</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//搜索树创建完毕，但是考虑到树的一方高度过高，还需要对树进行旋转处理</span><br>        <span class="hljs-comment">//当添加完节点后，如果(右子树高度-左子树高度)&gt;1，左旋</span><br>        <span class="hljs-keyword">if</span>(rightHeight()-leftHeight()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//如果右子树的左子树高度大于它的右子树的高度</span><br>            <span class="hljs-keyword">if</span>(right!=<span class="hljs-literal">null</span>&amp;&amp;right.leftHeight()&gt;right.rightHeight())&#123;<br>                <span class="hljs-built_in">this</span>.right.rightRotate();<br>                <span class="hljs-built_in">this</span>.leftRotate();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                leftRotate();<br>            &#125;<br>          leftRotate();<span class="hljs-comment">//左旋转</span><br>        &#125;<br>        <span class="hljs-comment">//当添加完节点后，如果(左子树高度-右子树高度)&gt;1，右旋</span><br>        <span class="hljs-keyword">if</span>(leftHeight()-rightHeight()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>&amp;&amp;left.rightHeight()&gt;left.leftHeight())&#123;<br>                <span class="hljs-comment">//先对当前节点的左子树左旋</span><br>                <span class="hljs-built_in">this</span>.left.leftRotate();<br>                <span class="hljs-comment">//然后再进行右旋</span><br>                <span class="hljs-built_in">this</span>.rightRotate();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                rightRotate();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>AVL类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            root=node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            root.add(node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            root.infixOrder();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;当前二叉排序树空，不能遍历&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找要删除的节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.search(value);<br>    &#125;<br>    <span class="hljs-comment">//查找要删除的父节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">searchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.searchParent(value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能：返回并删除根节点的右子树的最小节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 传入的节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回以node为根节点的二叉排序树的最小节点的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delRightTreeMin</span><span class="hljs-params">(Node node)</span>&#123;<br>        Node target=node;<br>        <span class="hljs-keyword">while</span>(target.left!=<span class="hljs-literal">null</span>)&#123;<br>            target=target.left;<br>        &#125;<br>        <span class="hljs-comment">//这时target就指向了最小节点</span><br>        <span class="hljs-comment">//删除最小节点</span><br>        delNode(target.value);<br>        <span class="hljs-keyword">return</span> target.value;<br>    &#125;<br>    <span class="hljs-comment">//删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node targetNode=search(value);<br>        <span class="hljs-comment">//如果没有找到要删除的节点</span><br>        <span class="hljs-keyword">if</span>(targetNode==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果发现当前这棵二叉排序树只有一个节点</span><br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>            root=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//去找targetNode的父节点</span><br>        Node parent=searchParent(value);<br>        <span class="hljs-comment">//如果删除的节点是叶子节点</span><br>        <span class="hljs-keyword">if</span>(targetNode.left==<span class="hljs-literal">null</span>&amp;&amp;targetNode.right==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//判断targetNode是父节点的左子节点还是父节点的右子节点</span><br>            <span class="hljs-keyword">if</span>(parent.left!=<span class="hljs-literal">null</span>&amp;&amp;parent.left==targetNode)&#123;<span class="hljs-comment">//是父节点的左子节点</span><br>                parent.left=<span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parent.right!=<span class="hljs-literal">null</span>&amp;&amp;parent.right==targetNode)&#123;<span class="hljs-comment">//是父节点的右子节点</span><br>                parent.right=<span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(targetNode.left!=<span class="hljs-literal">null</span>&amp;&amp;targetNode.right!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//有左右子树</span><br>            <span class="hljs-type">int</span> minVal=delRightTreeMin(targetNode.right);<br>            targetNode.value=minVal;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//删除只有一棵子树的节点</span><br>            <span class="hljs-keyword">if</span>(targetNode.left!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(parent!=<span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//如果targetNode是parent的左子节点</span><br>                    <span class="hljs-keyword">if</span> (parent.left == targetNode) &#123;<br>                        parent.left = targetNode.left;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        parent.right = targetNode.left;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    root=targetNode.left;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//要删除的节点有右子节点</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (parent.left == targetNode) &#123;<br>                        parent.left = targetNode.right;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        parent.right = targetNode.right;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    root=targetNode.right;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP首部</title>
    <link href="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/"/>
    <url>/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h1><img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/image-20220906145616078.png" class title="image-20220906145616078"><img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/image-20220906145626448.png" class title="image-20220906145626448"><h1 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h1><p>HTTP首部字段类型</p><ol><li>通用首部字段：请求响应报文都有</li><li>请求首部字段：客户端向服务器端发送请求</li><li>响应首部字段：服务器端向客户端返回响应</li><li>实体首部字段：请求和响应报文的实体部分使用的首部</li></ol><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>操作缓存的工作机制，多个参数之间使用$,$连接</p><ul><li><p><strong>no-cache</strong>：防止从缓存中返回过期的资源</p><ul><li><p>客户端发送的请求包含，表示客户端将不会接收缓存过的响应</p></li><li><p>服务器返回的响应包含：缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作</p></li><li>如果对Cache-Control中对cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存</li></ul></li><li><p><strong>no-store</strong>：控制可执行缓存的对象的指令</p><p>该指令规定缓存不能在本地存储请求或响应的任一部分</p></li><li><p><strong>max-age</strong>：</p><ul><li>当客户端发送的请求包含：如果判定缓存资源的缓存时间数值比指定时间的数值更小，客户端接收缓存的资源。</li><li>当服务器端返回的响应包含：缓存服务器不对资源的有效性再做确认，而max-age数值代表资源保存为缓存的最长时间</li></ul></li><li><p><strong>s-maxage</strong>：指定缓存期限和认证的指令</p><p>同max-age，但是只适用于供多位用户使用的公共缓存服务器</p></li><li><p><strong>min-fresh</strong>：要求缓存服务器返回至少还未过指定时间的缓存资源</p></li><li><p><strong>max-state</strong>：指示缓存资源，即使过期也照常接收</p></li><li><p><strong>only-if-cached</strong>：客户端仅在缓存服务器本地缓存目标资源的情况才会要求其返回</p></li><li><p><strong>must-revalidate</strong>：代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效</p><p>使用该指令会忽略max-state指令</p></li><li><p><strong>proxy-revalidate</strong>：要求所有的缓存服务器，在接收到客户端带有该指令的请求，返回响应之前，必须再次验证缓存的有效性</p></li><li><p><strong>no-transform</strong>：无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型</p></li></ul><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>该首部字段表示：</p><ul><li><p>控制不再转发给代理的首部字段</p><figure class="highlight http"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs http">Connection:不再转发的首部字段名<br></code></pre></td></tr></table></figure></li><li><p>管理持久连接</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br></code></pre></td></tr></table></figure></li></ul><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>表示创建HTTP报文的日期和时间</p><p>格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 03 Jul 2012 04:40:59 GMT<br></code></pre></td></tr></table></figure><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>Trailer会事先说明在报文主体后记录了哪些首部字段</p><h4 id="Trailer-Encoding"><a href="#Trailer-Encoding" class="headerlink" title="Trailer-Encoding"></a>Trailer-Encoding</h4><p>规定了传输报文主体时采用的编码方式</p><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>检测HTTP协议及其他协议是否可使用更高版本进行通信</p><p>Upgrade首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。在使用Upgrade时，还需要制定额外的Connnection:Upgrade</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>追踪客户端与服务器之间的请求和响应报文的传输路径</p><p>报文经过代理和网关时，会先在首部字段Via中附加服务器的信息，然后再进行转发</p><p>还可以避免请求回环的发生</p><h4 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h4><p>告知用户一些与缓存相关问题的警告</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Warning</span><span class="hljs-punctuation">: </span>[警告码][警告的主机:端口号] &quot;[警告内容]&quot; ([日期时间])<br></code></pre></td></tr></table></figure><img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/image-20220907203745462.png" class title="image-20220907203745462"><p>​    <img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/image-20220907203751532.png" class title="image-20220907203751532"></p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级</p><p>使用type/subtype这种形式，一次指定多种媒体类型</p><img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/image-20220907204231886.png" class title="image-20220907204231886"><p>若要给显示的媒体类型增加优先级，则使用$q=$来额外表示权重值，用分号进行分割$q$的范围是$0$~$1$。不指定$q$值时，默认权重$q=1.0$</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>通知服务器用户代理支持的字符集及字符集的相对优先顺序</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>告知服务器用户代理支持的内容编码及内容编码的优先级顺序，可一次性指定多种编码</p><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>告知服务器用户代理能够处理的自然语言集，以及自然语言及的相对优先级</p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>用来告知服务器，用户代理的认证信息（证书值）。</p><p>想要通过服务器认证的用户代理会在接收到返回的401状态码后，把首部字段Authorization加入请求中</p><h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><p>告知服务器期望出现的某种特定的行为。</p><p>因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码417 Expectation Failed</p><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>告知服务器使用用户代理的用户的电子邮件地址</p><p>使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>告知服务器请求的资源所处的互联网主机名和端口号</p><p>Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关系</p><h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>条件请求：If-xxx这种样式的请求首部字段</p><p>服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求</p><p>如果后面指定参数，它会告知服务器匹配资源所用的实体标记ETag值，这时的服务器无法使用弱ETag值。服务器会对比该字段值和资源的ETag值，仅当两者一致时，才会执行请求；反之，返回412 Precondition Failed</p><h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p>告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求；</p><p>而在指定If-Modified-Since字段值的日期之后，如果请求的资源都没有过更新过，返回304 Not Modified的响应</p><h4 id="if-none-Match"><a href="#if-none-Match" class="headerlink" title="if-none-Match"></a>if-none-Match</h4><p>属附带条件之一，它和首部字段If-Match作用相反</p><h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p>属附带条件之一，告知服务器若指定的If-Range字段值(ETag值或者时间)和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，返回全体资源。</p><h4 id="IF-Unmodified-Since"><a href="#IF-Unmodified-Since" class="headerlink" title="IF-Unmodified-Since"></a>IF-Unmodified-Since</h4><p>与首部字段If-Modified-Since作用相反。</p><p>告知服务器请求的资源只有再字段值之内指定的日期之后，为发生更新的情况下才能处理该请求。</p><h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h4><p>通过TRACE方法或OPTIONS方法，发送含有Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器的最大数目</p><h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><p>接收到代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息。</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>只需获取部分资源的范围请求</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>告知服务器请求的原始资源的URI</p><h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><p>告知服务器客户端能够处理响应的传输编码方式以及相对优先级。</p><p>和Accept-Encoding的功能很像，但是用于传输编码</p><p>除了指定传输编码之外，还可以指定伴随trailer字段的分块传输编码的方式，只需要把trailers赋值给该字段值</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>会将创建请求的浏览器和用户代理名称等信息传递给服务器</p><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p>告知客户端服务器是否能处理范围请求，以指定获取服务器端的某个部分的资源</p><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p>高职客户端，源服务器在多久前创建了响应。字段值的单位为秒</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为美分资源分配对应的ETag值。</p><p>当资源更新时，ETag值也会更新</p><ul><li>强ETag值：不论实体发生多么细微的变化都会改变其值</li><li>若ETag值：只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值</li></ul><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>可以将响应接收方引导至某个与请求URI位置不同的资源。</p><p>基本上会配合3xx:Redirection的响应，提供重定向的URI</p><h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><p>会把由代理服务器所要求的认证信息发送给客户端</p><h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><p>告知客户端应该在多久之后再次发送请求</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>告知客户端当前服务器上安装的HTTP服务器应用程序的信息</p><h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p>可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令</p><h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><p>用于HTTP访问认证。告知客户端适用于访问请求URI所指定资源的认证方案和带参数提示的质询</p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>通知客户端能够支持Request-URI指定资源的所有HTTP方法</p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>告知客户端服务器对实体的主体部分选用的内容编码的方式。</p><p>内容编码是在不丢失实体信息的前提下所进行的压缩</p><h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><p>告知客户端实体主体使用的自然语言</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p>表明实体主体部分的大小</p><h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><p>给出与报文主体部分相对应的URI。与Location不同，Content-Location表示的时报文主体返回资源对应的URI</p><h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><p>检查报文主体在传输过程中是否保持完整，以及确认传输到达</p><h4 id="Cotent-Range"><a href="#Cotent-Range" class="headerlink" title="Cotent-Range"></a>Cotent-Range</h4><p>告知客户端作为响应返回的实体的哪个部分符合范围请求</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>实体主体内对象的媒体类型。</p><p>和Accept一样，使用type/subtype形式赋值</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>将资源失效的日期告知客户端。</p><p>当字段Cache-Control有指定的max-age指令时，会优先处理max-age指令</p><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>指明资源最终修改时间</p><h3 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h3><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/image-20220907225742963.png" class title="image-20220907225742963"><img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%A6%96%E9%83%A8/image-20220907225748834.png" class title="image-20220907225748834">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2022/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序从数组的下标为1的元素开始，将整个数组分为两个部分：</p><p>一部分是前面的，表示已经排序好了</p><p>另一部分是后面的，还是无序状态</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;arr.length;i++)&#123;<br><span class="hljs-type">int</span> insertIndex=i-<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> insertVal=arr[i];<br><span class="hljs-keyword">while</span>(insertIndex&gt;=<span class="hljs-number">0</span>&amp;&amp;arr[insertIndex]&gt;insertVal)&#123;<br>arr[insertIndex+<span class="hljs-number">1</span>]=arr[insertIndex];<br>insertIndex--;<br>&#125;<br>arr[insertIndex+<span class="hljs-number">1</span>]=insertVal;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度，最坏$O(N^2)$，最好$O(N)$</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>插入排序的升级版，</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"/>
    <url>/2022/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="简单的"><a href="#简单的" class="headerlink" title="简单的"></a>简单的</h1><h3 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h3><p>Http协议是无状态协议，这种协议有好处，由于不必保存状态，可以减少服务器的CPU及内存资源的消耗。</p><p>但是会使业务处理比较复杂，Cookie技术通过在请求和相应报文中写入Cookie信息控制客户端状态</p><p>服务端在相应报文中写入Set-Cookie通知客户端保存该值，在下一次访问资源时请求报文加上Cookie的值，服务器对比记录，得到一个状态信息</p><h1 id="Http报文信息"><a href="#Http报文信息" class="headerlink" title="Http报文信息"></a>Http报文信息</h1><h3 id="报文的首部内容"><a href="#报文的首部内容" class="headerlink" title="报文的首部内容"></a>报文的首部内容</h3><ul><li><strong>请求行</strong>：请求的方法，请求URI和HTTP版本</li><li><strong>状态行</strong>：相应结果状态码，原因短语，HTTP版本</li><li><strong>首部字段</strong>：请求和相应的各种条件和属性的各类首部，4个首部：通用、请求、相应、实体</li><li><strong>其他</strong>：如Cookie信息</li></ul><h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP报文的主体用于传输请求或响应的实体主体</p><p>通常，报文主题等于实体。只有当传输过程中进行编码操作时，实体主体的内容发生变化，才导致它和它的报文主体产生差异</p><p>内容编码：指明应用在试题内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</p><h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>HTTP通信时，请求编码的实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</p><p>在传输大容量数据之前，通过把数据分割成多块，能够让浏览器逐步显示页面。</p><p>实体分块传输编码：把实体主题分块的功能</p><p>每一块都会用十六进制来标记块的大小，实体的最后一块会用$”0(CR+LF)”$来标记</p><h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP报文使用多对象集合时，需要在首部字段里添加<strong>Content-type</strong></p><p>使用<strong>boundary</strong>字符串来划分多部分对象集合指明的各类实体。</p><p>在boundary字符串指定的各个实体的起始行之前插入”—“标记，而在多部分对象集合对应的字符串的最后插入”—“标记</p><h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>执行范围请求时，使用首部字段<strong>Range</strong>来指定资源的<strong>byte</strong>范围</p><p>格式：</p><figure class="highlight http"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>byte=5001-10000//5001~10000<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>byte=5001-//5001之后的全部<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>byte=-3000,5000-7000 //从一开始到3000和5000~7000的<br></code></pre></td></tr></table></figure><p>响应会返回状态码<strong>206 Partial Conten</strong>t响应报文，会在首部字段<strong>Content-Type</strong>标明<strong>multipart/byteranges</strong>后返回响应报文</p><h3 id="内容协商后返回最合适的内容"><a href="#内容协商后返回最合适的内容" class="headerlink" title="内容协商后返回最合适的内容"></a>内容协商后返回最合适的内容</h3><p>内容协商会以响应的资源的语言、字符集、编码方式等作为判断的基准，提供给客户端最为合适的资源</p><ul><li>服务器驱动协商</li><li>客户端驱动协商</li><li>透明协商</li></ul><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>客户端发来的请求在服务端背正常处理了</p><h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>请求被处理，但是不返回也不允许返回任何实体的主体</p><h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行了范围请求，服务器成功执行了这部分GET请求，响应报文中包含<strong>Content-Range</strong>指定的范围的实体内容</p><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向。表示请求的资源已经分配了新的URI，以后应该使用资源现在所指的URI</p><h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时性重定向。但是代表资源不是被永久移动，只是临时性质的，以后还可能移动</p><h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p><p>与302的区别是明确客户端应使用GET方法</p><h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>服务器端允许请求访问资源，但是未满足条件。但是和重定向没有任何关系</p><h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>与302相同。</p><p>遵照浏览器标准，不会从POST变成GET</p><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>请求报文中存在语法错误，浏览器会像对待200 OK一样对待该状态码</p><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>发送的请求需要通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。如果之前已进行过1次请求，则表示认证失败</p><p>返回含401的响应必须包含一个适用于被请求资源的<strong>WWW-Authenticate</strong>首部用以质询用户信息。当浏览器初次接收到401响应时，会弹出认证用的对话窗口</p><h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>请求资源的访问被服务器拒接了。服务端没有必要给出详细理由</p><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>无法找到请求的资源</p><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><p>服务器端在执行请求时发生了错误，Web应用存在bug等</p><h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><p>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</p><h1 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h1><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>在相同的IP地址下，由于虚拟主机可以即存在多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>基本行为：接收客户端发送的请求后转发给其他服务器。代理不改变请求URI</p><p>转发时，需要附加Via首部字段以标记出经过的主机信息</p><p>利用代理服务器的好处：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关能使通信线路上的服务器提供非HTTP协议服务</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。</p><p>隧道的目的是确保客户端能与服务器进行安全的通信</p><p>隧道本身不回去解析HTTP请求，会在通信双方断开连接时结束</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h3 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h3><ul><li>通信使用明文，不加密，内容可能会被窃听</li><li>不验证通信双方的身份，因此有可能会遭遇伪装</li><li>无法验证报文的完整性，所以有可能已遭篡改</li></ul><p>HTTP+加密+认证+完整性保护=HTTPS</p><h3 id="共享密钥（对称密钥）"><a href="#共享密钥（对称密钥）" class="headerlink" title="共享密钥（对称密钥）"></a>共享密钥（对称密钥）</h3><p>加密和解密同用一个密钥的方式</p><p>但是发送密钥有被窃听的风险，但不发送，对方就不能解密。如果密钥能够安全地被发送，那数据也应该能安全送达</p><h3 id="使用两把密钥的公开密钥加密"><a href="#使用两把密钥的公开密钥加密" class="headerlink" title="使用两把密钥的公开密钥加密"></a>使用两把密钥的公开密钥加密</h3><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。</p><p>私有密钥不能让别人直到，公开密钥可以随意发布，任何人都能获得</p><p>使用公开密钥加密方式，发送密钥的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。</p><p>根据公开密钥和密文，解密是非常困难的</p><h3 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h3><p>HTTPS使用<strong>共享密钥加密</strong>和<strong>公开密钥加密</strong>两者并用的混合加密机制</p><img src="/2022/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/image-20220906141458279.png" class title="image-20220906141458279"><p><strong>证书</strong>：解决公开密钥是否是真正的公开密钥的问题</p><p>证书作用一个是证明通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在</p><p>证书使用流程：</p><ol><li>服务器首先向一个大家都信任的第三方机构申请一个身份证书</li><li>客户端向服务器建立通信之前首先向服务器请求获得服务器的证书</li><li>服务器收到请求后把数字证书发送给客户端</li><li>客户端获得服务器证书后，然后与可信任的第三方机构证书进行验证，验证通过过后则进行正常的内容通信</li></ol><h3 id="HTTPS安全通信机制"><a href="#HTTPS安全通信机制" class="headerlink" title="HTTPS安全通信机制"></a>HTTPS安全通信机制</h3><p>前提：公共密钥加密的密文只有私钥才能解开，私有密钥加密的密文只有公共密钥才能解开</p><h4 id="1-客户端发出请求"><a href="#1-客户端发出请求" class="headerlink" title="1.客户端发出请求"></a>1.客户端发出请求</h4><p>客户端向服务器发出加密通信的请求，称为Client Hello报文。</p><p>报文中有以下信息：</p><ul><li>客户端支持的SSL版本</li><li>加密组件(Cipher Suite)列表</li></ul><h4 id="2-服务器回应"><a href="#2-服务器回应" class="headerlink" title="2.服务器回应"></a>2.服务器回应</h4><p>如果加密组件不符合服务器的要求，断开连接</p><ol><li>服务器发送Server Hello报文回应，内容和上一封客户端报文相似，服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的</li><li>发送Certificate报文，报文包含公开密钥证书</li><li>发送Server Hello Done报文通知客户端</li></ol><h4 id="3-客户端回应"><a href="#3-客户端回应" class="headerlink" title="3.客户端回应"></a>3.客户端回应</h4><ol><li>客户端发送Client Key Exchange报文作为回应，报文中包含通信加密中使用的一种被称为Pro Master secret的随机密码串，该密码串就是后面用到的对称加密的私钥</li><li>客户端持续发送Change Cipher Spec报文，提示服务器之后的通信会采用Pre-master secret密钥加密</li><li>客户端发送Finished报文，报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准</li></ol><h4 id="4-服务器响应"><a href="#4-服务器响应" class="headerlink" title="4.服务器响应"></a>4.服务器响应</h4><ol><li>服务器同样发送Change Cipher Spec报文</li><li>服务器同样发送Finished报文</li></ol><p>服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成了</p><p>两者开始发送HTTP报文</p><h3 id="SSL速度"><a href="#SSL速度" class="headerlink" title="SSL速度"></a>SSL速度</h3><p>SSL速度慢分两种</p><p>一种是通信慢，另一种是由于大量消耗CPU等内存资源，导致变慢，</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉查找树</title>
    <link href="/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <url>/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>对数中的每个节点，它的左子树的值都小于该节点的值，它的右子树的值都大于该节点的值</p><p>增加节点、查找节点比较简单，删除节点的逻辑有点复杂</p><p>我们先要找到<strong>要删除节点的父节点</strong>和<strong>要删除的节点</strong>，然后分以下三种情况</p><ul><li>如果要删除的节点是叶子节点，直接让父节点的左儿子或右儿子为0即可</li><li>如果要删除的节点有左右子树，找到右子树的最小值，让删除该节点并互换两节点的值</li><li>如果要删除的节点只有一棵子树，直接按链表删除就好，注意分好类</li></ul><p>定义节点类：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> value;<br>    Node left;<br>    Node right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value=value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//递归的形式添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断传入节点的值，和当前子树的根节点值嗯对关系</span><br>        <span class="hljs-keyword">if</span>(node.value&lt;<span class="hljs-built_in">this</span>.value)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//如果当前节点左子节点为空</span><br>                <span class="hljs-built_in">this</span>.left=node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.left.add(node);<span class="hljs-comment">//递归地向左子树添加</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//添加地节点地值大于当前节点的值</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-built_in">this</span>.right=node;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">this</span>.right.add(node);<span class="hljs-comment">//递归地向右子树添加</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.infixOrder();<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.infixOrder();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找要删除的节点</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 希望删除的节点的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果找到返回该节点，否则返回null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.value==value) <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value&lt;<span class="hljs-built_in">this</span>.value)&#123;<span class="hljs-comment">//如果查找的值小于当前节点，则向左子树递归查找</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left==<span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.left.search(value);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果查找的值大于当前节点，则向右子树递归查找</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.right.search(value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找要删除节点的父节点</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 要查找的节点的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回要删除节点的父节点，如果没有就返回null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">searchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-comment">//如果当前节点就是要删除的节点的父节点就返回</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.left.value==value)||<br>                (<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.right.value==value))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果查找的值小于当前节点的值并且当前节点的左子节点不为空</span><br>        <span class="hljs-keyword">if</span>(value&lt;<span class="hljs-built_in">this</span>.value&amp;&amp;<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.left.searchParent(value);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value&gt;=<span class="hljs-built_in">this</span>.value&amp;&amp;<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.right.searchParent(value);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有找到父节点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>定义二叉查找树类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySortTree</span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            root=node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            root.add(node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            root.infixOrder();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;当前二叉排序树空，不能遍历&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找要删除的节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.search(value);<br>    &#125;<br>    <span class="hljs-comment">//查找要删除的父节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">searchParent</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.searchParent(value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 功能：返回并删除根节点的右子树的最小节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 传入的节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回以node为根节点的二叉排序树的最小节点的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delRightTreeMin</span><span class="hljs-params">(Node node)</span>&#123;<br>        Node target=node;<br>        <span class="hljs-keyword">while</span>(target.left!=<span class="hljs-literal">null</span>)&#123;<br>            target=target.left;<br>        &#125;<br>        <span class="hljs-comment">//这时target就指向了最小节点</span><br>        <span class="hljs-comment">//删除最小节点</span><br>        delNode(target.value);<br>        <span class="hljs-keyword">return</span> target.value;<br>    &#125;<br>    <span class="hljs-comment">//删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node targetNode=search(value);<br>        <span class="hljs-comment">//如果没有找到要删除的节点</span><br>        <span class="hljs-keyword">if</span>(targetNode==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果发现当前这棵二叉排序树只有一个节点</span><br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>           root=<span class="hljs-literal">null</span>;<br>           <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//去找targetNode的父节点</span><br>        Node parent=searchParent(value);<br>        <span class="hljs-comment">//如果删除的节点是叶子节点</span><br>        <span class="hljs-keyword">if</span>(targetNode.left==<span class="hljs-literal">null</span>&amp;&amp;targetNode.right==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//判断targetNode是父节点的左子节点还是父节点的右子节点</span><br>            <span class="hljs-keyword">if</span>(parent.left!=<span class="hljs-literal">null</span>&amp;&amp;parent.left==targetNode)&#123;<span class="hljs-comment">//是父节点的左子节点</span><br>                parent.left=<span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parent.right!=<span class="hljs-literal">null</span>&amp;&amp;parent.right==targetNode)&#123;<span class="hljs-comment">//是父节点的右子节点</span><br>                parent.right=<span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(targetNode.left!=<span class="hljs-literal">null</span>&amp;&amp;targetNode.right!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//有左右子树</span><br>            <span class="hljs-type">int</span> minVal=delRightTreeMin(targetNode.right);<br>            targetNode.value=minVal;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//删除只有一棵子树的节点</span><br>            <span class="hljs-keyword">if</span>(targetNode.left!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(parent!=<span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//如果targetNode是parent的左子节点</span><br>                    <span class="hljs-keyword">if</span> (parent.left == targetNode) &#123;<br>                        parent.left = targetNode.left;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        parent.right = targetNode.left;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    root=targetNode.left;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//要删除的节点有右子节点</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (parent.left == targetNode) &#123;<br>                        parent.left = targetNode.right;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        parent.right = targetNode.right;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    root=targetNode.right;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="普通的二叉树的各种方法"><a href="#普通的二叉树的各种方法" class="headerlink" title="普通的二叉树的各种方法"></a>普通的二叉树的各种方法</h1><p>BinaryTree封装HeroNode节点</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&#123;<br>    <span class="hljs-keyword">private</span> HeroNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(HeroNode root)</span>&#123;<br>        <span class="hljs-built_in">this</span>.root=root;<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>)<span class="hljs-built_in">this</span>.root.preOrder();<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.root.infixOrder();<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.root.postOrder();<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//前序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">preOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.root.preOrderSearch(no);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.root.infixOrderSearch(no);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//后序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">postOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.root.postOrderSearch(no);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;空树，不能删除&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.getNo()==no) &#123;<br>            root=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">this</span>.root.delNode(no);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroNode</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> HeroNode left;<br>    <span class="hljs-keyword">private</span> HeroNode right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HeroNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no,String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.no=no;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(HeroNode left)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(HeroNode right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;no=&quot;</span> + no +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.preOrder();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.preOrder();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.infixOrder();<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.infixOrder();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//后续遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.postOrder();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.postOrder();<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//前序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">preOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no==no) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        HeroNode resNode=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.left.preOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(resNode!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> resNode;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.right.preOrderSearch(no);<br>        <span class="hljs-keyword">return</span>  resNode;<br>    &#125;<br>    <span class="hljs-comment">//中序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        HeroNode resNode=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.left.infixOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(resNode!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> resNode;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no==no) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.right.infixOrderSearch(no);<br>        <span class="hljs-keyword">return</span> resNode;<br>    &#125;<br>    <span class="hljs-comment">//后序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">postOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        HeroNode resNode=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.left.postOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(resNode!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> resNode;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.right.postOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no==no) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> resNode;<br>    &#125;<br>    <span class="hljs-comment">//递归删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.left.no==no)&#123;<br>            <span class="hljs-built_in">this</span>.left=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.right.no==no)&#123;<br>            <span class="hljs-built_in">this</span>.right=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.left.delNode(no);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.right.delNode(no);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="数组模拟二叉树"><a href="#数组模拟二叉树" class="headerlink" title="数组模拟二叉树"></a>数组模拟二叉树</h1><p>对于一个节点n而言，左儿子是2n，右儿子是2n+1</p><p>假设有N个叶子节点，最少需要2N-1个空间，因为自己需要N个，所有的父节点需要N-1个，因为a[0]是不能用的，所以最少需要开2N个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrBinaryTree</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>  [] arr;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr)</span>&#123;<br>        <span class="hljs-built_in">this</span>.arr=arr;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(arr==<span class="hljs-literal">null</span>||arr.length==<span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;数组为空，不能按照二叉树的前序遍历&quot;</span>);<br>        &#125;<br>        System.out.println(arr[index]);<br>        <span class="hljs-keyword">if</span>(index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt; arr.length)&#123;<br>            preOrder(index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>&lt; arr.length)&#123;<br>            preOrder(index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h1><p>传统的二叉树的很多节点，如叶子节点的左右节点都为空，会浪费很多空间，如果让他们指向一些有用的东西，会节省很多资源</p><p>让一些空节点指向”前驱节点“或者”后继节点“，这样就不必用递归的方式遍历二叉树，可以节省很多时间</p><p>这个例子中序线索化二叉树，所以中序遍历就无需递归搜索</p><p>思路：如果该节点的左儿子节点为空，那么就让它指向上一个节点，称为”<strong>前驱节点</strong>“；如果该节点的右儿子为空，那么就让它指向下一个节点，称为”<strong>后继节点</strong>“。</p><p>同时，每个节点还应该加上两个变量，表示左指针的类型，0表示正常指向，1表示是前驱节点或者后继节点</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedBinaryTree</span>&#123;<br>    <span class="hljs-keyword">private</span> HeroNode root;<br>    <span class="hljs-keyword">private</span> HeroNode pre=<span class="hljs-literal">null</span>;<span class="hljs-comment">//在进行递归线索化时，pre总是保留node的前一个节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(HeroNode root)</span>&#123;<br>        <span class="hljs-built_in">this</span>.root=root;<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>)<span class="hljs-built_in">this</span>.root.preOrder();<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.root.infixOrder();<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.root.postOrder();<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;二叉树为空，无法遍历&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//前序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">preOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.root.preOrderSearch(no);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//中序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.root.infixOrderSearch(no);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//后序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">postOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.root.postOrderSearch(no);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;二叉树为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;空树，不能删除&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.getNo()==no) &#123;<br>            root=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">this</span>.root.delNode(no);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//遍历中序线索化二叉树的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//定义一个变量，存储当前遍历的节点</span><br>        HeroNode temp=root;<br>        <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//循环先找到leftType＝1的节点，即该节点是中序遍历的第一个节点</span><br>            <span class="hljs-keyword">while</span>(temp.getLeftType()==<span class="hljs-number">0</span>)&#123;<br>                temp=temp.getLeft();<br>            &#125;<br>            <span class="hljs-comment">//打印当前节点</span><br>            System.out.println(temp);<br>            <span class="hljs-comment">//如果右节点是后继节点</span><br>            <span class="hljs-keyword">while</span>(temp.getLeftType()==<span class="hljs-number">1</span>)&#123;<br>                temp=temp.getRight();<br>                System.out.println(temp);<br>            &#125;<br>            temp=temp.getRight();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//对二叉树中序线索化的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedNodes</span><span class="hljs-params">(HeroNode node)</span>&#123;<br>        <span class="hljs-comment">//如果node等于null，无法线索化</span><br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//中序线索化：（一）先线索化左子树</span><br>        threadedNodes(node.getLeft());<br>        <span class="hljs-comment">//（二）线索化当前节点</span><br>        <span class="hljs-comment">//先处理当前节点的前驱节点</span><br>        <span class="hljs-keyword">if</span>(node.getLeft()==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//让当前节点的左指针指向前驱节点</span><br>            node.setLeft(pre);<br>            node.setLeftType(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//处理后继节点</span><br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">null</span>&amp;&amp;pre.getRight()==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//让前驱节点的右指针指向当前节点</span><br>            pre.setRight(node);<br>            <span class="hljs-comment">//修改前驱节点的右指针类型</span><br>            pre.setRightType(<span class="hljs-number">1</span>);<br>        &#125;<br>        pre=node;<br>        <span class="hljs-comment">//（三）线索化右子树</span><br>        threadedNodes(node.getRight());<br>    &#125;<br>    <span class="hljs-comment">//重载中序线索化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedNodes</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.threadedNodes(<span class="hljs-built_in">this</span>.root);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroNode</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> HeroNode left;<br>    <span class="hljs-keyword">private</span> HeroNode right;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> leftType;<span class="hljs-comment">//0:表示左子树  1：表示指向前驱节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rightType;<span class="hljs-comment">//0：表示右子树  1：表示后继节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLeftType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> leftType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeftType</span><span class="hljs-params">(<span class="hljs-type">int</span> leftType)</span> &#123;<br>        <span class="hljs-built_in">this</span>.leftType = leftType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRightType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rightType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRightType</span><span class="hljs-params">(<span class="hljs-type">int</span> rightType)</span> &#123;<br>        <span class="hljs-built_in">this</span>.rightType = rightType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HeroNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.no=no;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(HeroNode left)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(HeroNode right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HeroNode&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;no=&quot;</span> + no +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.preOrder();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.preOrder();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infixOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.infixOrder();<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.infixOrder();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//后续遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.left.postOrder();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.right.postOrder();<br>        &#125;<br>        System.out.println(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//前序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">preOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no==no) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        HeroNode resNode=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.left.preOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(resNode!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> resNode;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.right.preOrderSearch(no);<br>        <span class="hljs-keyword">return</span>  resNode;<br>    &#125;<br>    <span class="hljs-comment">//中序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">infixOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        HeroNode resNode=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.left.infixOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(resNode!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> resNode;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no==no) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.right.infixOrderSearch(no);<br>        <span class="hljs-keyword">return</span> resNode;<br>    &#125;<br>    <span class="hljs-comment">//后序遍历查找</span><br>    <span class="hljs-keyword">public</span> HeroNode <span class="hljs-title function_">postOrderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        HeroNode resNode=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.left.postOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(resNode!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> resNode;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) resNode=<span class="hljs-built_in">this</span>.right.postOrderSearch(no);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.no==no) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> resNode;<br>    &#125;<br>    <span class="hljs-comment">//递归删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delNode</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.left.no==no)&#123;<br>            <span class="hljs-built_in">this</span>.left=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>&amp;&amp;<span class="hljs-built_in">this</span>.right.no==no)&#123;<br>            <span class="hljs-built_in">this</span>.right=<span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.left!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.left.delNode(no);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.right!=<span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.right.delNode(no);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    <url>/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="传统数组队列"><a href="#传统数组队列" class="headerlink" title="传统数组队列"></a>传统数组队列</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用数组模拟队列-编写一个ArrayQueue的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<span class="hljs-comment">//表示数组的最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;<span class="hljs-comment">//指向队列头</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;<span class="hljs-comment">//指向队列的尾部</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> []arr;<span class="hljs-comment">//该数组用于存放数据,模拟队列</span><br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> arrMaxSize)</span>&#123;<br>        maxSize=arrMaxSize;<br>        arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];<br>        front=-<span class="hljs-number">1</span>;<span class="hljs-comment">//指向队列头部，分析出front是指向队列头的前一个位置</span><br>        rear=-<span class="hljs-number">1</span>;<span class="hljs-comment">//指向队列尾，指向队列尾的数据，即队列最后一个数据</span><br>    &#125;<br>    <span class="hljs-comment">//判断队列是否满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> rear==maxSize-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> rear==front;<br>    &#125;<br>    <span class="hljs-comment">//添加数据到队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-comment">//判断队列是否满</span><br>        <span class="hljs-keyword">if</span>(isFull()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列满，不能加入数据&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            rear++;<span class="hljs-comment">//让rear后移</span><br>            arr[rear]=value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取队列的数据(出队列)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，不能取数据&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            front++;<br>            <span class="hljs-keyword">return</span> arr[front];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//显示队列的所有数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列空，无数据&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>                System.out.printf(<span class="hljs-string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//显示头部数据，不取出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">headQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，无数据&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> arr[front+<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样front之前的位置就被浪费了</p><h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>循环队列也是用数组模拟实现的，但是循环队列总有一位是空出来的</p><p>初始front和rear指向队列的第一个元素，此时front=rear，rear指向的是<strong>队列中最后一个元素的后一位</strong>，front指向的是<strong>队列中元素的第一个元素的位置</strong></p><p>队列空的条件：$rear==front$</p><p>队列满的条件:$(rear+1)\%maxSize==front$</p><p>队列中元素个数：$(rear+maxSize-front)\%maxSize$ </p><p>添加数据时，$rear=(rear+1)\%maxSize$</p><p>取出数据时，$front=(front+1)\%maxSize$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用数组模拟队列-编写一个CircleArray的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleArray</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<span class="hljs-comment">//表示数组的最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;<span class="hljs-comment">//队列头:指向队列的第一个元素，arr[front]，初始值为0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;<span class="hljs-comment">//队列尾:指向队列最后一个元素的后一位,希望空出一个位置，初始值为0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> []arr;<span class="hljs-comment">//该数据用于存放数据，模拟队列</span><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircleArray</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span>&#123;<br>        <span class="hljs-built_in">this</span>.maxSize=maxSize;<br>        arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];<br>        front=rear=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断队列是否满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> (rear+<span class="hljs-number">1</span>)%maxSize==front;<br>    &#125;<br>    <span class="hljs-comment">//判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> rear==front;<br>    &#125;<br>    <span class="hljs-comment">//添加数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(isFull())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列满，不能加数据&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        arr[rear]=value;<br>        <span class="hljs-comment">//将rear后移，这里必须考虑取模</span><br>        rear=(rear+<span class="hljs-number">1</span>)%maxSize;<br>    &#125;<br>    <span class="hljs-comment">//取数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列空，不能取数据&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> value=arr[front];<br>        <span class="hljs-comment">//后移时考虑取模</span><br>        front=(front+<span class="hljs-number">1</span>)%maxSize;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-comment">//显示队列数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列空，没有数据&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//从front开始遍历，遍历(rear+maxSize-front)%maxSize个值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=front;i&lt;front+size();i++)&#123;<br>            System.out.printf(<span class="hljs-string">&quot;arr[%d]:%d\n&quot;</span>,i%maxSize,arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回有效数据的个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> (rear+maxSize-front)%maxSize;<br>    &#125;<br>    <span class="hljs-comment">//返回队列头元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">headQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[front];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><p>来自CS61B中的两个双端队列：</p><ul><li><a href="https://www.malchinee.top/2022/09/21/proj1A-dataStructers/#%E7%BC%96%E5%86%99LinkedListDeque-java">链式结构</a></li><li><a href="https://www.malchinee.top/2022/09/21/proj1A-dataStructers/#%E7%BC%96%E5%86%99ArrayDeque-java">线性结构（数组大小可变）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
    <url>/2022/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<span class="hljs-comment">//栈的大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[]stack;<span class="hljs-comment">//数组模拟栈，数据就放在该数组中</span><br>    <span class="hljs-type">int</span> top=-<span class="hljs-number">1</span>;<span class="hljs-comment">//栈顶，没有数据初始化为-1</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span>&#123;<br>        <span class="hljs-built_in">this</span>.maxSize=maxSize;<br>        stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSize];<br>    &#125;<br><br>    <span class="hljs-comment">//判断栈是否满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> top==maxSize-<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断栈是否空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> top==-<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-keyword">if</span>(isFull())&#123;<br>            System.out.println(<span class="hljs-string">&quot;栈满，无法加数据&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        top++;<br>        stack[top]=value;<br>    &#125;<br>    <span class="hljs-comment">//出栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;栈空，无法返回数据&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> value=stack[top];<br>        top--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-comment">//遍历栈,遍历时需要从栈顶开始显示数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空，无法遍历&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=top;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            System.out.printf(<span class="hljs-string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="栈实现一个计算器"><a href="#栈实现一个计算器" class="headerlink" title="栈实现一个计算器"></a>栈实现一个计算器</h1><p>处理以上基本的方法外，还需要在ArrayStack类里添加一些方法：</p><ul><li><p>返回当前栈顶，但是不出栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> stack[top];<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>返回运算符的优先级，优先级由程序员决定，数字越高，优先级越大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">priority</span><span class="hljs-params">(<span class="hljs-type">int</span> oper)</span>&#123;<br>        <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&#x27;*&#x27;</span>||oper==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( oper==<span class="hljs-string">&#x27;+&#x27;</span>||oper==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//假定目前的表达式只有加减乘除</span><br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>判断是不是一个运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOper</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span>&#123;<br>        <span class="hljs-keyword">return</span> val==<span class="hljs-string">&#x27;+&#x27;</span>||val==<span class="hljs-string">&#x27;-&#x27;</span>||val==<span class="hljs-string">&#x27;*&#x27;</span>||val==<span class="hljs-string">&#x27;/&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>计算方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2,<span class="hljs-type">int</span> oper)</span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于存放计算结果</span><br>        <span class="hljs-keyword">switch</span> (oper)&#123;<br>            <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;+&#x27;</span>:<br>                res=num1+num2;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;-&#x27;</span>:<br>                res=num2-num1;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                res=num1*num2;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                res=num2/num1;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><p>我们需要两个栈，一个是数栈，存放数字和计算结果，一个是符号栈，用来存放符号</p><p>输入一串字符串，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String expression=<span class="hljs-string">&quot;33+2*6-2&quot;</span><br></code></pre></td></tr></table></figure><p>扫描字符串，碰到数字就入数栈，碰到符号先判断栈是否为空。</p><p>如果是空栈就入栈；</p><p>如果不是空栈，判断该符号的优先级是否小于等于栈顶符号的优先级，如果大于，入栈；如果是，就将弹出符号栈栈顶的一个运算符和数栈的两个数字进行运算，将运算结果再入数栈</p><p>最后扫描完字符串以后，按顺序从数栈和符号栈中pop出相应的数和符号，并进行运算</p><p>步骤：</p><p>第一步：准备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayStack numStack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayStack2</span>(<span class="hljs-number">10</span>);<br>ArrayStack operStack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayStack2</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//定义需要的相关变量</span><br><span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于扫描</span><br><span class="hljs-type">int</span> num1=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> num2=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> oper=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>String keepNum=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//用于拼接多位数</span><br><span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//将每次扫描得到的char保存到ch中</span><br></code></pre></td></tr></table></figure><p>第二步：扫描整个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">//依次得到expression中的每一个字符</span><br>    ch=expression.substring(index,index+<span class="hljs-number">1</span>).charAt(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//判断ch是什么，然后做相应的处理</span><br>    <span class="hljs-keyword">if</span>(operStack.isOper(ch))&#123;<span class="hljs-comment">//如果是运算符</span><br>         <span class="hljs-comment">//判断当前的符号栈是否为空</span><br>         <span class="hljs-keyword">if</span>(!operStack.isEmpty())&#123;<br>           <span class="hljs-comment">/*处理:如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就 需要从</span><br><span class="hljs-comment">            数栈中pop出两个数，在符号栈中pop出一个符号，进行运算，将得到结果入数栈，然后将当前的操作符入符号栈</span><br><span class="hljs-comment">                   * */</span><br>                   <span class="hljs-keyword">if</span>(operStack.priority(ch)&lt;= operStack.priority(operStack.peek()))&#123;<br>                       num1=numStack.pop();<br>                       num2=numStack.pop();<br>                       oper=operStack.pop();<br>                       res=numStack.cal(num1,num2,oper);<br>                       <span class="hljs-comment">//把运算结果入数栈</span><br>                       numStack.push(res);<br>                       operStack.push(ch);<br>                   &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果当前符号的优先级大于栈中操作符的优先级</span><br>                       operStack.push(ch);<br>                   &#125;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   <span class="hljs-comment">//如果为空，直接入符号栈</span><br>                   operStack.push(ch);<br>               &#125;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果是数字</span><br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               * 当发现是数字时，不能发现一个数就直接入数栈，它可能是多位数</span><br><span class="hljs-comment">               * 在处理数时，需要向expression表达式的后面index后再看一位</span><br><span class="hljs-comment">               * 如果是数字就继续扫描，如果是符号才入栈</span><br><span class="hljs-comment">               * 需要定义一个字符串变量，用于拼接</span><br><span class="hljs-comment">               * */</span><br><br>               <span class="hljs-comment">//处理多位数</span><br>               keepNum+=ch;<br>               <span class="hljs-keyword">if</span>(index==expression.length()-<span class="hljs-number">1</span>)&#123;<br>                   numStack.push(Integer.parseInt(keepNum));<br>               &#125;<span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">//判断下一位字符是不是数字,注意只是看一位，不是index++</span><br>                   <span class="hljs-keyword">if</span> (operStack.isOper(expression.substring(index + <span class="hljs-number">1</span>, index + <span class="hljs-number">2</span>).charAt(<span class="hljs-number">0</span>))) &#123;<span class="hljs-comment">//如果后一位是运算符</span><br>                       numStack.push(Integer.parseInt(keepNum));<br>                       <span class="hljs-comment">//清空keepNum</span><br>                       keepNum = <span class="hljs-string">&quot;&quot;</span>;<br>                   &#125;<br>               &#125;<br>           &#125;<br>           <span class="hljs-comment">//让index+1并判断是否扫描到expression的最后</span><br>           index++;<br>           <span class="hljs-keyword">if</span>(index&gt;=expression.length())&#123;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>第三步：当表达式扫描完毕以后，就顺序从数栈和符号栈中pop出相应的数和符号，并运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//如果符号栈为空，则计算到最后的结果，数栈中只有一个数字</span><br>            <span class="hljs-keyword">if</span>(operStack.isEmpty())&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                num1=numStack.pop();<br>                num2=numStack.pop();<br>                oper=operStack.pop();<br>                res=numStack.cal(num1,num2,oper);<br>                numStack.push(res);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>最后数栈的栈顶就是最后得到的结果</p><h1 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h1><p>逆波兰表达式为后缀表达式，这种表达式方便计算器求值</p><h3 id="将中缀表达式转后缀表达式"><a href="#将中缀表达式转后缀表达式" class="headerlink" title="将中缀表达式转后缀表达式"></a>将中缀表达式转后缀表达式</h3><p>中缀表达式为a+b<em>c+(d\</em>e+f)*g，转为后缀为: a b c <em> + d e </em> f + g * +</p><p>转换的过程需要栈，操作如下：</p><ol><li>如果遇到操作数，就将其输出</li><li>如果遇到操作符，将其放入栈中，如果遇到左括号也将其放入栈中</li><li>如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出知道遇到左括号为止。<strong>但是左括号只弹出不输出。</strong></li><li>如果遇到任何其他的操作符（”+“，”-“，”（ “）等，从栈中弹出元素直到遇到发现更低级的优先级的元素(或栈空)为止。谈完这些元素后，才将遇到的操作符压入栈中。但是，只有在遇到”）“的情况才会弹出”（“，其他情况不会弹出”（“。</li><li>如果读到了输入的末尾，则将栈中所有元素依次弹出</li></ol><p>主要的函数：将中缀表达式转化为后缀表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">parseSuffixExpressionList</span><span class="hljs-params">(List&lt;String&gt; ls)</span>&#123;<br>        Stack&lt;String&gt; s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<span class="hljs-comment">//符号栈</span><br>        List&lt;String&gt; s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//遍历ls</span><br>        <span class="hljs-keyword">for</span>(String item:ls)&#123;<br>            <span class="hljs-comment">//如果是一个数，加入s2</span><br>            <span class="hljs-keyword">if</span>(item.matches(<span class="hljs-string">&quot;\\d+&quot;</span>))&#123;<br>                s2.add(item);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item.equals(<span class="hljs-string">&quot;(&quot;</span>))&#123;<br>                s1.push(item);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item.equals(<span class="hljs-string">&quot;)&quot;</span>))&#123;<br>                <span class="hljs-comment">//如果是右括号，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br>                <span class="hljs-keyword">while</span>(!s1.peek().equals(<span class="hljs-string">&quot;(&quot;</span>))&#123;<br>                    s2.add(s1.pop());<br>                &#125;<br>                s1.pop();<span class="hljs-comment">//弹出对应的左括号</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//当item的优先级&lt;=栈顶运算符的优先级,将s1栈顶的运算符弹出并加入到s2中</span><br>                <span class="hljs-keyword">while</span>(s1.size()!=<span class="hljs-number">0</span>&amp;&amp;Operation.getValue(s1.peek())&gt;=Operation.getValue(item))&#123;<br>                    s2.add(s1.pop());<br>                &#125;<br>                <span class="hljs-comment">//还需要将item压入s1中</span><br>                s1.push(item);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将s1中剩余的运算符依次加入到s2中</span><br>        <span class="hljs-keyword">while</span>(!s1.isEmpty())&#123;<br>            s2.add(s1.pop());<br>        &#125;<br>        <span class="hljs-comment">//按顺序输出就是后序表达式对应的list</span><br>        <span class="hljs-keyword">return</span> s2;<br>    &#125;<br></code></pre></td></tr></table></figure><p>将中缀表达式的元素保存到集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">toInfixExpression</span><span class="hljs-params">(String s)</span>&#123;<br>        List&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//相当于一个指针，用于遍历s</span><br>        String str;<span class="hljs-comment">//用于多位数的拼接工作</span><br>        <span class="hljs-type">char</span> ch;<span class="hljs-comment">//每遍历到一个字符就放到ch中</span><br>       <span class="hljs-keyword">do</span>&#123;<br>           <span class="hljs-comment">//如果ch为非数字，需要加入到ls中</span><br>           <span class="hljs-keyword">if</span>((ch=s.charAt(i))&lt;<span class="hljs-number">48</span>||(ch=s.charAt(i))&gt;<span class="hljs-number">57</span>)&#123;<br>               list.add(<span class="hljs-string">&quot;&quot;</span>+ch);<br>               i++;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果ch是数字，需要考虑多位数的问题</span><br>               str=<span class="hljs-string">&quot;&quot;</span>;<br>               <span class="hljs-keyword">while</span>(i&lt;s.length()&amp;&amp;(ch=s.charAt(i))&gt;=<span class="hljs-number">48</span>&amp;&amp;(ch=s.charAt(i))&lt;=<span class="hljs-number">57</span>)&#123;<br>                   str+=ch;<span class="hljs-comment">//拼接</span><br>                   i++;<br>               &#125;<br>               list.add(str);<br>           &#125;<br>       &#125;<span class="hljs-keyword">while</span>(i&lt;s.length());<br>       <span class="hljs-keyword">return</span> list;<br>    &#125;<br></code></pre></td></tr></table></figure><p>将后缀表达式放入集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getListString</span><span class="hljs-params">(String suffixExpression)</span>&#123;<br>        <span class="hljs-comment">//将suffixExpression分割</span><br>        String []split=suffixExpression.split(<span class="hljs-string">&quot; &quot;</span>);<br>        List&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">for</span>(String ele:split)&#123;<br>            list.add(ele);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br></code></pre></td></tr></table></figure><p>完成后缀表达式的计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(List&lt;String&gt; ls)</span>&#123;<br>        <span class="hljs-comment">//创建一个栈</span><br>        Stack&lt;String&gt; st=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">//遍历list</span><br>        <span class="hljs-keyword">for</span>(String item:ls)&#123;<br>            <span class="hljs-comment">//使用正则表达式来取出数</span><br>            <span class="hljs-keyword">if</span>(item.matches(<span class="hljs-string">&quot;\\d+&quot;</span>))&#123;<span class="hljs-comment">//匹配的是多位数</span><br>                <span class="hljs-comment">//入栈</span><br>                st.push(item);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//pop出两个数并运算，再入栈</span><br>                <span class="hljs-type">int</span> num2=Integer.parseInt(st.pop());<br>                <span class="hljs-type">int</span> num1=Integer.parseInt(st.pop());<br>                <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(item.equals(<span class="hljs-string">&quot;+&quot;</span>))&#123;<br>                    res=num1+num2;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item.equals(<span class="hljs-string">&quot;-&quot;</span>))&#123;<br>                    res=num1-num2;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item.equals(<span class="hljs-string">&quot;*&quot;</span>))&#123;<br>                    res=num1*num2;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item.equals(<span class="hljs-string">&quot;/&quot;</span>))&#123;<br>                    res=num1/num2;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;运算符有误&quot;</span>);<br>                &#125;<br>                st.push(<span class="hljs-string">&quot;&quot;</span>+res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后留在stack中的数据为运算结果</span><br>        <span class="hljs-keyword">return</span> Integer.parseInt(st.pop());<br></code></pre></td></tr></table></figure><p>正则表达式”\\\d+”匹配的是多位数</p><p>除了通过以上方法将中缀表达式转为后缀表达式，还可以通过栈+二叉树的方式将中缀表达式转化为后缀表达式</p><p>中序遍历为中缀表达式，后序遍历为后缀表达式</p><p>只需要将这棵树后序遍历就能得到后缀表达式</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo-Fluid主题使用数学公式</title>
    <link href="/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <url>/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本人使用hexo+github搭建博客，使用<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide">Fliud主题</a></p><p>另外在本页将常用的数学公式和数学符号记录下来</p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><ol><li><p>在fulid的配置文件/themes/fluid/_config.yml设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br> <span class="hljs-attr">math:</span><br>   <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <span class="hljs-attr">engine:</span> <span class="hljs-string">katex</span><br></code></pre></td></tr></table></figure><img src="/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/image-20220902140632787.png" class title="image-20220902140632787"></li><li><p>更换markdown渲染器</p><p>卸载原有的markdown渲染器：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后根据上方配置的不同的<strong>engine</strong>，更换渲染器，这里选择katex:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">npm</span> install @upupming/hexo-renderer-markdown-<span class="hljs-literal">it</span>-plus --save<br></code></pre></td></tr></table></figure></li><li><p>安装完成后执行hexo clean</p></li></ol><h1 id="常用数学符号"><a href="#常用数学符号" class="headerlink" title="常用数学符号"></a>常用数学符号</h1><h4 id><a href="#" class="headerlink" title></a><img src="/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/2018041621294865.png" class width="2018041621294865"></h4><script type="math/tex; mode=display">\alpha</script><img src="/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/20180416213036844.png" class width="20180416213036844"><img src="/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/20180416213119987.png" class width="20180416213119987"><img src="/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/20180416213126857.png" class width="20180416213126857"><h1 id="行内数学公式"><a href="#行内数学公式" class="headerlink" title="行内数学公式"></a>行内数学公式</h1><ol><li><p>Typora左上角工具栏偏好设置</p><img src="/2022/09/02/%E5%85%B6%E4%BB%96/hexo-Fluid%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/image-20220902143619303.png" class title="image-20220902143619303"><p>设置完之后一定记得重启</p></li><li><p>输入的语法格式为：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>\delta<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>写下一个$后按Esc会补上另一个，在两个  $ 之间写数学公式</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo搭建博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章-信息的表示和处理</title>
    <link href="/2022/09/02/CSAPP/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <url>/2022/09/02/CSAPP/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p><strong>字节</strong>：8位的块，最小的可寻址的内存单位</p><p><strong>虚拟内存</strong>：机器级程序将内存视为一个非常大的字节数组，称为虚拟内存</p><p><strong>虚拟地址空间</strong>：所有可能地址的集合，这只是展现给机器级程序的概念性映像</p><h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>主要见数字逻辑中，二进制与十六进制互相转换的方法</p><h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><p>每台计算机都有一个字长，指明<em>指针数据的标称大小</em>，字长决定的最重要的系统参数就是<strong>虚拟地址空间的最大大小</strong></p><p>程序prog.c用如下伪指令编译后，可以在64位或32位机器上正确运行</p><p>64位机器的指针类型长度为8字节</p><figure class="highlight llvm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs llvm">linux&gt; gcc -m<span class="hljs-number">32</span> prog.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>但是用如下只能在64位机器上正确运行</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">linux&gt; gcc -m<span class="hljs-number">64</span> prog.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>“XX位程序”指的是该程序时如何编译的，而不是其运行的机器类型</p><h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>跨越多字节的程序对象，必须建立两个原则：</p><ul><li>这个对象的地址是什么</li><li>在内存中如何排列这些字节</li></ul><p>多字节的对象一般存储为连续的字节序列，对象的地址为使用字节中的最小的地址</p><p><strong>小端法</strong>：某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象</p><p><strong>大端法</strong>：从最高有效字节到最低有效字节的顺序存储对象</p><p>大多数Intel都是小端法</p><h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>文本数据比二进制数据具有更强的平台独立性</p><h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><p>不同的机器类型使用不同的且不兼容的指令和编码方式。</p><p>二进制代码很少能在不同机器和操作系统组合之间移植</p><h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><p>与（ $\&amp;$ ）、或（|）、非（~）、异或（$\oplus$），见数字逻辑</p><p>位向量就是固定长度为$\omega$、由0和1组成的串。</p><p>位向量的运算可以定义成每个对应元素之间的运算。</p><p>设$a、b$分别为位向量$[a_{\omega-1},a_{\omega-2},···,a_0]$和$[b_{\omega-1},b_{\omega-2},···,b_0]$,可以将$a\&amp;b$定义成一个长度为$\omega$的位向量</p><p> 可以使用位向量$[a_{\omega-1},a_{\omega-2},···,a_0]$编码任何一个子集$A\subseteq \{0,1,···,\omega-1\}$  ,$a_(\omega-1)$放在左边，而$a_0$写在右边 ，而位向量$a=[01101001]$表示集合$A=\{0,3,5,6\}$，这种编码集合的方式，<strong>布尔运算$|$和$\&amp;$分别对应集合的并和交</strong>，而~对应集合的补</p><h3 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h3><p>确定一个位级表达式最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制</p><p>位级运算的常见用法就是实现<strong>掩码计算</strong>，这里掩码是一个位模式，表示从一个字中选出的位的集合。如掩码0xFF（最低的8位为1）表示一个字的最低位字节，位级运算x$\&amp;$0xFF生成一个由x的最低有效字节组成的值，而其他字节被置为0</p><h3 id="C语言中的逻辑运算"><a href="#C语言中的逻辑运算" class="headerlink" title="C语言中的逻辑运算"></a>C语言中的逻辑运算</h3><p>||、&amp;&amp;、！不要混淆</p><h3 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h3><ul><li><p>左移：</p><script type="math/tex; mode=display">[x_{\omega-1},x_{\omega-2},···,x_0]左移k位变成[x_{\omega-k-1},x_{\omega-k-2},···,x_0,0,···,0]</script><p>x向左移动k位，丢弃最高的k位，并在右端补k个0</p></li><li><p>右移</p><ul><li><p>算术右移</p><p>在左端补k个最高有效位的值，如最高有效位为1，补1</p></li><li><p>逻辑右移</p><p>在左端补0</p></li></ul><p>java中定义x&gt;&gt;k会对x做算术单位，x&gt;&gt;&gt;k会对x做逻辑右移</p></li></ul><h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><img src="/2022/09/02/CSAPP/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20220902153208373.png" class title="image-20220902153208373"><h3 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h3><p>long唯一一个与机器相关的大小指示符</p><p>正数与负数不对称</p><h3 id="无符号编码"><a href="#无符号编码" class="headerlink" title="无符号编码"></a>无符号编码</h3><script type="math/tex; mode=display">B2U_\omega(\overrightarrow{x})\doteq\sum_{i=0}^{\omega-1}x_i2^i</script><p>函数$B2U_\omega$是一个双射，原理：无符号数编码的唯一性</p><h3 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h3><p>最高有效位$x_\omega-1$称为符号位，权重为$-2^{\omega-1}$</p><script type="math/tex; mode=display">B2T_\omega(\overrightarrow{x})\doteq-x_{\omega-1}2^{\omega-1}+\sum_{i=0}^{\omega-2}x_i2^i</script><p>函数$B2T_\omega$是一个双射，原理：补码编码的唯一性</p><p>补码范围是不对称的：$|TMin|=|TMax|+1$ ，$|TMin|$没有对应的正数</p><p>最大的无符号数值刚刚好比补码的最大值的两倍大一点$UMax_\omega=2TMax_\omega+1$ </p><h3 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h3><p>处理同样子长的有符号数和无符号数之间相互转换的一般表现：数值可能变，但是位模式不变</p><h4 id="补码转化位无符号数"><a href="#补码转化位无符号数" class="headerlink" title="补码转化位无符号数"></a>补码转化位无符号数</h4><p>对于满足$ TMin_\omega\leqslant x \leqslant TMax_\omega$ 的$x$ 有:</p><script type="math/tex; mode=display">T2U_\omega= \left\{\begin{aligned}x+2^\omega  {x < 0}\\x  \ \ \ {x\geqslant0}\end{aligned}\right.</script><p>推导：补码转化为无符号数</p><script type="math/tex; mode=display">B2U_\omega(\overrightarrow{x})-B2T(\overrightarrow{x})=x_{\omega-1}2^\omega</script><p>所以得到一个关系</p><script type="math/tex; mode=display">B2U_\omega(\overrightarrow{x})=x_{\omega-1}2^\omega+B2T_\omega(\overrightarrow{x})</script><p>因此</p><script type="math/tex; mode=display">B2U_\omega(T2B_\omega(x))=T2U_\omega(x)=x+x_{\omega-1}2^\omega</script><img src="/2022/09/02/CSAPP/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20220903220738262.png" class title="image-20220903220738262"><p>当一个有符号数映射为它相应的无符号数时，负数被转换成大的正数，而非负数会保持不变</p><h4 id="无符号数转化为补码"><a href="#无符号数转化为补码" class="headerlink" title="无符号数转化为补码"></a>无符号数转化为补码</h4><p>对满足$0\leqslant u \leqslant UMax_\omega$ 的$u$有：</p><script type="math/tex; mode=display">U2T_\omega(u)=\left\{\begin{aligned}u \ \ \ {u\leqslant TMax_\omega}\\u-2^\omega {u >TMax_\omega}\end{aligned}\right.</script><p>推导：无符号数转换为补码</p><p>根据两个编码公式可以推导得：</p><script type="math/tex; mode=display">U2T_\omega(u)=-u_{\omega-1}2^\omega+u</script><img src="/2022/09/02/CSAPP/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20220903222111889.png" class title="image-20220903222111889"><p>上图说明对于小的数（$\leqslant TMax_\omega$），从无符号到有符号的转换保留数字原值。对于大的数($&gt;TMax_\omega$)，数字将被转换为一个负数值</p><h3 id="C语言中的有符号数与无符号数"><a href="#C语言中的有符号数与无符号数" class="headerlink" title="C语言中的有符号数与无符号数"></a>C语言中的有符号数与无符号数</h3><p>当执行一个运算时，如果它的一个运算数是有符号的，但是另一个无符号，C语言会隐式地将有符号参数强制转换为无符号数，并且假设这两个数都是非负的，来执行这个运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">sun_elements</span><span class="hljs-params">(<span class="hljs-type">float</span> a[],<span class="hljs-type">unsigned</span> length)</span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">float</span> result=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,i&lt;=length<span class="hljs-number">-1</span>;i++)&#123;<br>result+=a[i];<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>上段代码unsigned类型的length-1，得到的结果为无符号的-1，对应$UMax$，会造成数组越界</p><h3 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h3><p><strong>零扩展</strong>：将一个无符号数转换为一个更大的数据类型，只要在开头添加0就行</p><p>宽度为$\omega$的位向量$\overrightarrow{u}=[u_{\omega-1},u_{\omega-2},···,u_0]$和宽度为$\omega’$的位向量$\overrightarrow{u’}=[0,··,0,u_{\omega-1},u_{\omega-2},···,u_0]$，其中$\omega’&gt;\omega$。则$B2U_\omega(\overrightarrow{u})=B2U_{\omega’}(\overrightarrow{u’})$</p><p>要将一个补码数字转换为一个更大的数据类型，可以执行<strong>符号扩展</strong>，在开头补符号位</p><p>宽度为$\omega$的位向量$\overrightarrow{x}=[x_{\omega-1},x_{\omega-2},···,x_0]$和宽度为$\omega’$的位向量$\overrightarrow{x’}=[x_{\omega’-1},··,0,x_{\omega-1},x_{\omega-2},···,x_0]$，其中$\omega’&gt;\omega$。则$B2U_\omega(\overrightarrow{x})=B2U_{\omega’}(\overrightarrow{x’})$</p><p>证明用数学归纳法</p><p>在C语言中，把short转化为unsigned时，要先改变大小再从有符号转化为无符号</p><h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p><strong>截断</strong>：将一个$\omega$位的数$\overrightarrow{x}=[x_{\omega-1},x_{\omega-2},···,x_0]$截断为一个$k$位数字时，丢弃高$\omega-k$位，得到一个位向量$\overrightarrow{x’}=[x_{k-1},x_{x-2},···,x_0]$，截断数字很可能改变它的值</p><p><strong>截断无符号数</strong>：令$\overrightarrow{x}=[x_{\omega-1},x_{\omega-2},···,x_0]$，而$\overrightarrow{x’}$是将其截断$k$位的结果，$\overrightarrow{x’}=[x_{k-1},x_{x-2},···,x_0]$，令$x=B2U_\omega(\overrightarrow{x}),x’=B2U_k(\overrightarrow{x’}),则x’=x mod 2^k$</p><p>推导利用属性，对于任何的$i\geq k，2^i mod 2^k=0$</p><p><strong>补码截断</strong>：将最高位转换为符号位，令$\overrightarrow{x}=[x_{\omega-1},x_{\omega-2},···,x_0]$，而$\overrightarrow{x’}$是将其截断$k$位的结果，$\overrightarrow{x’}=[x_{k-1},x_{x-2},···,x_0]$，令$x=B2U_\omega(\overrightarrow{x}),x’=B2T_k(\overrightarrow{x’}),则x’=U2T_k(xmod2^k)$</p><p>推导利用函数$U2T_k$产生的效果是把最高有效位$x_{k-1}$的权重从$2^{k-1}$转变为$-2^{k-1}$</p><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><h3 id="无符号数加法"><a href="#无符号数加法" class="headerlink" title="无符号数加法"></a>无符号数加法</h3><p>定义运算 $^{u}_{\omega}+$ 其中$0\leqslant x ,y\leqslant 2^\omega$  ，该操作是把整数和x+y截断为$\omega$位得到的结果</p><p><strong>$^{u}_{\omega}+$ 描述</strong>：</p><p>对满足$0\leqslant x ,y\leqslant 2^\omega$ 的$x$和$y$有：</p><script type="math/tex; mode=display">x+^{u}_{\omega}y =\left\{\begin{aligned}x+y, \ \ \ \ \ {x+y<2^\omega}\\x+y-2^\omega, \ \ \ \ \ \ {2^\omega\leqslant x+y<2^{\omega+1}}\end{aligned}\right.</script><p>推导：如果$x+y&lt;2^\omega$ ，和的$\omega+1$位表示中的最高位会等于0，因此不会改变这个数的值；而$2^\omega\leqslant x+y&lt;2^{\omega+1}$ ，和的$\omega+1$位表示中的最高位会减去1，丢弃$2^\omega$</p><p><strong>检测无符号数加法中的溢出</strong>：</p><p>在对范围$0\leqslant x,y \leqslant UMax_\omega$ 中的$x$和$y$，令$s=x+^{u}_{\omega}y$ ，则对计算s，当且仅当$s&lt;x$时，发生了溢出</p><p><strong>无符号数求反</strong>：</p><p>对满足$0\leqslant x&lt;2^\omega$ 的任意$x$，其$\omega$位的无符号逆元$-^{u}_{\omega}x$由下式给出：</p><script type="math/tex; mode=display">-^{u}_{\omega}x=\left\{\begin{aligned}x,{x=0}\\2^{\omega}-x,{x>0}\end{aligned}\right.</script><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p><strong>补码加法</strong>：</p><p>对满足$-2^{\omega-1}\leqslant x,y\leqslant 2^{\omega-1}-1$的整数$x,y$，有：</p><script type="math/tex; mode=display">x+^{t}_{\omega}y=\left\{\begin{aligned}x+y-2^\omega ,{2^{\omega-1}\leqslant x+y} \  {负溢出}\\x+y,{-2^{\omega-1}\leqslant x+y<2^{\omega-1}} {正常}\\x+y+2^\omega,{x+y<-2^{\omega-1}} {负溢出}\end{aligned}\right.</script><p><strong>检测补码加法中的溢出</strong>：</p><p>对满足$TMin_\omega \leqslant x,y \leqslant TMax_\omega$的$x$和$y$，令$s\doteq x+^{t}_{\omega}y$，当且仅当$x&gt;0,y&gt;0$，但$s\leqslant 0$时，计算$s$发生了正溢出。当且仅当$x&lt;0,y&lt;0$，但$s\geqslant 0$时，计算$s$发生了负溢出</p><h3 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h3><p><strong>补码的非</strong>：</p><p>对满足$TMin_\omega \leqslant x\leqslant TMax_\omega$ 的$x$ ，其补码的非$-^{t}_{\omega}x$由下式给出:</p><script type="math/tex; mode=display">-^{t}_{\omega}x=\left\{\begin{aligned}TMin_\omega,{x=TMin_\omega}\\-x,{x>TMin_\omega}\end{aligned}\right.</script><h3 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h3><p>范围在$0 \leqslant x,y\leqslant 2^\omega-1$内的整数$x$和$y$，它们的乘法取值范围$0$到$(2^\omega-1)^2=2^{2\omega}-2^{\omega+1}+1$之间，这可能需要$2\omega$位来表示</p><p>但是C语言无符号乘法定义为产生$\omega$位的值，所以$2\omega$位到$\omega$位的值将被截断</p><p><strong>无符号乘法</strong>:</p><p>对满足的$0 \leqslant x,y \leqslant UMax_\omega$的$x$和$y$有：</p><script type="math/tex; mode=display">x*^{u}_{\omega}y=(x·y)mod 2^\omega</script><h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><p>将一个补码数截断位$\omega$位相当于先计算该值模$2\omega$，再把无符号数转换为补码</p><p><strong>补码乘法</strong>：</p><p>对满足$TMin_\omega\leqslant x,y \leqslant TMax_\omega$的$x$和$y$有：</p><script type="math/tex; mode=display">x*^{t}_{\omega}y=U2T_\omega((x*y)\ mod\ 2^\omega)</script><p><strong>无符号和补码乘法的位级等价性</strong>：</p><p>给定长度位$\omega$的位向量$\overrightarrow{x}$和$\overrightarrow{y}$，用补码的形式的位向量表示来定义整数$x$和$y$：$x=B2T_\omega(\overrightarrow{x}),y=B2T_\omega(\overrightarrow{y})$ 。用无符号形式的位向量来定义非负整数$x’$和$y’$：$x’=B2U_\omega(\overrightarrow{x}),y’=B2U_\omega(\overrightarrow{y})$，则：</p><script type="math/tex; mode=display">T2B_\omega(x*^{t}_{\omega}y)=U2B_\omega(x'*^{u}_{\omega}y')</script><h3 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h3><h4 id="乘以2的幂"><a href="#乘以2的幂" class="headerlink" title="乘以2的幂"></a>乘以2的幂</h4><p>以$x$为位模式$[x_{\omega-1},x_{\omega-2},···,x_0]$表示的无符号整数，对于任何的$k\geqslant0$ 都认为$[x_{\omega-1},x_{\omega-2},···,x_0,0,···,0]$给出了$x2^\omega$的$\omega+k$位的无符号表示，这里右边加了$k$个0</p><p>左移一个数值等价于执行一个与2的幂相乘的无符号乘法</p><h4 id="与2的幂相乘的无符号乘法"><a href="#与2的幂相乘的无符号乘法" class="headerlink" title="与2的幂相乘的无符号乘法"></a>与2的幂相乘的无符号乘法</h4><p>C变量$x$和$k$有无符号数值$x$和$k$，且$0\leqslant k &lt;\omega$，则C表达式$x&lt;&lt;k$产生数值$x*^{u}_{\omega}2^k$ </p><h4 id="与2的幂相乘的补码乘法"><a href="#与2的幂相乘的补码乘法" class="headerlink" title="与2的幂相乘的补码乘法"></a>与2的幂相乘的补码乘法</h4><p>C变量$x$和$k$有补码值$x$和无符号数值$k$，且$0\leqslant k &lt;\omega$，则C表达式$x&lt;&lt;k$产生数值$x*^{t}_{\omega}2^k$ </p><p>注意都可能导致溢出，C编译器试图以移位、加法、减法来分解乘法，因为乘法代价更大</p><h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>使用右移，无符号和补码数分别使用逻辑移位和算术移位</p><h4 id="除以2的幂的无符号除法"><a href="#除以2的幂的无符号除法" class="headerlink" title="除以2的幂的无符号除法"></a>除以2的幂的无符号除法</h4><p>C变量$x$和$k$有无符号数值$x$和$k$，且$0\leqslant k &lt;\omega$，则C表达式$x&gt;&gt;k$产生数值$[x/ 2^k]$ </p><h4 id="除以2的幂的补码除法，向下取舍"><a href="#除以2的幂的补码除法，向下取舍" class="headerlink" title="除以2的幂的补码除法，向下取舍"></a>除以2的幂的补码除法，向下取舍</h4><p>C变量$x$和$k$有补码值$x$和无符号数值$k$，且$0\leqslant k &lt;\omega$，当执行算术移位时，C表达式产生数值$[x/2^k]$</p><h4 id="除以2的幂的补码除法，向上舍入"><a href="#除以2的幂的补码除法，向上舍入" class="headerlink" title="除以2的幂的补码除法，向上舍入"></a>除以2的幂的补码除法，向上舍入</h4><p>C变量$x$和$k$有补码值$x$和无符号数值$k$，且$0\leqslant k &lt;\omega$，当执行算术移位时，C表达式$(x+(1&lt;<k)-1)>&gt;k$产生数值$[x/2^k]$</k)-1)></p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>IEEE754浮点标准用$V=(-1)^s <em> (1.M)</em>2^e$的形式表示浮点数的真值</p><p>e=E-bias，bias在32位表示时为127，在64位表示时为1023</p><ul><li>符号：$s$决定是负数($s=1$)还是正数($s=0$)，而对于数值0的符号位解释作为特殊情况处理</li><li>尾数域值是$1.M$。规格化的浮点数的尾数域最左边总是1，这一位不予存储，认为隐藏在小数点最左边。</li><li>在计算指数 e 时，对阶码E的计算采用原码的计算方式，因此 32 位浮点数的 8bits 的阶码 E 的取值范围是 0 到 255</li></ul><img src="/2022/09/02/CSAPP/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20220904145425862.png" class title="image-20220904145425862"><img src="/2022/09/02/CSAPP/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/image-20220904145501200.png" class title="image-20220904145501200"><h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4><p>移码一般用作浮点数的阶码，便于浮点数运算时的对阶操作</p><p>原码：将十进制转化成二进制</p><p>反码：正数反码等于原码，负数的反码等于除符号位剩余位取反</p><p>补码：正数补码等于原码，负数反码符号位不变，反码最低位加1</p><p><strong>移码</strong>：将补码的符号位取反，得到移码</p><h3 id="十进制转机器码"><a href="#十进制转机器码" class="headerlink" title="十进制转机器码"></a>十进制转机器码</h3><p>-12.5转单精度浮点数</p><p>-12.5=$[-1100.1]_2$ ,符号位为1，小数点向左移动三位，变成1.xxx这种形式，所以指数e=3，尾数为1.1001.</p><p>尾数域M右侧以0补全得到尾数域$M=[100\ 1000\ 0000 \ 0000 \ 0000\ 0000]_2$共23位</p><p>阶码E：E=e-1=$[3]_移-1$=$[1000\ 0011]_2-1$=$[1000\ 0010]_2$</p><p>加上符号位S，最后的到32位浮点数：</p><script type="math/tex; mode=display">[1100\ 0001\ 0100\ 1000\ 0000\ 0000\ 0000\ 0000]_2</script><p>1.5转单精度浮点数：</p><p>1.5=$[1.1]_2$，小数点不需要移动，e=0；正数，S=0；尾数位1.1.</p><p>尾数域M右侧以0补全得到尾数域$M=[100\ 0000\ 0000\ 0000\ 0000\ 0000]$共23位</p><p>阶码E:E=e-1=$[0]_移-1$=$[1000\ 0000]_2-1$=$[0111\ 1110]_2$</p><p>加上符号位，得到的32位浮点数：</p><script type="math/tex; mode=display">[0011\ 1111\ 0100\ 0000\ 0000\ 0000\ 0000\ 0000]_2</script><h3 id="机器码转十进制"><a href="#机器码转十进制" class="headerlink" title="机器码转十进制"></a>机器码转十进制</h3><p>例：</p><script type="math/tex; mode=display">[0\ 10000010\ 011\ 0110\ 0000\ 0000\ 0000\ 0000]_2</script><p>符号位0，表正数。</p><p>尾数域$[011\ 0110\ 0000\ 0000\ 0000\ 0000]_2$，加上左边隐藏位1，1.M得$1.011011$</p><p>阶码E=$[1000\ 0010]_2$，可以由阶码-127（双精度为1023）=指数，获得指数；也可以通过阶码+1=移码，通过移码获得补码来获得指数。阶码+1=$[1000\ 0011]_移$，移码换位补码为$[0000\ 0011]_补$，最终得e=3</p><p>最后$x=(-1)^s<em>(1.M)</em>2^e$=$+(1.011011)*2^3$</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><h4 id="0"><a href="#0" class="headerlink" title="0"></a>0</h4><p>如果阶码E=0并且尾数M是0，则这个数的真值为$\pm0$</p><p>+0的机器码为：$[0\ 00000000\ 000\ 0000\ 0000\ 0000\ 0000\ 0000]_2$</p><p>-0的机器码为：$[1\ 00000000\ 000\ 0000\ 0000\ 0000\ 0000\ 0000]_2$</p><h4 id="infty-和-infty"><a href="#infty-和-infty" class="headerlink" title="$+\infty$和$-\infty$"></a>$+\infty$和$-\infty$</h4><p>如果阶码E=255并且尾数M全是0，则这个真值为$\pm\infty$ </p><p>$+\infty$的机器码为：$[0\ 1111111\ 000\ 0000\ 0000\ 0000\ 0000\ 0000]_2$</p><p>$-\infty$的机器码为：$[1\ 1111111\ 000\ 0000\ 0000\ 0000\ 0000\ 0000]_2$</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决：hexo+github本地和线上图片不显示的问题</title>
    <link href="/2022/09/01/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3%EF%BC%9Ahexo-github%E6%9C%AC%E5%9C%B0%E5%92%8C%E7%BA%BF%E4%B8%8A%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/01/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3%EF%BC%9Ahexo-github%E6%9C%AC%E5%9C%B0%E5%92%8C%E7%BA%BF%E4%B8%8A%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>hexo+github搭建博客之后，使用markdown语法发布的图片无法正常显示，这是因为hexo和markdown图片插入语法不同导致的，</p><p>hexo语法为：</p><figure class="highlight django"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_img</span> 图片名称 %&#125;</span><br></code></pre></td></tr></table></figure><p>markdown语法为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[图片名称]</span>(图片位置)<br></code></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li><p>在Typora的偏好设置中设置<img src="/2022/09/01/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3%EF%BC%9Ahexo-github%E6%9C%AC%E5%9C%B0%E5%92%8C%E7%BA%BF%E4%B8%8A%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/image-20220901224329268.png" class title="image-20220901224329268"></p><p>表示引用图片会从当前目录下寻找同名文件夹下的图片</p></li><li><p>在blog根目录下，修改_config.yml中的post_asset_folder，false修改为true，这样修改后就会每次使用指令</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p>时，都会在文章文件同级目录创建一个与文章名称同名的文件夹，在此存放文章的图片</p></li><li><p>安装插件hexo-asset-img：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">npm install hexo-asset-<span class="hljs-selector-tag">img</span> <span class="hljs-attr">--save</span><br>hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><p>这样就可以了</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo搭建博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章-计算机系统漫游</title>
    <link href="/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <url>/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="信息就是-位-上下文"><a href="#信息就是-位-上下文" class="headerlink" title="信息就是 位+上下文"></a>信息就是 位+上下文</h1><p>每条C语言程序都必须被其他程序转化为一系列的<em>低级机器语言</em>，然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打包，并以二进制磁盘文件的形式存放起来，目标程序也称为<strong>可执行目标文件</strong></p><p><em>hello.c</em>转化为可执行文件分为四个阶段：</p><ol><li><strong>预处理</strong>：<em>预处理器</em> 根据预编译头（如<em>#include&lt;stdio.h</em>&gt;），然后读取系统头文件的内容，并将其直接插入到程序文本中，得到.i后缀的文件</li><li><strong>编译阶段</strong>：<em>编译器</em> 将.i后缀的文件编译为.s为后缀的文本文件，包含一个汇编语言程序</li><li><strong>汇编阶段</strong>：<em>汇编器</em> 将.s后缀的文件翻译成机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>的格式，并将结果保存在.o为后缀的二进制文件中</li><li><strong>链接阶段</strong>：C语言库函数存在于一个.o为后缀的单独的预编译好的文件中，<em>链接器</em> 负责合并该文件与总的文件中。最终得到<strong>可执行文件</strong>，可以被加载到内存中，由系统执行</li></ol><h1 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h1><ul><li><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>贯穿于整个系统的一组电子管道，它负责携带信息字节并负责在各个部件间传递。<strong>总线被设计成传送定长的字节块</strong>，称为字，字的大小在明确定义的上下文中说明</p></li><li><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><p>系统与外部世界的联系通道，每一个I/O设备通过一个控制器或适配器与I/O总线相连。</p><p>控制器与适配器的区别是它们的封装方式</p></li><li><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p><p>从物理上来说，是由一组<strong><em>动态随机存取存储区（DRAM）</em></strong>芯片组成的。</p><p>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有唯一的地址</p></li><li><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p><em>中央处理单元（CPU）</em> ，简称处理器，是解释、执行存储在主存中的指令的引擎。</p><p>处理器的核心是一个大小为一个字的存储设备（或寄存器），称为<em>程序计数器（PC）</em></p><p>PC在任何时刻都会指向主存中某条机器语言指令</p><p>处理器是由<strong>指令集架构</strong>决定的模型决定的。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令的简单操作，然后更新PC，使其指向下一条指令</p></li></ul><p>上述操作围绕<strong>主存</strong>、<strong>寄存器文件</strong>和<strong>算术/逻辑单元（ALU）</strong>进行。</p><p>寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。</p><p>ALU计算新的数据和地址值。</p><p>CPU在指令的要求下可能执行的操作：</p><ul><li><strong>加载</strong>：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容</li><li><strong>存储</strong>：从寄存器复制一个字节或者一个字到主存中的某个位置，以覆盖这个位置上原来的内容</li><li><strong>操作</strong>：两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到寄存器中，以覆盖该寄存器中的原来的内容</li><li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制PC中，以覆盖PC中原来的值</li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>程序的机器指令最初是存放到磁盘上的，当程序加载时，它们被复制到主存中；</p><p>当处理器运行程序时，指令又从主存复制到处理器；</p><p>数据串开始时在磁盘上，然后被复制到主存中，最后从主存复制到显示设备。</p><p>以上复制就是开销，减缓程序真正的工作。</p><p>根据机械原理，较大的存储设备要比较小的存储设备运行的慢，而快速设备的造价远高于同类的低俗设备。类似，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几亿字节的信息。而处理器从寄存器文件中读取数据比从主存中读取几乎要快100倍。</p><p>针对处理器与主存之间的差异，采用<strong>高速缓存存储器</strong>，简称cache或高速缓存。</p><p>L1高速缓存位于处理器芯片上，容量可达数万字节，访问速度几乎和访问寄存器文件一样快。</p><p>L2高速缓存通过一条特殊的总线连接到处理器，容量位数十万到数百万字节，比L1访问时间长5倍。</p><p>L1和L2高速缓存是用一种<strong>静态随机访问存储器（SRAM）</strong>的硬件技术实现的</p><h3 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h3><img src="/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/image-20220901203132507.png" class title="image-20220901203132507"><p>存储器层次就够的主要思想是上一层的存储器作为低一层存储器的高速缓存。</p><h1 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h1><p>操作系统的两个基本功能：</p><ul><li><p>防止硬件被失控的应用程序滥用；</p></li><li><p>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备</p></li></ul><p>操作系统通过几个基本的抽象的概念：</p><ul><li><strong>文件</strong>：对I/O设备的抽象表示</li><li><strong>虚拟内存</strong>：对主存和磁盘I/O设备的抽象表示</li><li><strong>进程</strong>：对处理器、主存、I/O设备的抽象表示、</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象。</p><p>一个系统可以运行多个进程，每个进程并发运行，每个进程的指令都是交替进行的</p><p>大多数系统，需要运行的进程数大于可以多于运行它们的CPU个数</p><p><strong>上下文切换</strong>：操作系统实现交错执行的机制，一个CPU可以看上去并发执行多个进程。即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递给新进程</p><p><strong>上下文</strong>：操作系统保持跟踪进程运行的所有状态信息（包括PC和寄存器文件的当前值），这种状态为上下文</p><p>在任何时候，单处理器系统都只能执行一个进程的代码</p><p><strong>内核</strong>：操作系统代码常驻主存的部分，从一个进程到另一个内核的转换是由它完成的。</p><p>当应用程序需要操作系统的某些操作时，内核就执行一条特殊的<em>系统调用</em> 指令，将控制权传递给内核，然后执行被请求的操作并返回应用程序。</p><p>内核不是一个独立的进程，是系统管理全部进程所用代码和数据结构的集合</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程由多个线程组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>是抽象概念，它为每个进程提供了一种假象，即每个进程都在独占地使用主存。</p><p>每个进程看到的内存是一致的，称为<em>虚拟地址空间</em></p><p>linux进程的虚拟地址空间：地址从下往上增大<img src="/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/image-20220901212311906.png" class title="image-20220901212311906"></p><p>内核虚拟内存不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数</p><p>虚拟内存运作的基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件就是字节序列。</p><p>系统中所有输入输出都是通过使用一小组的称为Unix I/O的系统调用函数读写文件来实现的</p><h1 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h1><p>见计算机网络</p><h1 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h1><p>主要思想：当我们对系统的某一部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度</p><img src="/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/image-20220901213856413.png" class title="image-20220901213856413"><img src="/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/image-20220901213914144.png" class title="image-20220901213914144"><h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>并发：通用的概念，一个同时具有多个活动的系统</p><p>并行：用并发来使一个系统运行得更快</p><h3 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h3><ul><li><p><strong>多核处理器</strong>：将多个CPU集成到一个集成电路芯片上</p><img src="/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/image-20220901215311312.png" class title="image-20220901215311312"></li><li><p><strong>超线程</strong>：一项允许一个CPU执行多个控制流的技术。</p><p>设计CPU某些硬件有多个备份如程序计数器和寄存器文件。超线程的处理器可以在单个周期的基础上决定要执行哪一个线程</p><p>可以在两方面提高系统性能：</p><ul><li>减少了在执行多个任务时模拟并发的需要</li><li>使应用程序运行的更快</li></ul></li></ul><h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><p>现代处理器可以同时执行多条指令的属性为指令级并行</p><h3 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h3><p>现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式为单指令、多数据</p><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><img src="/2022/09/01/CSAPP/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/image-20220901221222775.png" class title="image-20220901221222775">]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lab0</title>
    <link href="/2022/06/27/cs61b/lab0/"/>
    <url>/2022/06/27/cs61b/lab0/</url>
    
    <content type="html"><![CDATA[<p>使用自己的虚拟机，将课程的<a href="https://github.com/CS144/sponge">仓库代码</a>拉取到本地，用vscode远程连接</p><p>不需要他提供的镜像，进入sponge</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">mkdir build<br>cd build<br>cmake ..<br>make<br></code></pre></td></tr></table></figure><p> 然后剩下一些telnet等操作不写了，这个看lab就可以</p><h1 id="web-get"><a href="#web-get" class="headerlink" title="web_get"></a>web_get</h1>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2022/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2022/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="数据平面-每台路由器的功能"><a href="#数据平面-每台路由器的功能" class="headerlink" title="数据平面(每台路由器的功能)"></a>数据平面(每台路由器的功能)</h1><p>数据平面功能决定到达路由器输入链路之一的数据报如何转发到该路由器的输出链路之一</p><p><strong>转发</strong> 是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作<br><strong>路由选择</strong> 是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程 </p><h1 id="控制平面-网络范围的逻辑"><a href="#控制平面-网络范围的逻辑" class="headerlink" title="控制平面(网络范围的逻辑)"></a>控制平面(网络范围的逻辑)</h1><p>控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据链路</title>
    <link href="/2022/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/"/>
    <url>/2022/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范</strong><br>通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>MAC地址用于识别数据链路中互连的节点<br>MAC地址长48比特，任何一个网卡的MAC地址都是唯一的<br><img src="/2022/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/MAC%E5%9C%B0%E5%9D%80.png" class></p><h2 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h2><p><strong>共享介质型网络是指由多个设备共享一个通信介质的一种网络</strong>，有两种介质访问控制方式：争用方式和令牌传递方式</p><h3 id="争用方式"><a href="#争用方式" class="headerlink" title="争用方式"></a>争用方式</h3><p>争夺获取数据传输的权力，也叫CSMA，采用先到先得的方式占用信道发送数据<br>改良CSMA另一种方式——CSMA/CD</p><ul><li>如果载波信道上没有数据流动，任何站可以发送数据</li><li>检查是否会发生冲突。一旦发生冲突，放弃发送数据，同时立即释放载波信道</li><li>放弃发送后，随机延时一段时间，再重新争用介质，重新发送帧</li></ul><h3 id="令牌传递方式"><a href="#令牌传递方式" class="headerlink" title="令牌传递方式"></a>令牌传递方式</h3><p>只有获得令牌的站才能发送数据，有两个特点：</p><ul><li>不会有冲突</li><li>每个站都有通过平等循环获得令牌的机会</li></ul><h2 id="非共享介质网络"><a href="#非共享介质网络" class="headerlink" title="非共享介质网络"></a>非共享介质网络</h2><p>网络中的每个站直连交换机，由交换机负责转发数据帧<br>并且交换机的端口与计算机之间可以实现同时收发的全双工通信<br><img src="/2022/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/%E9%9D%9E%E5%85%B1%E4%BA%AB%E4%BB%8B%E8%B4%A8%E7%BD%91%E7%BB%9C.png" class></p><h2 id="根据MAC地址转发"><a href="#根据MAC地址转发" class="headerlink" title="根据MAC地址转发"></a>根据MAC地址转发</h2><p><strong>以太网交换机就是持有多个端口的网桥</strong>，此处端口不是操作系统的端口。它们根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。<strong>所参考的，用以记录发送接口的表叫做转发表</strong><br>转发表内容可以自动生成，又叫<strong>自学过程</strong><br><img src="/2022/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6.png" class><br>当连接多个终端时，有必要讲网络分成多个数据链路，采用类似于网络层的IP地址一样对地址进行分层管理<br><strong>交换机转发方式</strong>：</p><ul><li>存储转发：检查以太网数据帧末尾的FCS位后再进行转发，可以避免由于冲突而被破坏的帧或噪声导致的错误帧</li><li>直通转发：不需要将整个帧全部接收下来以后再进行转发。只需要得知目标地址即可开始转发。具有延迟较短的优势，但可能会发送错误帧</li></ul><h2 id="环路检测技术"><a href="#环路检测技术" class="headerlink" title="环路检测技术"></a>环路检测技术</h2><p>最坏的情况下，数据帧会在环路中被持续转发，数据帧的积累导致网络瘫痪</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h1><p>网络层服务：主机到主机的逻辑通信<br>传输层服务：主机中进程到进程的逻辑通信</p><ul><li>依赖于网络层的服务，如延时，带宽</li><li>并对网络层的服务进行增强，如数据丢失、顺序混乱、加密等</li></ul><p>可靠的、保序的传输：TCP</p><ul><li>多路复用，解复用</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li></ul><p>不可靠的、不保序的传输：UDP</p><ul><li>多路复用、解复用</li><li>没有尽力而为地为IP服务器添加更多的其他的额外的服务</li></ul><p>都不提供的服务：</p><ul><li>延时保证</li><li>带宽保证</li></ul><h1 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h1><h2 id="接收主机将到达地运输层报文定向到适当的套接字"><a href="#接收主机将到达地运输层报文定向到适当的套接字" class="headerlink" title="接收主机将到达地运输层报文定向到适当的套接字"></a>接收主机将到达地运输层报文定向到适当的套接字</h2><p>每个运输层报文段中具有几个字段<br>在接收端，运输层检查这些字段，表示出接收套接字，进而将报文段定向到该套接字<br><strong>将运输段报文段中的数据交付到正确的套接字地工作成为多路分解</strong></p><p>源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作为<strong>多路复用</strong></p><p><strong>它们在某层的单一协议何时被位于接下来的较高层的多个协议使用有关</strong></p><p><strong>运输层多路复用的要求：</strong></p><ol><li>套接字有唯一标识符</li><li>每个报文段有特殊字段来指示该报文段所要交付到的套接字</li></ol><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E7%AB%AF%E5%8F%A3.png" class><p>上述特殊字段是<strong>源端口号字段</strong>和<strong>目的端口号字段</strong><br>端口号是16比特的数，在0~65535之间。</p><ul><li>0~1023范围的端口号为周知端口号，是受限制的，留给HTTP(80号端口)、FTP(21号端口)、DNS(53号端口)等周知的应用层协议来使用<img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCPUDP.png" class><h2 id="无连接的多路复用与多路分解"><a href="#无连接的多路复用与多路分解" class="headerlink" title="无连接的多路复用与多路分解"></a>无连接的多路复用与多路分解</h2></li></ul><ol><li>主机A向主机B发送UDP报文</li><li>主机A的运输层创建一个运输层报文段，包括应用程序数据、目的IP、目的端口号和两个其他值、UDPSocket</li><li>运输层将得到的报文段传递到网络层</li><li>网络层将报文段封装到一个IP数据报并尽力将报文段交付给接收主机</li><li>主机B运输层检查报文段目标端口号，并将报文段交付给该端口号所标识的套接字</li><li>主机B有多个进程，每个进程有自己特定的UDP套接字和相应的端口号，当UDP报文段从网络到达时，主机B检查报文段的目的端口号，将每个报文段定向分解到相应的套接字</li></ol><p><strong>一个UDP套接字时一个二元组：目的主机IP和目的主机端口号</strong></p><p>若两个源主机IP不同，源端口号不同，但是目的主机IP和目的主机端口号相同的UDP报文段，那么这两个报文段就会被定向到相同的目标进程</p><p>UDP报文段源主机IP和源端口号的作用显然<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E7%AB%AF%E5%8F%A3%E5%8F%8D%E8%BD%AC.png" class></p><h2 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h2><p>与UDP不同，TCP套接字是一个四元组(前面已知)，TCP报文段的四部分必须完全一致才能被定向到一个相同的进程<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP0.png" class></p><h1 id="无连接传输UDP"><a href="#无连接传输UDP" class="headerlink" title="无连接传输UDP"></a>无连接传输UDP</h1><p>UDP的优点：</p><ol><li>采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并将其立即传递给网络层。<strong>TCP有拥塞控制机制</strong>，当源和目的主机的一条或多条链路变得极度拥塞时会遏制TCP发送方，TCP发送方仍然会发送，不管用多长时间。<strong>实时应用通常要求最小的发送速率，不希望过分地延迟报文段的发送，能容忍数据的丢失</strong></li><li><strong>无须连接建立</strong>，TCP不会引入建立连接的时延，而TCP会</li><li><strong>无连接状态</strong>，TCP需要在端系统中维护连接状态，包括接收和发送缓存、拥塞控制参数以及序号和确认号的参数。UDP不需要维护连接状态，也不跟踪这些参数</li><li>分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销</li></ol><h2 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h2><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP0.png" class><p>UDP首部只有4个字段，每个字段两个字节<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/789456.png" class><br><strong>长度</strong>：指示了在UDP报文段中的字节数(首部加数据)。接收方使用检验和来检查在报文段中是否出现了差错</p><h2 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h2><p><strong>UDP检验和提供了差错检测功能</strong>，检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。<br>发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段</p><p><strong>虽然UDP提供差错检测，但它对差错恢复无能为力。UDP的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告</strong></p><h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1.png" class><h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="经完全可靠信道的可靠数据传输-rdt1-0"><a href="#经完全可靠信道的可靠数据传输-rdt1-0" class="headerlink" title="经完全可靠信道的可靠数据传输 rdt1.0"></a>经完全可靠信道的可靠数据传输 rdt1.0</h3><p>在这个协议中，一个单元数据和一个分组没差别。所有分组是从发送方流向接收方；<br>有了完全可靠的信道，接收端就不需要提供任何反馈信息给发送方，因为不必担心差错；<br>假定接收方接收数据的速率能够和发送方发送数据的速率一样快，接收方没有必要请求发送方慢一点<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/rdt1.png" class></p><h3 id="经具有比特差错信道的可靠数据传输-rdt2-0"><a href="#经具有比特差错信道的可靠数据传输-rdt2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输 rdt2.0"></a>经具有比特差错信道的可靠数据传输 rdt2.0</h3><p><strong>自动重传请求(ARQ)协议</strong><br>这些控制报文使得接收方可以让发送方知道哪些内容被正确接受，哪些内容接收有误并因此需要重复，基于这样的重传机制为自动重传请求协议</p><p>此外，还需要另外三种协议功能来处理比特差错的情况</p><ul><li><strong>差错检测</strong>，如UDP使用因特网检验和字段是为了这个目的</li><li><strong>接收方反馈ACK/NAK</strong>：如”ACK”(肯定确认)和”NAK”(否定确认)，理论上，这些分组只需要一个比特长，0标示NAK，1标示ACK</li><li><strong>重传</strong>：接收方收到有差错的分组时，发送方将重传该报文</li></ul><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.png" class><h4 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h4><p>rdt2.0的缺陷是无法确认ACK和NAK一定是正确的<br>就是在rdt2.0基础上将发送方的数据进行分组</p><p> 如果收到受损的分组 ，则接收方将发送一个否定确认 。 如果不发送 NAK, 而是对上次正确接收的分组发送一个 ACK, 我们也能实现与 NAK — 样的效果 。 发送方接收到对同一个分组的两个 ACK （ 即接收冗余 ACK（ duplicate ACK））后 ， 就知道接收方没有正确接收到跟在被确认两次的分组后面的分组<br>发送方<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.11.png" class><br>接收方<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.12.png" class></p><h4 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h4><p>相比于rdt2.1，rdt2.2只使用ACK报</p><ul><li>接收方通过ACK告知最后一个被正确接收的分组</li><li>在ACK消息中显示地加入被正确分组的序列号</li></ul><p>发送方收到重复的ACK之后，采取与收到NAK消息相同的动作，重传当前分组<br>发送方<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.21.png" class><br>接收方<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.22.png" class></p><h3 id="经具有比特差错的丢包信道的可靠数据传输：rdt3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输：rdt3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输：rdt3.0"></a>经具有比特差错的丢包信道的可靠数据传输：rdt3.0</h3><p>让发送方负责检测和恢复丢包工作<br>在发送方和接收方之间加一个往返时延，当发送方在此时间内没有收到ACK，则重传该分组。<br><strong>这就在发送方和接收方的信道中引入了冗余数据分组的可能性</strong>，在rdt2.2中该问题已解决<br><strong>发送方应该做到</strong>：</p><ol><li>每次发送一个分组(包括第一次分组和重传分组)时，便启动一个定时器</li><li>响应定时器中断(采取适当动作)</li><li>终止定时器<br>发送方：<img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/rdt3.png" class></li></ol><h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>既然rdt3.0性能非常差，那么每次让发送方发送一定数量的分组而无需等待确认，可以解决该问题。</p><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%93%8D%E4%BD%9C.png" class><ol><li>必须增加序号范围：每个输送的分组(不包括重传)必须有一个唯一的序号，而且也许有多个在输送中的未确认的报文</li><li>协议中的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲哪些已发送但没有确认的分组</li><li>解决流水线的回复差错的两种基本方法：<strong>回退N步(GBN)和选择重传(SR)</strong></li></ol><h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><p><strong>基序号</strong>定义为最早未确认分组的序号，将<strong>下一个序号</strong>定义为最小的未使用序号(下一个待发分组的序号)<br><strong>N为窗口长度</strong></p><p>[0,base-1]对应已经发送但未被确认的分组<br>[base,nexteqnum-1]对应已经发送但未确认的分组<br>[nexteqnum,base+N-1] 对应要被立即发送的分组<br>直到流水线中未被确认的分组得到确认为止，大于等于base+N的序号时不能使用的<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/GBN.png" class><br>扩展的状态机：<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/GBN1.png" class><br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/GBN2.png" class></p><p>ACK机制：发送拥有最高序列号的、已被正确接收的分组的ACK</p><ul><li>可能产生ACK</li><li>只需要记住唯一的expectedeqnum</li></ul><p>乱序到达的分组</p><ul><li>直接丢弃-&gt;接收方没有缓存</li><li>重新确认序列号最大的、按序到达的分组</li></ul><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><ul><li>接收方对每个分组<strong>单独进行确认</strong><ul><li>设置<strong>缓存机制</strong>，缓存乱序到达的分组</li></ul></li><li>发送方只重传那些没收到ACK的分组 <ul><li>为每个窗口设置定时器</li></ul></li><li>发送方窗口<ul><li>N个连续的序列号</li><li>限制已发送且未确认的分组 </li></ul></li></ul><p>比GBN先进的地方是，</p><ul><li>为每个分组单独地设置计时器，当超时以后，没发出去的分组再单独重发，不必将后面的已经收到的重发</li><li>接收方也有一个滑动窗口，可以将乱序的分组放进缓存中去</li></ul><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/SR.png" class><p>当窗口中的所有分组都收到时，才将该窗口的分组交给上层应用</p><h1 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h1><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><strong>三次握手</strong>：前两个报文段不包含应用层数据；第三个报文段可以承载有效载荷</p><ul><li>点对点</li><li>可靠的、按序的字节流</li><li>流水线机制<ul><li>Tcp拥塞控制和流量控制机制，设置窗口尺寸 </li></ul></li><li>发送方/接收方缓存</li><li>全双工：同一连接中能够传输双向数据流</li><li>面向连接</li><li>流量控制机制</li></ul><p>TCP将数据引导到连接的<strong>发送缓存</strong>里，发送缓存是发起三次握手期间设置的缓存之一<br>TCP在方便的时候以报文段的形式发送数据。<br>TCP可从缓存中取出并放入报文段的数量受限于<strong>最大报文段长度MSS</strong>。MSS通常根据最初确定的由本地发送主机发送的<strong>最大链路层帧长度(最大传输单元)</strong>来设置</p><p>TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段</p><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E5%8F%91%E9%80%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BC%93%E5%AD%98.png" class><h2 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h2><p>MSS限制了报文段数据字段的最大长度<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.png" class><br>TCP首部一般是20字节(UDP8字节)<br>TCP报文段首部包括：</p><ul><li><strong>源端口和目的端口</strong></li><li><strong>检验和字段</strong></li><li>32比特的<strong>序号字段</strong>和32比特的<strong>确认号字段</strong></li><li>16比特的<strong>接收窗口字段</strong>，该字段用于流量控制</li><li>4比特的<strong>首部长度字段</strong>，该字段指示了以32比特的字为单位的TCP首部长度(通常该字段为空，所以TCP首部的典型长度为20字节)</li><li>可选与变长的<strong>选项字段</strong>，该字段用于发送方与接收方协商最大报文段长度时，或在高速网络环境下用作窗口调节因子时使用</li><li>16比特的<strong>标志字段</strong>，<ul><li>RST、SYN、FIN比特用于连接建立和拆除</li><li>明确拥塞通告中使用了CWR和ECE比特</li><li>当PSH比特被置位时，就指示接收方应立即将数据交给上层</li><li>URG比特用于指示报文段里存在着被发送端上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的<strong>紧急数据指针字段指出</strong></li></ul></li></ul><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/123456789.png" class><h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p><strong>序号</strong>以字节为编号，是该报文段首字节的字节流编号。500000字节大小文件，MSS为1000，则序号分别为0，1000，2000<br><strong>主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号</strong>，确认n-1及之前的字节<br>TCP只确认该流中至第一个丢失字节为止的字节，所以被称为提供<strong>累计确认</strong><br>主机收到失序报文段，由实现TCP的编程人员去处理</p><ul><li>接收方立即丢弃失序报文段</li><li>接收方保留时失序报文段，并等待缺少的字节以填补该间隔</li></ul><h2 id="往返时间估计与超时"><a href="#往返时间估计与超时" class="headerlink" title="往返时间估计与超时"></a>往返时间估计与超时</h2><h3 id="估计往返时间"><a href="#估计往返时间" class="headerlink" title="估计往返时间"></a>估计往返时间</h3><p>大多数TCP仅在某一时刻做sampleRTT测量，不为每个发送的报文段做sampleRTT<br>TCP维持一个SampleRTT均值(EstimatedRTT)<br>EstimatedRTT=(1-α)<em>EstimatedRTT+α</em>SampleRTT，推荐α取0.125<br>偏差DevRTT=(1-β)<em>DevRTT+β</em>|SampleRTT-EstimatedRTT|,推荐β取0.25<br>TimeoutInterval=EstimatedRTT+4*DevRTT;当出现超时，值加倍；只要收到报文段并更新EstimatedRTT，就使用公式重新计算</p><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><ul><li>TCP在IP不可靠的服务基础上建立了rdt<ul><li>管道化的报文段</li><li>累计确认</li><li>单个重传定时器</li><li>是否可以接受乱序的，没有规范</li></ul></li><li>通过以下事件触发重传<ul><li>超时(只重发那个最早的未确认的段)</li><li>重复的确认，例如收到ACK50之后又收到3个冗余的ACK50</li></ul></li><li>首先考虑简化的TCP发送发<ul><li>忽略重复的确认</li><li>忽略流量控制和拥塞控制</li></ul></li></ul><p><strong>产生TCP ACk的建议:</strong><br></p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p><strong>流量控制就是让发送方的发送速率不要太快，要接收方来得及接收</strong><br>利用滑动窗口机制方便在TCP连接上实现对发送方的流量控制</p><ul><li>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小</li><li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文(该探测报文超过一段时间未收到确认后也会重传)</li></ul><p>RcvBuffer：接受主机分配的接收缓存<br>LastByteRead：主机 B 上的应用进程从缓存读出的数据流的最后一个字节的编号 。<br>LastByteRcvd : 从网络中到达的并且已放入主机 B 接收缓存中的数据流的最后一个字节的编号<br>Tcp不允许已分配的缓存溢出，必须有：LastByteRcvd - LastByteRead &lt;= RcvBuffer<br>接受窗口用rwnd表示，rwnd = RcvBuffer - [ LastByteRcvd - LastByteRead ]<br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/8678964165.png" class></p><p> 主机 B 通过把当前的rwnd 值放入它发给主机 A 的报文段接收窗口字段中 ， 通知主机 A 它在该连接的缓存中还有多少可用空间。开始时，主机 B设定 rwnd = RcvBuffer<br> 主机 A 轮流跟踪两个变量 ， LastByteSent 和 LastByteAcked</p><p>主机 A 在该连接的整个生命周期须保证:LastByteSent-LastByteAcked &lt;= rwnd<br><strong>当主机 B 的接收窗口为 0 时,主机 A 继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认 。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd 值</strong></p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" class><p>假定：</p><ol><li>数据是单方向传送，而另一个方向只传送确认</li><li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定</li><li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位</li></ol><ul><li>发送方维护一个<strong>拥塞窗口cwnd</strong>的状态变量，其值取决于<strong>网络的拥塞程度</strong>，并且<strong>动态变化</strong><ul><li>拥塞窗口<strong>cwnd的维护原则</strong>：只要窗口没有出现拥塞，拥塞窗口就再增大一些；但只要网络出现拥塞，拥塞窗口就减少一些</li><li>判断出现网络拥塞的<strong>依据</strong>：没有按时收到应当到达的报文(即<strong>发生超时重传</strong>)</li></ul></li><li>发送方将拥塞窗口作为<strong>发送窗口swnd</strong>，即<strong>swnd=cwnd</strong></li><li>维护一个慢开始门限<strong>ssthresh</strong>状态变量：<ul><li>当cwnd&lt; ssthresh时，使用慢开始算法；</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法</li><li>当cwnd==ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法</li></ul></li></ul><h3 id="TCP拥塞控制算法：慢启动、拥塞避免、快速恢复"><a href="#TCP拥塞控制算法：慢启动、拥塞避免、快速恢复" class="headerlink" title="TCP拥塞控制算法：慢启动、拥塞避免、快速恢复"></a>TCP拥塞控制算法：慢启动、拥塞避免、快速恢复</h3><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6FSM%E6%8F%8F%E8%BF%B0.png" class><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p><strong>三次握手：</strong><br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class><br><strong>客户ＴＣＰ经历的典型的ＴＣＰ状态序列</strong><br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%AE%A2%E6%88%B7%EF%BC%B4%EF%BC%A3%EF%BC%B0%E7%BB%8F%E5%8E%86%E7%9A%84%E5%85%B8%E5%9E%8B%E7%9A%84%EF%BC%B4%EF%BC%A3%EF%BC%B0%E7%8A%B6%E6%80%81%E5%BA%8F%E5%88%97.png" class><br><strong>服务端TCP经历的典型的TCP状态序列</strong><br><img src="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BE%B7%E7%93%A6dawdle4.png" class></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>应用层</title>
    <link href="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h4 id="应用程序体系结构"><a href="#应用程序体系结构" class="headerlink" title="应用程序体系结构"></a>应用程序体系结构</h4><p>由应用程序研发者决定，使用如客户-服务器体系结构(C/S模式)，P2P体系结构等<br>各个结构的缺点：</p><ul><li>C/S模式的可扩展性比较差，用户达到一定阈值会断崖式下降，可靠性也比较差</li><li>P2P管理困难</li></ul><h4 id="分布式进程需要解决的问题："><a href="#分布式进程需要解决的问题：" class="headerlink" title="分布式进程需要解决的问题："></a>分布式进程需要解决的问题：</h4><ol><li>进程标示和寻址问题(服务用户)</li><li>传输层-应用层提供服务是如何(服务)<ul><li>位置：层间界面的SAP(TCP/IP:socket)</li><li>形式：应用程序接口API(TCP/IP:socket API)</li></ul></li><li>如何使用传输层提供的服务、实现进程间报文的交换，实现应用(用户使用服务)</li></ol><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li>对进程进行编址：引入端口号</li><li>传输层提供的服务：需要穿过层间的信息<ul><li>层间接口必须要携带的的信息：要传输的报文(SDU)、应用进程的标示(IP+TCP或UDP端口)、对方的应用程序的标示(IP+TCP或UDP端口)</li><li>传输层实体根据这些信息进行TCP报文段/UDP数据段的封装</li></ul></li><li><ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，使用OS提供的API，调用网络基础设施提供通信服务传报文，实现应用时序</li></ul></li></ol><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p>客户、服务器<br>进程之间通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接受报文。套接字也被称为<strong>应用程序编程接口</strong>。<br>标识进程需要定义两种信息：主机地址+目的主机中接受进程的标识符。标识符，IP地址＋端口号<br><strong>TCP socket返回一个整数，代表一个四元组，是本地标示</strong><br><strong>UDP socket返回整数，代表本地IP和端口的二元组，但是在发送时，必须指定对方的IP和udp端口</strong><br>优点：便于管理、穿过层间的信息量最少</p><h4 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h4><p>运输层协议为调用它的应用程序提供四个方面的服务：</p><ul><li>可靠数据传输</li><li>吞吐量</li><li>定时</li><li>安全性<br>可用吞吐量是指发送进程能够向接收进程交付比特的速率<h4 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h4><strong>tcp服务</strong>模型包括面向连接服务和可靠数据传输服务，还拥有拥塞控制机制<br><strong>udp服务</strong>实现简单、无头部开销，仅提供最小服务<br>目前因特网没有提供吞吐量和定时的保证<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4>应用层协议定义：</li><li>交换报文的类型</li><li>各种报文类型的语法</li><li>字段的语义</li><li>确定一个进程何时以及如何发送报文</li></ul><p>注：应用层协议只是网络应用的一部分。<br>web协议是http，电子邮件协议是SMTP</p><h1 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和<a href="https://www.malchinee.top/2022/09/04/HTTP/">HTTP</a></h1><h4 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h4><p>WEB页面由对象组成<br>HTML基本文件通过URL地址引用页面中的其他对象，URL由两部分组成：存放对象的服务器主机名和对象的路径名<br>http使用TCP作为它的支撑运输协议，一个客户进程发送的每个HTTP请求报文都能最终完整地到达服务器，服务器进程发出的每个响应报文都能最终完整地到达客户<br>HTTP是<strong>无状态协议</strong>，不保存任何客户的信息</p><h4 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h4><p>非持续连接：每个请求/响应都通过单独的TCP连接发送<br>持续连接：所有的请求和响应都经过相同的TCP连接发送<br>默认情况下使用持续连接</p><h5 id="采用非持续连接的HTTP"><a href="#采用非持续连接的HTTP" class="headerlink" title="采用非持续连接的HTTP"></a>采用非持续连接的HTTP</h5><p>如果客户向服务器访问含有11个对象的网页（1个html基本文件和10个jpeg图像），需要建立11次连接<br>往返时间RTT：一个小的分组从客户端到服务器，再回到客户端的时间(传输时间忽略不计)。包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理的时延。<br>用户点击某超链接时，总的响应时间就是两个RTT（一个RTT用于建立连接，另一个用于请求和接受对象）加上服务器传输html文件的时间</p><h5 id="采用持续连接的TCP"><a href="#采用持续连接的TCP" class="headerlink" title="采用持续连接的TCP"></a>采用持续连接的TCP</h5><p>服务器在发送响应后保持该TCP连接打开，若长时间未使用，HTTP服务器就关闭该连接<br>使用流水线的方式</p><h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a><a href="https://www.malchinee.top/2022/09/06/HTTP%E9%A6%96%E9%83%A8/">HTTP报文格式</a></h4><img src="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" class><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><p>get方法：请求一个对象<br>post方法：提交表单<br>head方法：类似于get方法但是不返回请求对象，常用于调试跟踪<br>put方法：允许用户上传对象到指定的web服务器上的指定的路径<br>delete方法：允许用户或应用程序删除web服务器上的对象</p><h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><p>常见的状态码和相关短语：</p><ul><li>200 OK：请求成功，信息返回在响应报文中</li><li>301 Moved Permanently：请求的对象已经被永久转移了，新的url定义在响应报文的location：首部行中。客户软件将自动获取新的url</li><li>400 Bad Request：一个通用的差错代码，指示该请求不能被服务器理解。</li><li>404 Not Found：被请求的文档不在服务器上</li><li>505 HTTP Version Not Supported：服务器不支持请求报文使用的http协议版本</li></ul><h4 id="用户和服务器的交互：cookie"><a href="#用户和服务器的交互：cookie" class="headerlink" title="用户和服务器的交互：cookie"></a>用户和服务器的交互：cookie</h4><p>4个组件</p><ul><li>在HTTP响应报文中的一个cookie首部行</li><li>在HTTP请求报文中的一个cookie首部行</li><li>在用户端系统中保留一个cookie文件，并由用户浏览器进行管理</li><li>位于web站点的一个后端数据库</li></ul><h4 id="web缓存（代理服务器）"><a href="#web缓存（代理服务器）" class="headerlink" title="web缓存（代理服务器）"></a>web缓存（代理服务器）</h4><p>web缓存服务器既是服务器又是客户。<br>自己的理解：当用户访问某web站点时，浏览器创建与缓存服务器的TCP连接，然后在缓存服务器中寻找是否有该对象，若有，则发送响应报文返回；若没有，则与创建该对象的初始服务器建立一条TCP连接，发送请求报文，初始服务器返回响应报文，然后web缓存器接受到该对象，在本地存储区建立副本，然后通过响应报文将对象返回给用户。</p><h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>如果请求报文中使用GET方法，并且请求报文中包含一个”If-modified-Since”首部行，那么这个HTTP请求报文就是一个条件GET请求报文<br>如果客户再次访问该对象（代理服务器已保存），代理服务器向初始服务器使用一个条件GET方法，如果”If-modified-Since”的值等于最后一次服务器发送的响应报文中的Last-Modified:首部行的值，那么服务器的响应报文没有想要请求的对象（避免浪费带宽）</p><h1 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h1><p>客户端上载文件到服务器，也可以把服务器相应目录下的文件下载到本地<br>一开始是控制连接：FTP守候的端口TCP：21，等待FTP客户端的连接请求；<br>然后身份认证，客户端向服务端发出一系列命令<br><strong>数据传输是通过另一个TCP上进行的</strong><br>FTP是一个<strong>有状态的</strong>协议</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>因特网电子邮件的三个主要组成部分：<strong>用户代理(如outlook)</strong>，<strong>邮件服务器</strong>，<strong>简单邮件传输协议(SMTP)</strong><br>一个典型的发送邮件的过程：从发送方的用户代理开始，传输到发送方的邮件服务器，在传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。<br>SMTP使用TCP可靠数据传输服务，既是客户端也是服务端</p><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><img src="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP.png" class><p>服务器守候在25号端口，等待客户端建立连接<br>分三个阶段：握手，传报文，关闭。</p><h4 id="与http的对比"><a href="#与http的对比" class="headerlink" title="与http的对比"></a>与http的对比</h4><ul><li>HTTP协议采用<strong>拉协议</strong>，某些人在web服务器上装载信息，用户使用HTTP服务器从该服务器上拉取这些信息。TCP连接时由这些想要接收文件的机器发起的<br>；SMTP基本上是<strong>推协议</strong>，发送邮件的服务器把文件推向接收邮件的服务器，这个TCP连接是要发送该文件的机器发起的</li><li>SMTP要求每个报文采用7比特的ASCLL码格式，如果某报文使用非7比特的ASCLL码或者使用二进制，则报文必须按7比特ASCLL码进行编码；HTTP不受这种限制</li><li><strong>HTTP把每个对象封装到它自己的HTTP响应报文中，而SMTP把所有报文对象放在一个报文之中</strong></li></ul><h4 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h4><p>每个首部必须含有一个From：首部行和一个To：首部行；可能含有subject：首部行以及其他可选的首部行。报文首部之后，紧跟一个空白行。然后是以ASCLL表示的报文体</p><h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>用户代理没办法到达一个不可达的目的地接收服务器。<br>接收方的用户代理，通过<strong>第三版的邮局协议(POP3)</strong>、<strong>因特网邮件访问协议(IMAP)以及HTTP</strong>“拉取”邮件服务器上的报文传给它的本地PC</p><h5 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h5><p>协议简单，功能有限<br>三个阶段：</p><ul><li><strong>特许</strong>：两个主要命令 user &lt; user name &gt;和pass &lt; password &gt;用户代理以明文形式发送用户名和口令以鉴别用户</li><li><strong>事务处理</strong>：用户代理取回报文；同时，还可以：对报文做删除标记，取消报文的删除标记，获取邮件的统计信息</li><li><strong>更新</strong>：出现在客户发出quit命令之后，目的是结束POP3会话；这时，邮件服务器删除那些被标记为删除的报文</li></ul><p>服务器对命令做出的回答有两种，+OK和-ERR</p><h5 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h5><p>IMAP服务器把每个报文和一个文件夹联系起来，允许用文件夹组织消息<br>IMAP服务器维护了IMAP会话的用户状态信息</p><h4 id="基于WEB的电子邮件"><a href="#基于WEB的电子邮件" class="headerlink" title="基于WEB的电子邮件"></a>基于WEB的电子邮件</h4><p>用户代理就成了浏览器。</p><h1 id="DNS：因特网的目录式服务"><a href="#DNS：因特网的目录式服务" class="headerlink" title="DNS：因特网的目录式服务"></a>DNS：因特网的目录式服务</h1><p>将主机名转化为IP地址</p><h4 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h4><p>DNS是</p><ul><li>一个由分层的DNS服务器实现的分布式数据库</li><li>一个使主机能够查询分布式数据库的应用层协议</li></ul><p><strong>DNS运行在UDP之上，使用53号端口</strong><br>除此之外，还提供</p><ul><li>主机别名</li><li>邮件服务器别名</li><li>负载分配<h5 id="分布式、层级数据库"><a href="#分布式、层级数据库" class="headerlink" title="分布式、层级数据库"></a>分布式、层级数据库</h5>主机域名到ip地址之间的映射分布在DNS服务器上，有三种DNS服务器：根DNS服务器，顶级域DNS服务器和权威DNS服务器，他们中的前者为后者提供IP地址<br>本地DNS服务器不属于层级结构中，通常主机向本地DNS服务器查询属于递归查询(逐级返回IP地址)，而其他查询属于迭代查询(本地DNS服务器一直问问问)<h5 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h5>当某DNS服务器接受某DNS回答时，能将映射缓存到本地存储器中，即使它不是主机名的权威服务器，它也能提供IP地址，但缓存不是永久的</li></ul><p>DNS解析域名流程：客户端向最近的，计算机设置的默认的DNS服务器发送请求，如果没有该请求，该DNS服务器向根DNS服务器发送请求，一级一级递归查询，从最高的一级往下查询，一步一步查到ip地址</p><h4 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h4><h5 id="资源记录"><a href="#资源记录" class="headerlink" title="资源记录"></a>资源记录</h5><p>(Name , Value , Type , TTL)<br>TTL是该记录的生存时间，TTL维护权威记录就是无限大，而维护缓存记录就是有限值<br>Name和Value的值取决于Type：</p><ul><li>“<strong>Type=A</strong>“，则Name是主机名，Value是该主机名对应的IP地址，一条A类型的资源记录提供了标准的主机名到IP地址的映射</li><li>“<strong>Type=NS</strong>“，则Name是个域，Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名</li><li>“<strong>Type=CNAME</strong>“，则Value是个别名为Name的主机对应的规范主机名</li><li>“<strong>Type=MX</strong>“，Value是个别名为Name的邮件服务器的规范主机名</li></ul><h5 id="dns报文格式"><a href="#dns报文格式" class="headerlink" title="dns报文格式"></a>dns报文格式</h5><img src="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/dns.png" class><h1 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h1><h4 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h4><p>参与一个特定的文件分发的所有对等方的集合被称为一个<strong>洪流</strong>。在一个洪流中的对等方彼此下载等长度的<strong>文件块</strong>，典型的块长度为256KB。<br>每个洪流都以一个基础设施节点：<strong>追踪器</strong>，每个对等方加入洪流时，向追踪器注册自己，并且周期性地通知追踪器它仍在该洪流中。<br>一个新的对等方加入该洪流时，追踪器随机地从参与对等方地集合中选择对等方的一个子集<br><strong>最稀缺优先</strong>：解决<strong>某对等方应该从它的另据请求哪些块，应当向哪些向它请求的邻居发送块</strong>的问题。思路：</p><ul><li>针对它没有的块在它的邻居中最稀缺的块，并首先请求那些最稀缺的块。</li><li>对换算法：对等方能够趋向于找到彼此的协调的速率上载。(具体实现机制略)</li></ul><h1 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h1><h2 id="因特网视频"><a href="#因特网视频" class="headerlink" title="因特网视频"></a>因特网视频</h2><p>流视频的最为重要的性能度量：平均端到端的吞吐量</p><h2 id="HTTP和DASH"><a href="#HTTP和DASH" class="headerlink" title="HTTP和DASH"></a>HTTP和DASH</h2><p><strong>DASH</strong>：经HTTP的动态适应流<br>视频编码为几个不同的版本，每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。当可用带宽较高时，客户自然的选择来自高速率版本的块；较低时同理。</p><p>DASH允许用户使用不同的以太网接入速率流式播放具有不同编码速率的视频。</p><p>使用DASH后，每个视频版本存储在HTTP服务器中，每个版本都有不同的URL。<br>HTTP服务器有<strong>告示文件</strong>，为每个版本提供了一个URL及其比特率<br>客户首先请求该告示文件并得知各种各样的版本。然后客户通过在HTTP GET请求报文中对每块指定一个URL和一个字节范围，一次选择一块。在下载块的同时，客户也测量接收带宽并运行一个<strong>速率决定算法</strong>来选择下次请求的块</p><h2 id="内容分发网CDN"><a href="#内容分发网CDN" class="headerlink" title="内容分发网CDN"></a>内容分发网CDN</h2><p>CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置<br>CDN可以是</p><ul><li>专用CDN，由内容提供商自己所拥有</li><li>第三方CDN，代表多个内容提供商分发内容</li></ul><p>CDN采用两种不同的服务器安置原则：</p><ul><li>深入：通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中</li><li>邀请做客：通过在少量关键位置建造大集群来邀请到ISP做客，这些CDN通常将它们的集群放置在因特网交换点(IXP)。</li></ul><p>CDN没有将视频推入它们的集群中，而是采取<strong>拉策略</strong>：如果客户向一个未存储该视频的集群请求某视频，则该集群检索该视频，向客户流式传输视频的同时在本地存储一个副本。类似因特网缓存，当某集群存储器变满时，它删除不经常请求的视频</p><h3 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h3><p>用户浏览器指令检索一个特定的视频，CDN必须截获该请求，以便能够：</p><ul><li>确定此时适合用于该客户的CDN服务器集群</li><li>将客户的请求重定向到该集群的某台服务器.</li></ul><img src="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E6%88%AA%E8%8E%B7%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91.png" class><h3 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h3><ul><li>地理上最为临近：这种简单的策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群</li><li>实时测量：CDN能苟对其集群和客户之间的时延和丢包性能执行周期性的实时测量。</li></ul><h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><p>网络应用程序有两类：</p><ul><li>由协议标准中所定义的操作的实现：定义其操作的这些规则周知，客户程序和服务器程序必须遵守该RFC所规定的规则</li><li>专用的网络应用程序：这些代码并没有实现一个开放的协议，其他独立的开发者将不能开发出和该应用程序交互的代码</li></ul><p>收发数据有四个阶段</p><ol><li>创建套接字</li><li>将管道连接到服务器端的套接字上</li><li>收发阶段</li><li>断开管道并删除套接字</li></ol><p>使用python：</p><h2 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h2><img src="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/UDP.png" class><h3 id="UDPClient-py"><a href="#UDPClient-py" class="headerlink" title="UDPClient.py"></a>UDPClient.py</h3><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs python">//导包<br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>//设置变量<br>serverName=<span class="hljs-string">&#x27;hostname&#x27;</span><br>serverPort=<span class="hljs-number">12000</span><br>//创建客户套接字，AF_INET：使用IPv4，SOCK_DGRAM：使用UDP协议<br>clientSocket=socket(<span class="hljs-string">&#x27;Input lowercase sentence:&#x27;</span>)<br>message=raw_input(<span class="hljs-string">&#x27;Input lowercase sentence:&#x27;</span>)<br>//将报文由字符串类型转换为字节类型，方法 sendto () 为报文附上目的地址( serverName , serverPort ) 并且向进程的套接字 clientSocket 发送结果分组 <br>clientSocket,sendto(message.encode(),(serverName,serverPort))<br>//分组的数据放到modifiedMessage中，源地址放到serverAddress中<br>modifiedMessage,serverAddress=clientSocket.recvfrom(<span class="hljs-number">2048</span>)<br>//向屏幕打印<br><span class="hljs-built_in">print</span>(modifiedMessage.decode())<br>//关闭套接字，然后关闭进程<br>clientSocket.close()<br><br></code></pre></td></tr></table></figure><p>当创建套接字时,我们并没有指定客户套接字的端口号;相反,我们让操作系统为我们做这件事.</p><h3 id="UDPserver-py"><a href="#UDPserver-py" class="headerlink" title="UDPserver.py"></a>UDPserver.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">//导包<br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>//同上<br>serverPort=<span class="hljs-number">12000</span><br>serverSocket=socket(AF_INET,SOCK_DGRAM)<br>//将端口号<span class="hljs-number">12000</span>与该服务器的套接字绑定<br>serverSocket.bind(<span class="hljs-string">&#x27;&#x27;</span>,serverPort)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The server is ready to receive&quot;</span>)<br><span class="hljs-keyword">while</span> true:<br>    //保存变量<br>    message,clientAddress=serverSocket.recvfrom(<span class="hljs-number">2048</span>)<br>    //小写转大写<br>    modifiedMessage=message.decode.upper()<br>    //将客户的地址附到大写的报文上，并将所得的分组发送到服务器的套接字中<br>    serverSocket.sendto(modifiedMessage.encode(),clientAddress)<br></code></pre></td></tr></table></figure><p>将端口号与套接字绑定：当任何人向位于该服务器的IP地址的端口12000发送一个分组，该分组将导向该套接字</p><h2 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h2><p>欢迎套接字和连接套接字<br>客户套接字和服务器连接套接字直接通过一根管道连接<br><img src="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/TCP.png" class></p><img src="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/TCP1.png" class><h3 id="TCPClient-py"><a href="#TCPClient-py" class="headerlink" title="TCPClient.py"></a>TCPClient.py</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//导包</span><br>from socket import *<br><span class="hljs-comment">//设置变量</span><br>serverName=&#x27;servername&#x27;<br>serverPort=12000<br><span class="hljs-comment">//创建客户套接字</span><br>clientSocket=socket(AF_INET,SOCK_STREAM)<br><span class="hljs-comment">//创建TCP连接</span><br>clientSocket.connect((serverName,serverPort))<br><span class="hljs-comment">//获得句子</span><br>sentence=raw_input(&#x27;<span class="hljs-keyword">input</span> lowercase sentence)<br><span class="hljs-comment">//发送句子,encode方法转字节类型</span><br>clientSocket.send(sentence.<span class="hljs-keyword">encode</span>())<br><span class="hljs-comment">//字符到达服务器时，它们被放置在字符串modifiedSentence中</span><br>modifiedSentence=clientSocket.recv(1024)<br><span class="hljs-keyword">print</span>(&#x27;From Server:&#x27;,modifiedSentence.<span class="hljs-keyword">decode</span>())<br><span class="hljs-comment">//关闭套接字</span><br>clientSocket.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure><h3 id="TCPServer-py"><a href="#TCPServer-py" class="headerlink" title="TCPServer.py"></a>TCPServer.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverPort=<span class="hljs-number">12000</span><br>//创建服务端套接字<br>serverSocket=socket(AF_INET,SOCK_STREAM)<br>//服务器端口与与该套接字关联<br>serverSocket.bind((<span class="hljs-string">&#x27;&#x27;</span>,serverPort))<br>//等待某客户敲门<br>serverSocket.listen(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The server is ready to receive&#x27;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    //创建一个新的套接字，由这个特定的客户专用<br>    connectionSocket,addr=serverSocket.accept()<br>    //将二进制解码成字符串<br>    sentence=connectionSocket.recv(<span class="hljs-number">1024</span>).decode()<br>    //转换大小写<br>    capitalizedSentence=sentence.upper()<br>    //将字符串编码省二进制并且发送给客户端<br>    connectionSocket.send(capitalizedSentence.encode())<br>    //关闭套接字<br>    connectionSocket.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
